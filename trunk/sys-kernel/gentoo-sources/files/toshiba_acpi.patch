--- linux-2.6.20-gentoo.orig/drivers/acpi/toshiba_acpi.c	2007-03-11 23:53:23.000000000 +0200
+++ linux-2.6.20-gentoo/drivers/acpi/toshiba_acpi.c	2007-03-12 00:39:41.000000000 +0200
@@ -33,7 +33,7 @@
  *
  */
 
-#define TOSHIBA_ACPI_VERSION	"0.18"
+#define TOSHIBA_ACPI_VERSION	"0.18-p1"
 #define PROC_INTERFACE_VERSION	1
 
 #include <linux/kernel.h>
@@ -216,6 +216,7 @@
 static int force_fan;
 static int last_key_event;
 static int key_event_valid;
+static int arbitrary, arbitrary2, arbitrary1;
 
 typedef struct _ProcItem {
 	const char *name;
@@ -223,6 +224,28 @@
 	unsigned long (*write_func) (const char *, unsigned long);
 } ProcItem;
 
+
+static acpi_status hci_write2(u32 reg, u32 in1, u32 in2, u32* result)
+{
+        u32 in[HCI_WORDS] = { HCI_SET, reg, in1, in2, 0, 0 };
+        u32 out[HCI_WORDS];
+        acpi_status status = hci_raw(in, out);
+        *result = (status == AE_OK) ? out[0] : HCI_FAILURE;
+        return status;
+}
+
+static acpi_status hci_read2(u32 reg, u32* out1, u32* out2, u32* result)
+{
+        u32 in[HCI_WORDS] = { HCI_GET, reg, *out1, *out2, 0, 0 };
+        u32 out[HCI_WORDS];
+        acpi_status status = hci_raw(in, out);
+        *out1 = out[2];
+        *out2 = out[3];
+        *result = (status == AE_OK) ? out[0] : HCI_FAILURE;
+        return status;
+}
+
+
 /* proc file handlers
  */
 
@@ -482,6 +505,162 @@
 	return count;
 }
 
+static char* read_wk(char* p)
+{
+        u32 hci_result;
+        u32 value, value2;
+        value = 0;
+        value2 = 0x0001;
+        hci_read2(0x0056, &value, &value2, &hci_result);
+        if (hci_result == HCI_SUCCESS) {
+                p += sprintf(p,"wireless key:                  %d\n", value );
+        } else {
+                p += sprintf(p, "ERROR\n");
+        }
+
+        return p;
+}
+
+static char* read_bt(char* p)
+{
+        u32 hci_result;
+        u32 value, value2;
+        value = 0;
+        value2 = 0;
+        hci_read2(0x0056, &value, &value2, &hci_result);
+        if (hci_result == HCI_SUCCESS) {
+/*              p += sprintf(p,"present:                  %d\n", value);*/
+                p += sprintf(p,"present:                  %d\n", (value & 0x0f)?1:0);
+        } else {
+                p += sprintf(p, "ERROR\n");
+        }
+        value = 0;
+        value2 = 0x0001;
+        hci_read2(0x0056, &value, &value2, &hci_result);
+        if (hci_result == HCI_SUCCESS) {
+                p += sprintf(p,"power:                    %d\n", (value & 128) >> 7);
+                p += sprintf(p,"attach:                   %d\n", (value &  64) >> 6);
+                p += sprintf(p,"wireless:                 %d\n", (value & 512) >> 9);
+        } else {
+                p += sprintf(p, "ERROR\n");
+        }
+
+        return p;
+}
+
+static unsigned long write_bt(const char* buffer, unsigned long count)
+{
+        int value, value2;
+        u32 hci_result;
+        value2 = 0x0080;
+
+        if (sscanf(buffer, " power : %i", &value) == 1 &&
+                        value >= 0 && value <= 1) {
+                hci_write2(0x0056, value, value2, &hci_result);
+                if (hci_result != HCI_SUCCESS)
+                        return -EFAULT;
+        } else
+        if (sscanf(buffer, " attach : %i", &value) == 1 &&
+                        value >= 0 && value <= 1) {
+                value2 = 0x0040;
+                hci_write2(0x0056, value, value2, &hci_result);
+                if (hci_result != HCI_SUCCESS)
+                        return -EFAULT;
+        } else
+        if (sscanf(buffer, " orinoco : %i", &value) == 1 &&
+                        value >= 0 && value <= 1) {
+                value2 = 0x0200;
+                hci_write2(0x0056, value, value2, &hci_result);
+                if (hci_result != HCI_SUCCESS)
+                        return -EFAULT;
+        } else {
+                return -EINVAL;
+        }
+
+        return count;
+}
+
+static char* read_arb(char* p)
+{
+        u32 hci_result;
+        u32 value, value2;
+        value = 0;
+        value2 = arbitrary2;
+                p += sprintf(p,"arg1 :                  %d\n", value  );
+                p += sprintf(p,"arg2 :                  %d\n", value2 );
+        hci_read2(arbitrary, &value, &value2, &hci_result);
+        if (hci_result == HCI_SUCCESS) {
+                p += sprintf(p,"arbitrary call:                  %d\n", arbitrary);
+
+                p += sprintf(p,"return1:                  %x\n", value);
+                p += sprintf(p,"return2:                  %x\n",value2);
+        } else
+                p += sprintf(p, "ERROR\n");
+
+        return p;
+}
+
+static unsigned long write_arb(const char* buffer, unsigned long count)
+{
+        int value, value2, i;
+        u32 hci_result;
+        value2 = 0x0080;
+
+        sscanf(buffer, " arb : %i", &value) ;
+        	arbitrary=value;
+        i=0;
+        while(buffer[i]!=';')i++;  
+        if (sscanf(buffer+i+1, " arb2 : %i", &value) == 1 )
+        	arbitrary2=value;
+        else      
+                return -EINVAL;
+
+        return count;
+}
+
+static char* read_arb_c(char* p)
+{
+	u32 hci_result;
+	u32 value, value2;
+
+	value = arbitrary1;
+	value2 = arbitrary2;
+	p += sprintf(p,"arg1 :                  %d\n", value  );
+	p += sprintf(p,"arg2 :                  %d\n", value2 );
+
+	hci_write2(arbitrary, value, value2, &hci_result);
+	if (hci_result == HCI_SUCCESS) {
+		p += sprintf(p,"arbitrary call:                  %d\n", arbitrary);
+		p += sprintf(p,"return1:                  %d\n", value);
+		p += sprintf(p,"return2:                  %d\n",value2);
+        } else
+		p += sprintf(p, "ERROR\n");
+
+	return p;
+}
+
+static unsigned long write_arb_c(const char* buffer, unsigned long count)
+{
+	int value, value2, i;
+	u32 hci_result;
+	value2 = 0x0080;
+
+	sscanf(buffer, " arb : %i", &value) ;
+	arbitrary=value;
+	i=0;
+	while(buffer[i]!=';')i++;
+	sscanf(buffer+i+1, " arb2 : %i", &value);
+	arbitrary2=value;
+	i++;  
+	while(buffer[i]!=';')i++;  
+	if (sscanf(buffer+i+1, " arb1 : %i", &value) == 1 )
+		arbitrary1=value;
+	else      
+		return -EINVAL;
+
+	return count;
+}
+
 static char *read_version(char *p)
 {
 	p += sprintf(p, "driver:                  %s\n", TOSHIBA_ACPI_VERSION);
@@ -501,6 +680,8 @@
 	{"fan", read_fan, write_fan},
 	{"keys", read_keys, write_keys},
 	{"version", read_version, NULL},
+	{ "wireless_key", read_wk, 0},
+	{ "bluetooth", read_bt, write_bt},
 	{NULL}
 };
 
