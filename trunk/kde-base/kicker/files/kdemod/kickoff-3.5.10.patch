diff -Nurp kicker.orig/applets/clock/clock.cpp kicker/applets/clock/clock.cpp
--- kicker.orig/applets/clock/clock.cpp	2008-08-19 18:16:58.000000000 +0000
+++ kicker/applets/clock/clock.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -863,8 +863,8 @@ ClockApplet::ClockApplet(const QString& 
       _calendar(0),
       _disableCalendar(false),
       _clock(0),
-      _timer(new QTimer(this)),
-      m_layoutTimer(new QTimer(this)),
+      _timer(new QTimer(this, "ClockApplet::_timer")),
+      m_layoutTimer(new QTimer(this, "m_layoutTimer")),
       m_layoutDelay(0),
       m_followBackgroundSetting(true),
       m_dateFollowBackgroundSetting(true),
diff -Nurp kicker.orig/applets/clock/clock.cpp.orig kicker/applets/clock/clock.cpp.orig
--- kicker.orig/applets/clock/clock.cpp.orig	1970-01-01 00:00:00.000000000 +0000
+++ kicker/applets/clock/clock.cpp.orig	2008-08-19 18:16:58.000000000 +0000
@@ -0,0 +1,1821 @@
+/************************************************************
+
+Copyright (c) 1996-2002 the kicker authors. See file AUTHORS.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#include <cstdlib>
+#include <ctime>
+#include <time.h>
+
+#include <qcheckbox.h>
+#include <qcursor.h>
+#include <qgroupbox.h>
+#include <qimage.h>
+#include <qpainter.h>
+#include <qtimer.h>
+#include <qtooltip.h>
+#include <qclipboard.h>
+#include <qtabwidget.h>
+#include <qwidgetstack.h>
+#include <qcombobox.h>
+
+#include <kapplication.h>
+#include <kdebug.h>
+#include <kcolorbutton.h>
+#include <kiconloader.h>
+#include <kstandarddirs.h>
+#include <kapplication.h>
+#include <kprocess.h>
+#include <klocale.h>
+#include <kpopupmenu.h>
+#include <kstringhandler.h>
+#include <kfiledialog.h>
+#include <kfontrequester.h>
+#include <kglobalsettings.h>
+#include <kconfigdialogmanager.h>
+#include <kcalendarsystem.h>
+#include <kicontheme.h>
+#include <kiconloader.h>
+
+#include <global.h> // libkickermain
+
+#include "clock.h"
+#include "datepicker.h"
+#include "zone.h"
+#include "analog.h"
+#include "digital.h"
+#include "fuzzy.h"
+#include "prefs.h"
+
+extern "C"
+{
+    KDE_EXPORT KPanelApplet* init(QWidget *parent, const QString& configFile)
+    {
+        KGlobal::locale()->insertCatalogue("clockapplet");
+        KGlobal::locale()->insertCatalogue("timezones"); // For time zone translations
+        return new ClockApplet(configFile, KPanelApplet::Normal,
+                               KPanelApplet::Preferences, parent, "clockapplet");
+    }
+}
+
+// Settings
+
+KConfigDialogSingle::KConfigDialogSingle(Zone *zone, QWidget *parent,
+                                         const char *name, Prefs * prefs,
+                                         KDialogBase::DialogType dialogType,
+                                         bool modal) :
+    KConfigDialog(parent, name, prefs, dialogType,
+                  KDialogBase::Default | KDialogBase::Ok |
+                  KDialogBase::Apply | KDialogBase::Cancel,
+                  KDialogBase::Ok,
+                  modal), _prefs(prefs)
+{
+    // As a temporary mesure until the kicker applet's app name is set to the
+    // applets name so KDialogBase gets the right info.
+    setPlainCaption(i18n("Configure - Clock"));
+    setIcon(SmallIcon("date"));
+
+    settings = new SettingsWidgetImp(prefs, zone, 0, "General");
+    connect(settings->kcfg_Type, SIGNAL(activated(int)), SLOT(selectPage(int)));
+
+    settings->kcfg_PlainBackgroundColor->setDefaultColor(KApplication::palette().active().background());
+    settings->kcfg_DateBackgroundColor->setDefaultColor(KApplication::palette().active().background());
+
+    // Digital
+    digitalPage = new DigitalWidget(0, "DigitalClock");
+    settings->widgetStack->addWidget(digitalPage, 1);
+    digitalPage->kcfg_DigitalBackgroundColor->setDefaultColor(KApplication::palette().active().background());
+
+    // Analog
+    analogPage = new AnalogWidget(0, "AnalogClock");
+    settings->widgetStack->addWidget(analogPage, 2);
+    analogPage->kcfg_AnalogBackgroundColor->setDefaultColor(KApplication::palette().active().background());
+
+    // Fuzzy
+    fuzzyPage = new FuzzyWidget(0, "FuzzyClock");
+    settings->widgetStack->addWidget(fuzzyPage, 3);
+    fuzzyPage->kcfg_FuzzyBackgroundColor->setDefaultColor(KApplication::palette().active().background());
+
+    connect(settings->kcfg_PlainShowDate, SIGNAL(toggled(bool)),
+            SLOT(dateToggled()));
+    connect(settings->kcfg_PlainShowDayOfWeek, SIGNAL(toggled(bool)),
+            SLOT(dateToggled()));
+    connect(digitalPage->kcfg_DigitalShowDate, SIGNAL(toggled(bool)),
+            SLOT(dateToggled()));
+    connect(digitalPage->kcfg_DigitalShowDayOfWeek, SIGNAL(toggled(bool)),
+            SLOT(dateToggled()));
+    connect(digitalPage->kcfg_DigitalShowDate, SIGNAL(toggled(bool)),
+            SLOT(dateToggled()));
+    connect(analogPage->kcfg_AnalogShowDate, SIGNAL(toggled(bool)),
+            SLOT(dateToggled()));
+    connect(analogPage->kcfg_AnalogShowDayOfWeek, SIGNAL(toggled(bool)),
+            SLOT(dateToggled()));
+    connect(fuzzyPage->kcfg_FuzzyShowDate, SIGNAL(toggled(bool)),
+            SLOT(dateToggled()));
+    connect(fuzzyPage->kcfg_FuzzyShowDayOfWeek, SIGNAL(toggled(bool)),
+            SLOT(dateToggled()));
+
+    addPage(settings, i18n("General"), QString::fromLatin1("package_settings"));
+}
+
+void KConfigDialogSingle::updateSettings()
+{
+    settings->OkApply();
+}
+
+void KConfigDialogSingle::updateWidgets()
+{
+    selectPage( _prefs->type() );
+}
+
+void KConfigDialogSingle::updateWidgetsDefault()
+{
+    KConfigSkeletonItem *item = _prefs->findItem("Type");
+    item->swapDefault();
+    selectPage( _prefs->type() );
+    item->swapDefault();
+    // This is ugly, but kcfg_Type does not have its correct setting
+    // at this point in time.
+    QTimer::singleShot(0, this, SLOT(dateToggled()));
+}
+
+void KConfigDialogSingle::selectPage(int p)
+{
+    settings->widgetStack->raiseWidget( p );
+    dateToggled();
+}
+
+void KConfigDialogSingle::dateToggled()
+{
+    bool showDate;
+    switch( settings->kcfg_Type->currentItem() )
+    {
+      case Prefs::EnumType::Plain:
+         showDate = settings->kcfg_PlainShowDate->isChecked() ||
+                    settings->kcfg_PlainShowDayOfWeek->isChecked();
+         break;
+      case Prefs::EnumType::Digital:
+         showDate = digitalPage->kcfg_DigitalShowDate->isChecked() ||
+                    digitalPage->kcfg_DigitalShowDayOfWeek->isChecked();
+         break;
+      case Prefs::EnumType::Analog:
+         showDate = analogPage->kcfg_AnalogShowDate->isChecked() ||
+                    analogPage->kcfg_AnalogShowDayOfWeek->isChecked();
+         break;
+      case Prefs::EnumType::Fuzzy:
+      default:
+         showDate = fuzzyPage->kcfg_FuzzyShowDate->isChecked() ||
+                    fuzzyPage->kcfg_FuzzyShowDayOfWeek->isChecked();
+         break;
+    }
+    settings->dateBox->setEnabled(showDate);
+}
+
+SettingsWidgetImp::SettingsWidgetImp(Prefs *p, Zone *z, QWidget* parent, const char* name, WFlags fl) :
+    SettingsWidget(parent, name, fl), prefs(p), zone(z)
+{
+    zone->readZoneList(tzListView);
+}
+
+void SettingsWidgetImp::OkApply()
+{
+    zone->getSelectedZonelist(tzListView);
+    zone->writeSettings();
+}
+
+//************************************************************
+
+
+ClockWidget::ClockWidget(ClockApplet *applet, Prefs* prefs)
+    : _applet(applet), _prefs(prefs), _force(false)
+{}
+
+
+ClockWidget::~ClockWidget()
+{}
+
+
+//************************************************************
+
+
+PlainClock::PlainClock(ClockApplet *applet, Prefs *prefs, QWidget *parent, const char *name)
+    : QLabel(parent, name), ClockWidget(applet, prefs)
+{
+    setBackgroundOrigin(AncestorOrigin);
+    loadSettings();
+    updateClock();
+}
+
+
+int PlainClock::preferedWidthForHeight(int ) const
+{
+    QString maxLengthTime = KGlobal::locale()->formatTime( QTime( 23, 59 ), _prefs->plainShowSeconds());
+    return fontMetrics().width( maxLengthTime+2 );
+}
+
+
+int PlainClock::preferedHeightForWidth(int /*w*/) const
+{
+    return fontMetrics().lineSpacing();
+}
+
+
+void PlainClock::updateClock()
+{
+    QString newStr = KGlobal::locale()->formatTime(_applet->clockGetTime(), _prefs->plainShowSeconds());
+
+    if (_force || newStr != _timeStr) {
+        _timeStr = newStr;
+        setText(_timeStr);
+    }
+}
+
+void PlainClock::loadSettings()
+{
+    setFrameStyle(_prefs->plainShowFrame() ? Panel | Sunken : NoFrame);
+    setAlignment(AlignVCenter | AlignHCenter | SingleLine);
+
+    setFont(_prefs->plainFont());
+}
+
+bool PlainClock::showDate()
+{
+    return _prefs->plainShowDate();
+}
+
+bool PlainClock::showDayOfWeek()
+{
+    return _prefs->plainShowDayOfWeek();
+}
+
+//************************************************************
+
+
+DigitalClock::DigitalClock(ClockApplet *applet, Prefs *prefs, QWidget *parent, const char *name)
+    : QLCDNumber(parent, name), ClockWidget(applet, prefs)
+{
+    setWFlags(WNoAutoErase);
+    setBackgroundOrigin(AncestorOrigin);
+    loadSettings();
+    updateClock();
+}
+
+
+DigitalClock::~DigitalClock()
+{
+    delete _buffer;
+}
+
+
+int DigitalClock::preferedWidthForHeight(int h) const
+{
+    if (h > 29) h = 29;
+    if (h < 0) h = 0;
+    return (numDigits()*h*5/11)+2;
+}
+
+
+int DigitalClock::preferedHeightForWidth(int w) const
+{
+    if (w < 0) w = 0;
+    return((w / numDigits() * 2) + 6);
+}
+
+
+void DigitalClock::updateClock()
+{
+    static bool colon = true;
+    QString newStr;
+    QTime t(_applet->clockGetTime());
+
+    int h = t.hour();
+    int m = t.minute();
+    int s = t.second();
+
+    QString format("%02d");
+
+    QString sep(!colon && _prefs->digitalBlink() ? " " : ":");
+
+    if (_prefs->digitalShowSeconds())
+        format += sep + "%02d";
+
+    if (KGlobal::locale()->use12Clock()) {
+        if (h > 12)
+            h -= 12;
+        else if( h == 0)
+            h = 12;
+
+        format.prepend("%2d" + sep);
+    } else
+        format.prepend("%02d" + sep);
+
+
+    if (_prefs->digitalShowSeconds())
+        newStr.sprintf(format.latin1(), h, m, s);
+    else
+        newStr.sprintf(format.latin1(), h, m);
+
+    if (_force || newStr != _timeStr)
+    {
+        _timeStr = newStr;
+        setUpdatesEnabled( FALSE );
+        display(_timeStr);
+        setUpdatesEnabled( TRUE );
+        update();
+    }
+    
+    if (_prefs->digitalBlink())
+        colon = !colon;
+}
+
+void DigitalClock::loadSettings()
+{
+    setFrameStyle(_prefs->digitalShowFrame() ? Panel | Sunken : NoFrame);
+    setMargin( 4 );
+    setSegmentStyle(QLCDNumber::Flat);
+
+    if (_prefs->digitalLCDStyle())
+        lcdPattern = KIconLoader("clockapplet").loadIcon("lcd", KIcon::User);
+
+    setNumDigits(_prefs->digitalShowSeconds() ? 8:5);
+
+    _buffer = new QPixmap(width(), height());
+}
+
+void DigitalClock::paintEvent(QPaintEvent*)
+{
+    QPainter p(_buffer);
+
+    if (_prefs->digitalLCDStyle())
+    {
+        p.drawTiledPixmap(0, 0, width(), height(), lcdPattern);
+    }
+    else if (_prefs->digitalBackgroundColor() !=
+             KApplication::palette().active().background())
+    {
+        p.fillRect(0, 0, width(), height(), _prefs->digitalBackgroundColor());
+    }
+    else if (paletteBackgroundPixmap())
+    {
+        QPoint offset = backgroundOffset();
+        p.drawTiledPixmap(0, 0, width(), height(), *paletteBackgroundPixmap(), offset.x(), offset.y());
+    }
+    else
+    {
+        p.fillRect(0, 0, width(), height(), _prefs->digitalBackgroundColor());
+    }
+
+    drawContents(&p);
+    if (_prefs->digitalShowFrame())
+    {
+        drawFrame(&p);
+    }
+
+    p.end();
+    bitBlt(this, 0, 0, _buffer, 0, 0);
+}
+
+
+// yes, the colors for the lcd-lock are hardcoded,
+// but other colors would break the lcd-lock anyway
+void DigitalClock::drawContents( QPainter * p)
+{
+    setUpdatesEnabled( FALSE );
+    QPalette pal = palette();
+    if (_prefs->digitalLCDStyle())
+        pal.setColor( QColorGroup::Foreground, QColor(128,128,128));
+    else
+        pal.setColor( QColorGroup::Foreground, _prefs->digitalShadowColor());
+    setPalette( pal );
+    p->translate( +1, +1 );
+    QLCDNumber::drawContents( p );
+    if (_prefs->digitalLCDStyle())
+        pal.setColor( QColorGroup::Foreground, Qt::black);
+    else
+        pal.setColor( QColorGroup::Foreground, _prefs->digitalForegroundColor());
+    setPalette( pal );
+    p->translate( -2, -2 );
+    setUpdatesEnabled( TRUE );
+    QLCDNumber::drawContents( p );
+    p->translate( +1, +1 );
+}
+
+
+// reallocate buffer pixmap
+void DigitalClock::resizeEvent ( QResizeEvent *)
+{
+    delete _buffer;
+    _buffer = new QPixmap( width(), height() );
+}
+
+
+bool DigitalClock::showDate()
+{
+    return _prefs->digitalShowDate();
+}
+
+bool DigitalClock::showDayOfWeek()
+{
+    return _prefs->digitalShowDayOfWeek();
+}
+
+
+//************************************************************
+
+
+AnalogClock::AnalogClock(ClockApplet *applet, Prefs *prefs, QWidget *parent, const char *name)
+    : QFrame(parent, name), ClockWidget(applet, prefs), _spPx(NULL)
+{
+    setWFlags(WNoAutoErase);
+    setBackgroundOrigin(AncestorOrigin);
+    loadSettings();
+}
+
+
+AnalogClock::~AnalogClock()
+{
+    delete _spPx;
+}
+
+void AnalogClock::initBackgroundPixmap()
+{
+    //if no antialiasing, use pixmap as-is
+    if (_prefs->analogAntialias() == 0)
+    {
+      lcdPattern = KIconLoader("clockapplet").loadIcon("lcd",KIcon::User);
+      _bgScale = 1;
+    }
+    else
+    {
+        //make a scaled pixmap -- so when image is reduced it'll look "OK".
+        _bgScale = _prefs->analogAntialias()+1;
+        QImage bgImage = KIconLoader("clockapplet").loadIcon("lcd", KIcon::User).convertToImage();
+        lcdPattern = QPixmap(bgImage.scale(bgImage.width() * _bgScale,
+                             bgImage.height() * _bgScale));
+
+    }
+}
+
+void AnalogClock::updateClock()
+{
+    if (!_force)
+    {
+        if (!_prefs->analogShowSeconds() && (_time.minute() == _applet->clockGetTime().minute()))
+            return;
+    }
+    
+    _time = _applet->clockGetTime();
+    update();
+}
+
+void AnalogClock::loadSettings()
+{
+    if (_prefs->analogLCDStyle())
+    {
+        initBackgroundPixmap();
+    }
+/*  this may prevent flicker, but it also prevents transparency
+    else
+    {
+        setBackgroundMode(NoBackground);
+    }*/
+
+    setFrameStyle(_prefs->analogShowFrame() ? Panel | Sunken : NoFrame);
+    _time = _applet->clockGetTime();
+    _spPx = new QPixmap(size().width() * _prefs->analogAntialias()+1,
+                        size().height() * _prefs->analogAntialias()+1);
+
+    update();
+}
+
+void AnalogClock::paintEvent( QPaintEvent * )
+{
+    if ( !isVisible() )
+        return;
+
+    int aaFactor = _prefs->analogAntialias()+1;
+    int spWidth = size().width() * aaFactor;
+    int spHeight = size().height() * aaFactor;
+
+    if ((spWidth != _spPx->size().width()) ||
+        (spHeight != _spPx->size().height()))
+    {
+        delete _spPx;
+        _spPx = new QPixmap(spWidth, spHeight);
+    }
+
+    QPainter paint;
+    paint.begin(_spPx);
+
+    if (_prefs->analogLCDStyle())
+    {
+        if (_bgScale != aaFactor)
+        {
+            //check to see if antialiasing has changed -- bg pixmap will need
+            //to be re-created
+            initBackgroundPixmap();
+        }
+
+        paint.drawTiledPixmap(0, 0, spWidth, spHeight, lcdPattern);
+    }
+    else if (_prefs->analogBackgroundColor() != KApplication::palette().active().background())
+    {
+        _spPx->fill(_prefs->analogBackgroundColor());
+    }
+    else if (paletteBackgroundPixmap())
+    {
+        QPixmap bg(width(), height());
+        QPainter p(&bg);
+        QPoint offset = backgroundOffset();
+        p.drawTiledPixmap(0, 0, width(), height(), *paletteBackgroundPixmap(), offset.x(), offset.y());
+        p.end();
+        QImage bgImage = bg.convertToImage().scale(spWidth, spHeight);
+        paint.drawImage(0, 0, bgImage);
+    }
+    else
+    {
+       _spPx->fill(_prefs->analogBackgroundColor());
+    }
+
+    QPointArray pts;
+    QPoint cp(spWidth / 2, spHeight / 2);
+
+    int d = KMIN(spWidth,spHeight) - (10 * aaFactor);
+
+    if (_prefs->analogLCDStyle()) 
+    {
+        paint.setPen( QPen(QColor(100,100,100), aaFactor) );
+        paint.setBrush( QColor(100,100,100) );
+    }
+    else
+    {
+        paint.setPen( QPen(_prefs->analogShadowColor(), aaFactor) );
+        paint.setBrush( _prefs->analogShadowColor() );
+    }
+
+    paint.setViewport(2,2,spWidth,spHeight);
+
+    for ( int c=0 ; c < 2 ; c++ ) {
+        QWMatrix matrix;
+        matrix.translate( cp.x(), cp.y());
+        matrix.scale( d/1000.0F, d/1000.0F );
+
+        // hour
+        float h_angle = 30*(_time.hour()%12-3) + _time.minute()/2;
+        matrix.rotate( h_angle );
+        paint.setWorldMatrix( matrix );
+        pts.setPoints( 4, -20,0,  0,-20, 300,0, 0,20 );
+        paint.drawPolygon( pts );
+        matrix.rotate( -h_angle );
+
+        // minute
+        float m_angle = (_time.minute()-15)*6;
+        matrix.rotate( m_angle );
+        paint.setWorldMatrix( matrix );
+        pts.setPoints( 4, -10,0, 0,-10, 400,0, 0,10 );
+        paint.drawPolygon( pts );
+        matrix.rotate( -m_angle );
+
+        if (_prefs->analogShowSeconds()) {   // second
+            float s_angle = (_time.second()-15)*6;
+            matrix.rotate( s_angle );
+            paint.setWorldMatrix( matrix );
+            pts.setPoints(4,0,0,0,0,400,0,0,0);
+            paint.drawPolygon( pts );
+            matrix.rotate( -s_angle );
+        }
+
+        QWMatrix matrix2;
+        matrix2.translate( cp.x(), cp.y());
+        matrix2.scale( d/1000.0F, d/1000.0F );
+
+        // quadrante
+        for ( int i=0 ; i < 12 ; i++ ) {
+            paint.setWorldMatrix( matrix2 );
+            paint.drawLine( 460,0, 500,0 ); // draw hour lines
+            // paint.drawEllipse( 450, -15, 30, 30 );
+            matrix2.rotate( 30 );
+        }
+
+        if (_prefs->analogLCDStyle()) {
+            paint.setPen( QPen(Qt::black, aaFactor) );
+            paint.setBrush( Qt::black );
+        } else {
+            paint.setPen( QPen(_prefs->analogForegroundColor(), aaFactor) );
+            paint.setBrush( _prefs->analogForegroundColor() );
+        }
+
+        paint.setViewport(0,0,spWidth,spHeight);
+    }
+    paint.end();
+
+    QPainter paintFinal;
+    paintFinal.begin(this);
+
+    if (aaFactor != 1)
+    {
+        QImage spImage = _spPx->convertToImage();
+        QImage displayImage = spImage.smoothScale(size());
+
+        paintFinal.drawImage(0, 0, displayImage);
+    }
+    else
+    {
+        paintFinal.drawPixmap(0, 0, *_spPx);
+    }
+
+    if (_prefs->analogShowFrame())
+    {
+        drawFrame(&paintFinal);
+    }
+}
+
+
+// the background pixmap disappears during a style change
+void AnalogClock::styleChange(QStyle &)
+{
+    if (_prefs->analogLCDStyle())
+    {
+       initBackgroundPixmap();
+    }
+}
+
+bool AnalogClock::showDate()
+{
+    return _prefs->analogShowDate();
+}
+
+bool AnalogClock::showDayOfWeek()
+{
+    return _prefs->analogShowDayOfWeek();
+}
+
+
+//************************************************************
+
+
+FuzzyClock::FuzzyClock(ClockApplet *applet, Prefs *prefs, QWidget *parent, const char *name)
+    : QFrame(parent, name), ClockWidget(applet, prefs)
+{
+    setBackgroundOrigin(AncestorOrigin);
+    loadSettings();
+    hourNames   << i18n("hour","one") << i18n("hour","two")
+                << i18n("hour","three") << i18n("hour","four") << i18n("hour","five")
+                << i18n("hour","six") << i18n("hour","seven") << i18n("hour","eight")
+                << i18n("hour","nine") << i18n("hour","ten") << i18n("hour","eleven")
+                << i18n("hour","twelve");
+
+    // xgettext:no-c-format
+    normalFuzzy << i18n("%0 o'clock") // xgettext:no-c-format
+                << i18n("five past %0") // xgettext:no-c-format
+                << i18n("ten past %0") // xgettext:no-c-format
+                << i18n("quarter past %0") // xgettext:no-c-format
+                << i18n("twenty past %0") // xgettext:no-c-format
+                << i18n("twenty five past %0") // xgettext:no-c-format
+                << i18n("half past %0") // xgettext:no-c-format
+                << i18n("twenty five to %1") // xgettext:no-c-format
+                << i18n("twenty to %1") // xgettext:no-c-format
+                << i18n("quarter to %1") // xgettext:no-c-format
+                << i18n("ten to %1") // xgettext:no-c-format
+                << i18n("five to %1") // xgettext:no-c-format
+                << i18n("%1 o'clock");
+
+    // xgettext:no-c-format
+    normalFuzzyOne << i18n("one","%0 o'clock") // xgettext:no-c-format
+                   << i18n("one","five past %0") // xgettext:no-c-format
+                   << i18n("one","ten past %0") // xgettext:no-c-format
+                   << i18n("one","quarter past %0") // xgettext:no-c-format
+                   << i18n("one","twenty past %0") // xgettext:no-c-format
+                   << i18n("one","twenty five past %0") // xgettext:no-c-format
+                   << i18n("one","half past %0") // xgettext:no-c-format
+                   << i18n("one","twenty five to %1") // xgettext:no-c-format
+                   << i18n("one","twenty to %1") // xgettext:no-c-format
+                   << i18n("one","quarter to %1") // xgettext:no-c-format
+                   << i18n("one","ten to %1") // xgettext:no-c-format
+                   << i18n("one","five to %1") // xgettext:no-c-format
+                   << i18n("one","%1 o'clock");
+
+    dayTime << i18n("Night")
+            << i18n("Early morning") << i18n("Morning") << i18n("Almost noon")
+            << i18n("Noon") << i18n("Afternoon") << i18n("Evening")
+            << i18n("Late evening");
+
+    _time = _applet->clockGetTime();
+    alreadyDrawing=false;
+    update();
+}
+
+void FuzzyClock::deleteMyself()
+{
+    if(alreadyDrawing) // try again later
+        QTimer::singleShot(1000, this, SLOT(deleteMyself()));
+    else
+        delete this;
+}
+
+
+int FuzzyClock::preferedWidthForHeight(int ) const
+{
+    QFontMetrics fm(_prefs->fuzzyFont());
+    return fm.width(_timeStr) + 8;
+}
+
+
+int FuzzyClock::preferedHeightForWidth(int ) const
+{
+    QFontMetrics fm(_prefs->fuzzyFont());
+    return fm.width(_timeStr) + 8;
+}
+
+
+void FuzzyClock::updateClock()
+{
+    if (!_force)
+    {
+        if (_time.hour() == _applet->clockGetTime().hour() &&
+            _time.minute() == _applet->clockGetTime().minute())
+        return;
+    }
+
+    _time = _applet->clockGetTime();
+    update();
+}
+
+void FuzzyClock::loadSettings()
+{
+    setFrameStyle(_prefs->fuzzyShowFrame() ? Panel | Sunken : 0);
+}
+
+void FuzzyClock::drawContents(QPainter *p)
+{
+    if (!isVisible())
+        return;
+
+    if(!_applet)
+        return;
+
+    alreadyDrawing = true;
+    QString newTimeStr;
+
+    if (_prefs->fuzzyness() == 1 || _prefs->fuzzyness() == 2) {
+      int minute = _time.minute();
+      int sector = 0;
+      int realHour = 0;
+
+      if (_prefs->fuzzyness() == 1) {
+          if (minute > 2)
+              sector = (minute - 3) / 5 + 1;
+      } else {
+          if (minute > 6)
+              sector = ((minute - 7) / 15 + 1) * 3;
+      }
+
+      newTimeStr = normalFuzzy[sector];
+      int phStart = newTimeStr.find("%");
+      if (phStart >= 0) { // protect yourself from translations
+          int phLength = newTimeStr.find(" ", phStart) - phStart;
+
+          // larrosa: we want the exact length, in case the translation needs it,
+          // in other case, we would cut off the end of the translation.
+          if (phLength < 0) phLength = newTimeStr.length() - phStart;
+          int deltaHour = newTimeStr.mid(phStart + 1, phLength - 1).toInt();
+
+          if ((_time.hour() + deltaHour) % 12 > 0)
+              realHour = (_time.hour() + deltaHour) % 12 - 1;
+          else
+              realHour = 12 - ((_time.hour() + deltaHour) % 12 + 1);
+          if (realHour==0) {
+              newTimeStr = normalFuzzyOne[sector];
+              phStart = newTimeStr.find("%");
+              // larrosa: Note that length is the same,
+              // so we only have to update phStart
+          }
+          if (phStart >= 0)
+              newTimeStr.replace(phStart, phLength, hourNames[realHour]);
+          newTimeStr.replace(0, 1, QString(newTimeStr.at(0).upper()));
+      }
+    } else if (_prefs->fuzzyness() == 3) {
+        newTimeStr = dayTime[_time.hour() / 3];
+    } else {
+        int dow = _applet->clockGetDate().dayOfWeek();
+
+        if (dow == 1)
+            newTimeStr = i18n("Start of week");
+        else if (dow >= 2 && dow <= 4)
+            newTimeStr = i18n("Middle of week");
+        else if (dow == 5)
+            newTimeStr = i18n("End of week");
+        else
+            newTimeStr = i18n("Weekend!");
+    }
+
+    if (_timeStr != newTimeStr) {
+        _timeStr = newTimeStr;
+        _applet->resizeRequest();
+    }
+
+    p->setFont(_prefs->fuzzyFont());
+    p->setPen(_prefs->fuzzyForegroundColor());
+    if (_applet->getOrientation() == Vertical) {
+        p->rotate(90);
+        p->drawText(4, -2, height() - 8, -(width()) + 2, AlignCenter, _timeStr);
+    } else {
+        p->drawText(4, 2, width() - 8, height() - 4, AlignCenter, _timeStr);
+    }
+    alreadyDrawing = false;
+}
+
+bool FuzzyClock::showDate()
+{
+    return _prefs->fuzzyShowDate();
+}
+
+bool FuzzyClock::showDayOfWeek()
+{
+    return _prefs->fuzzyShowDayOfWeek();
+}
+
+
+//************************************************************
+
+
+ClockApplet::ClockApplet(const QString& configFile, Type t, int actions,
+                         QWidget *parent, const char *name)
+    : KPanelApplet(configFile, t, actions, parent, name),
+      _calendar(0),
+      _disableCalendar(false),
+      _clock(0),
+      _timer(new QTimer(this)),
+      m_layoutTimer(new QTimer(this)),
+      m_layoutDelay(0),
+      m_followBackgroundSetting(true),
+      m_dateFollowBackgroundSetting(true),
+      TZoffset(0),
+      _prefs(new Prefs(sharedConfig())),
+      zone(new Zone(config())),
+      menu(0),
+      m_tooltip(this)
+{
+    DCOPObject::setObjId("ClockApplet");
+    _prefs->readConfig();
+    configFileName = configFile.latin1();
+    setBackgroundOrigin(AncestorOrigin);
+
+    _dayOfWeek = new QLabel(this);
+    _dayOfWeek->setAlignment(AlignVCenter | AlignHCenter | WordBreak);
+    _dayOfWeek->setBackgroundOrigin(AncestorOrigin);
+    _dayOfWeek->installEventFilter(this);   // catch mouse clicks
+
+    _date = new QLabel(this);
+    _date->setAlignment(AlignVCenter | AlignHCenter | WordBreak);
+    _date->setBackgroundOrigin(AncestorOrigin);
+    _date->installEventFilter(this);   // catch mouse clicks
+
+    connect(m_layoutTimer, SIGNAL(timeout()), this, SLOT(fixupLayout()));
+    connect(_timer, SIGNAL(timeout()), SLOT(slotUpdate()));
+    connect(kapp, SIGNAL(kdisplayPaletteChanged()), SLOT(globalPaletteChange()));
+
+    reconfigure();    // initialize clock widget
+    slotUpdate();
+
+    if (kapp->authorizeKAction("kicker_rmb"))
+    {
+        menu = new KPopupMenu();
+        connect(menu, SIGNAL(aboutToShow()), SLOT(aboutToShowContextMenu()));
+        connect(menu, SIGNAL(activated(int)), SLOT(contextMenuActivated(int)));
+        setCustomMenu(menu);
+    }
+
+    installEventFilter(KickerTip::the());
+}
+
+
+ClockApplet::~ClockApplet()
+{
+    //reverse for the moment
+    KGlobal::locale()->removeCatalogue("clockapplet");
+    KGlobal::locale()->removeCatalogue("timezones"); // For time zone translations
+
+    if (_calendar)
+    {
+        // we have to take care of the calendar closing first before deleting
+        // the prefs
+        _calendar->close();
+    }
+
+    zone->writeSettings();
+
+    delete _prefs; _prefs = 0;
+    delete zone; zone = 0;
+    delete menu; menu = 0;
+    config()->sync();
+}
+
+int ClockApplet::widthForHeight(int h) const
+{
+    if (orientation() == Qt::Vertical)
+    {
+        return width();
+    }
+
+    int shareDateHeight = 0, shareDayOfWeekHeight = 0;
+    bool dateToSide = (h < 32);
+    bool mustShowDate = showDate || (zone->zoneIndex() != 0);
+    if (mustShowDate)
+    {
+        _date->setAlignment(AlignVCenter | AlignHCenter);
+        if (!dateToSide)
+        {
+            shareDateHeight = _date->sizeHint().height();
+        }
+    }
+    if (showDayOfWeek)
+    {
+        _dayOfWeek->setAlignment(AlignVCenter | AlignHCenter);
+        if (!dateToSide)
+        {
+            shareDayOfWeekHeight = _dayOfWeek->sizeHint().height();
+        }
+    }
+
+    int clockWidth = _clock->preferedWidthForHeight(KMAX(0, h - shareDateHeight - shareDayOfWeekHeight));
+    int w = clockWidth;
+    if (!mustShowDate && !showDayOfWeek)
+    {
+        // resize the date widgets in case the are to the left of the clock
+        _clock->widget()->setFixedSize(w, h);
+        _clock->widget()->move(0,0);
+        _dayOfWeek->move(clockWidth + 4, 0);
+        _date->move(clockWidth + 4, 0);
+    }
+    else
+    {
+        int dateWidth = mustShowDate ? _date->sizeHint().width() + 4 : 0;
+        int dayOfWeekWidth = showDayOfWeek ? _dayOfWeek->sizeHint().width() + 4 : 0;
+
+        if (dateToSide)
+        {
+            w += dateWidth + dayOfWeekWidth;
+            bool dateFirst = false;
+
+            if (mustShowDate)
+            {
+                // if the date format STARTS with a year, assume it's in descending
+                // order and should therefore PRECEED the date.
+                QString dateFormat = KGlobal::locale()->dateFormatShort();
+                dateFirst = dateFormat.at(1) == 'y' || dateFormat.at(1) == 'Y';
+            }
+
+            if (dateFirst)
+            {
+                _date->setFixedSize(dateWidth, h);
+                _date->move(0, 0);
+
+                if (showDayOfWeek)
+                {
+                    _dayOfWeek->setFixedSize(dayOfWeekWidth, h);
+                    _dayOfWeek->move(dateWidth, 0);
+                }
+
+                _clock->widget()->setFixedSize(clockWidth, h);
+                _clock->widget()->move(dateWidth + dayOfWeekWidth, 0);
+            }
+            else
+            {
+                _clock->widget()->setFixedSize(clockWidth, h);
+                _clock->widget()->move(0,0);
+
+                if (showDayOfWeek)
+                {
+                    _dayOfWeek->setFixedSize(dayOfWeekWidth, h);
+                    _dayOfWeek->move(clockWidth, 0);
+                }
+
+                if (mustShowDate)
+                {
+                    _date->setFixedSize(dateWidth, h);
+                    _date->move(clockWidth + dayOfWeekWidth, 0);
+                }
+            }
+        }
+        else
+        {
+            w = KMAX(KMAX(w, dateWidth), dayOfWeekWidth);
+
+            _clock->widget()->setFixedSize(w, h - shareDateHeight - shareDayOfWeekHeight);
+            _clock->widget()->setMinimumSize(w, h - shareDateHeight - shareDayOfWeekHeight);
+            _clock->widget()->move(0, 0);
+            if (showDayOfWeek)
+            {
+                _dayOfWeek->setFixedSize(w, _dayOfWeek->sizeHint().height());
+                _dayOfWeek->move(0, _clock->widget()->height());
+            }
+
+            if (mustShowDate)
+            {
+                _date->setFixedSize(w, _date->sizeHint().height());
+                _date->move(0, _clock->widget()->height() + shareDayOfWeekHeight);
+            }
+        }
+    }
+
+    return w;
+}
+
+int ClockApplet::heightForWidth(int w) const
+{
+    if (orientation() == Qt::Horizontal)
+    {
+        return height();
+    }
+
+    int clockHeight = _clock->preferedHeightForWidth(w);
+    bool mustShowDate = showDate || (zone->zoneIndex() != 0);
+
+    _clock->widget()->setFixedSize(w, clockHeight);
+
+    // add 4 pixels in height for each of date+dayOfWeek, if visible
+    if (showDayOfWeek)
+    {
+        if (_dayOfWeek->minimumSizeHint().width() > w)
+        {
+            _dayOfWeek->setAlignment(AlignVCenter | WordBreak);
+        }
+        else
+        {
+            _dayOfWeek->setAlignment(AlignVCenter | AlignHCenter | WordBreak);
+        }
+
+        _dayOfWeek->setFixedSize(w, _dayOfWeek->minimumSizeHint().height());
+        _dayOfWeek->move(0, clockHeight);
+
+        clockHeight += _dayOfWeek->height();
+    }
+
+    if (mustShowDate)
+    {
+        // yes, the const_cast is ugly, but this is to ensure that we
+        // get a proper date label in the case that we munged it for
+        // display on panel that is too narrow and then they made it wider
+        const_cast<ClockApplet*>(this)->updateDateLabel(false);
+
+        if (_date->minimumSizeHint().width() > w)
+        {
+            QString dateStr = _date->text();
+            // if we're too wide to fit, replace the first non-digit from the end with a space
+            int p = dateStr.findRev(QRegExp("[^0-9]"));
+            if (p > 0)
+            {
+                _date->setText(dateStr.insert(p, '\n'));
+            }
+        }
+
+        if (_date->minimumSizeHint().width() > w)
+        {
+            _date->setAlignment(AlignVCenter | WordBreak);
+        }
+        else
+        {
+            _date->setAlignment(AlignVCenter | AlignHCenter | WordBreak);
+        }
+        _date->setFixedSize(w, _date->heightForWidth(w));
+        _date->move(0, clockHeight);
+
+        clockHeight += _date->height();
+    }
+
+    return clockHeight;
+}
+
+void ClockApplet::preferences()
+{
+    preferences(false);
+}
+
+void ClockApplet::preferences(bool timezone)
+{
+  KConfigDialogSingle *dialog = dynamic_cast<KConfigDialogSingle*>(KConfigDialog::exists(configFileName));
+
+  if (!dialog)
+  {
+    dialog = new KConfigDialogSingle(zone, this, configFileName, _prefs, KDialogBase::Swallow);
+    connect(dialog, SIGNAL(settingsChanged()), this, SLOT(slotReconfigure()));
+  }
+
+  if (timezone)
+  {
+      dialog->settings->tabs->setCurrentPage(1);
+  }
+
+  dialog->show();
+}
+
+void ClockApplet::updateFollowBackground()
+{
+    QColor globalBgroundColor = KApplication::palette().active().background();
+    QColor bgColor;
+    
+    switch (_prefs->type())
+    {
+        case Prefs::EnumType::Plain:
+            bgColor = _prefs->plainBackgroundColor();
+            break;
+        case Prefs::EnumType::Analog:
+            bgColor = _prefs->analogBackgroundColor();
+            break;
+        case Prefs::EnumType::Fuzzy:
+            bgColor = _prefs->fuzzyBackgroundColor();
+            break;
+        case Prefs::EnumType::Digital:
+        default:
+            bgColor = _prefs->digitalBackgroundColor();
+            break;
+    }
+    
+    m_followBackgroundSetting = (bgColor == globalBgroundColor);
+    
+    bgColor = _prefs->dateBackgroundColor();
+    m_dateFollowBackgroundSetting = (bgColor == globalBgroundColor);
+}
+
+// DCOP interface
+void ClockApplet::reconfigure()
+{
+    _timer->stop();
+
+    // ugly workaround for FuzzyClock: sometimes FuzzyClock
+    // hasn't finished drawing when getting deleted, so we
+    // ask FuzzyClock to delete itself appropriately
+    if (_clock && _clock->widget()->inherits("FuzzyClock"))
+    {
+        FuzzyClock* f = static_cast<FuzzyClock*>(_clock);
+        f->deleteMyself();
+    }
+    else
+    {
+        delete _clock;
+    }
+
+    int shortInterval = 500;
+    int updateInterval = 0;
+    
+    switch (_prefs->type())
+    {
+        case Prefs::EnumType::Plain:
+            _clock = new PlainClock(this, _prefs, this);
+            if (_prefs->plainShowSeconds())
+                updateInterval = shortInterval;
+            break;
+        case Prefs::EnumType::Analog:
+            _clock = new AnalogClock(this, _prefs, this);
+            if (_prefs->analogShowSeconds())
+                updateInterval = shortInterval;
+            break;
+        case Prefs::EnumType::Fuzzy:
+            _clock = new FuzzyClock(this, _prefs, this);
+            break;
+        case Prefs::EnumType::Digital:
+        default:
+            _clock = new DigitalClock(this, _prefs, this);
+            if (_prefs->digitalShowSeconds() || _prefs->digitalBlink())
+                updateInterval = shortInterval;
+            break;
+    }
+
+    m_updateOnTheMinute = updateInterval != shortInterval;
+    if (m_updateOnTheMinute)
+    {
+        connect(_timer, SIGNAL(timeout()), this, SLOT(setTimerTo60()));
+        updateInterval = ((60 - clockGetTime().second()) * 1000) + 500;
+    }
+    else
+    {
+        // in case we reconfigure to show seconds but setTimerTo60 is going to be called
+        // we need to make sure to disconnect this so we don't end up updating only once
+        // a minute ;)
+        disconnect(_timer, SIGNAL(timeout()), this, SLOT(setTimerTo60()));
+    }
+
+    _timer->start(updateInterval);
+
+    // See if the clock wants to show the date.
+    showDate = _clock->showDate();
+    if (showDate)
+    {
+        TZoffset = zone->calc_TZ_offset(zone->zone(), true);
+        updateDateLabel();
+    }
+    
+    updateFollowBackground();
+    setBackground();
+
+    // FIXME: this means you can't have a transparent clock but a non-transparent
+    //        date or day =/
+
+    _clock->widget()->installEventFilter(this);   // catch mouse clicks
+    _clock->widget()->show();
+
+    _clock->forceUpdate(); /* force repaint */
+
+    if (showDayOfWeek)
+    {
+        _dayOfWeek->show();
+    }
+    else
+    {
+        _dayOfWeek->hide();
+    }
+
+    if (showDate || (zone->zoneIndex() != 0))
+    {
+        _date->show();
+    }
+    else
+    {
+        _date->hide();
+    }
+
+    emit(updateLayout());
+
+    showZone(zone->zoneIndex());
+}
+
+void ClockApplet::setTimerTo60()
+{
+//    kdDebug() << "setTimerTo60" << endl;
+    disconnect(_timer, SIGNAL(timeout()), this, SLOT(setTimerTo60()));
+    _timer->changeInterval(60000);
+}
+
+void ClockApplet::setBackground()
+{
+    QColor globalBgroundColor = KApplication::palette().active().background();
+    QColor fgColor, bgColor;
+    
+    if (!_clock)
+        return;
+    
+    switch (_prefs->type())
+    {
+        case Prefs::EnumType::Plain:
+            bgColor = _prefs->plainBackgroundColor();
+            fgColor = _prefs->plainForegroundColor();
+            break;
+        case Prefs::EnumType::Analog:
+            bgColor = _prefs->analogBackgroundColor();
+            fgColor = _prefs->analogForegroundColor();
+            break;
+        case Prefs::EnumType::Fuzzy:
+            bgColor = _prefs->fuzzyBackgroundColor();
+            fgColor = _prefs->fuzzyForegroundColor();
+            break;
+        case Prefs::EnumType::Digital:
+        default:
+            bgColor = _prefs->digitalBackgroundColor();
+            fgColor = _prefs->digitalForegroundColor();
+            break;
+    }
+    
+    if (!m_followBackgroundSetting)
+        _clock->widget()->setPaletteBackgroundColor(bgColor);
+    else
+        _clock->widget()->unsetPalette();
+    _clock->widget()->setPaletteForegroundColor(fgColor);
+    
+    bgColor = _prefs->dateBackgroundColor();
+        
+    // See if the clock wants to show the day of week.
+    // use same font/color as for date
+    showDayOfWeek = _clock->showDayOfWeek();
+    if (showDayOfWeek)
+    {
+        _dayOfWeek->setFont(_prefs->dateFont());
+        
+        if (!m_dateFollowBackgroundSetting)
+            _dayOfWeek->setBackgroundColor(bgColor);
+        else
+            _dayOfWeek->unsetPalette();
+        _dayOfWeek->setPaletteForegroundColor(_prefs->dateForegroundColor());
+    }
+    
+    // See if the clock wants to show the date.
+    showDate = _clock->showDate();
+    _date->setFont(_prefs->dateFont());
+    
+    if (!m_dateFollowBackgroundSetting)
+        _date->setPaletteBackgroundColor(bgColor);
+    else
+        _date->unsetPalette();
+    _date->setPaletteForegroundColor(_prefs->dateForegroundColor());
+}
+
+void ClockApplet::globalPaletteChange()
+{
+    if (!m_dateFollowBackgroundSetting && !m_followBackgroundSetting)
+        return;
+    
+    QColor globalBgroundColor = KApplication::palette().active().background();
+    
+    if (m_dateFollowBackgroundSetting)
+        _prefs->setDateBackgroundColor(globalBgroundColor);
+    
+    if (m_followBackgroundSetting)
+    {
+        // we need to makes sure we have the background color synced!
+        // otherwise when we switch color schemes again or restart kicker
+        // it might come back non-transparent
+        switch (_prefs->type())
+        {
+            case Prefs::EnumType::Plain:
+                _prefs->setPlainBackgroundColor(globalBgroundColor);
+                break;
+            case Prefs::EnumType::Analog:
+                _prefs->setAnalogBackgroundColor(globalBgroundColor);
+                break;
+            case Prefs::EnumType::Fuzzy:
+                _prefs->setFuzzyBackgroundColor(globalBgroundColor);
+                break;
+            case Prefs::EnumType::Digital:
+            default:
+                _prefs->setDigitalBackgroundColor(globalBgroundColor);
+                break;
+        }
+     }
+     
+    _prefs->writeConfig();
+}
+
+void ClockApplet::slotUpdate()
+{
+    if (_lastDate != clockGetDate())
+    {
+        updateDateLabel();
+    }
+
+    if (m_updateOnTheMinute)
+    {
+        // catch drift so we're never more than a few s out
+        int seconds = clockGetTime().second();
+//        kdDebug() << "checking for drift: " << seconds << endl;
+
+        if (seconds > 2)
+        {
+            connect(_timer, SIGNAL(timeout()), this, SLOT(setTimerTo60()));
+            _timer->changeInterval(((60 - seconds) * 1000) + 500);
+        }
+    }
+    _clock->updateClock();
+    KickerTip::Client::updateKickerTip();
+}
+
+void ClockApplet::slotCalendarDeleted()
+{
+    _calendar = 0L;
+    // don't reopen the calendar immediately ...
+    _disableCalendar = true;
+    QTimer::singleShot(100, this, SLOT(slotEnableCalendar()));
+
+    // we are free to show a tip know :)
+    installEventFilter(KickerTip::the());
+}
+
+
+void ClockApplet::slotEnableCalendar()
+{
+    _disableCalendar = false;
+}
+
+void ClockApplet::toggleCalendar()
+{
+    if (_calendar && !_disableCalendar)
+    {
+        // calls slotCalendarDeleted which does the cleanup for us
+        _calendar->close();
+        return;
+    }
+
+    if (_calendar || _disableCalendar)
+    {
+        return;
+    }
+
+    KickerTip::the()->untipFor(this);
+    removeEventFilter(KickerTip::the());
+
+    _calendar = new DatePicker(this, _lastDate, _prefs);
+    connect(_calendar, SIGNAL(destroyed()), SLOT(slotCalendarDeleted()));
+
+    QSize size = _prefs->calendarSize();
+
+    if (size != QSize())
+    {
+        _calendar->resize(size);
+    }
+    else
+    {
+        _calendar->adjustSize();
+    }
+
+    // make calendar fully visible
+    QPoint popupAt = KickerLib::popupPosition(popupDirection(),
+                                              _calendar,
+                                              this);
+    _calendar->move(popupAt);
+    _calendar->show();
+    _calendar->setFocus();
+}
+
+
+void ClockApplet::openContextMenu()
+{
+    if (!menu || !kapp->authorizeKAction("kicker_rmb"))
+        return;
+
+    menu->exec( QCursor::pos() );
+}
+
+void ClockApplet::contextMenuActivated(int result)
+{
+    if ((result >= 0) && (result < 100))
+    {
+        _prefs->setType(result);
+        _prefs->writeConfig();
+        reconfigure();
+        return;
+    };
+
+    if ((result >= 500) && (result < 600))
+    {
+        showZone(result-500);
+        zone->writeSettings();
+        return;
+    };
+
+    KProcess proc;
+    switch (result)
+    {
+        case 102:
+            preferences();
+            break;
+        case 103:
+            proc << locate("exe", "kdesu");
+            proc << "--nonewdcop";
+            proc << QString("%1 kde-clock.desktop --lang %2")
+                .arg(locate("exe", "kcmshell"))
+                .arg(KGlobal::locale()->language());
+            proc.start(KProcess::DontCare);
+            break;
+        case 104:
+            proc << locate("exe", "kcmshell");
+            proc << "kde-language.desktop";
+            proc.start(KProcess::DontCare);
+            break;
+        case 110:
+            preferences(true);
+            break;
+    } /* switch() */
+}
+
+void ClockApplet::aboutToShowContextMenu()
+{
+    bool bImmutable = config()->isImmutable();
+
+    menu->clear();
+    menu->insertTitle( SmallIcon( "clock" ), i18n( "Clock" ) );
+
+    KLocale *loc = KGlobal::locale();
+    QDateTime dt = QDateTime::currentDateTime();
+    dt = dt.addSecs(TZoffset);
+
+    KPopupMenu *copyMenu = new KPopupMenu( menu );
+    copyMenu->insertItem(loc->formatDateTime(dt), 201);
+    copyMenu->insertItem(loc->formatDate(dt.date()), 202);
+    copyMenu->insertItem(loc->formatDate(dt.date(), true), 203);
+    copyMenu->insertItem(loc->formatTime(dt.time()), 204);
+    copyMenu->insertItem(loc->formatTime(dt.time(), true), 205);
+    copyMenu->insertItem(dt.date().toString(), 206);
+    copyMenu->insertItem(dt.time().toString(), 207);
+    copyMenu->insertItem(dt.toString(), 208);
+    copyMenu->insertItem(dt.toString("yyyy-MM-dd hh:mm:ss"), 209);
+    connect( copyMenu, SIGNAL( activated(int) ), this, SLOT( slotCopyMenuActivated(int) ) );
+
+    if (!bImmutable)
+    {
+        KPopupMenu *zoneMenu = new KPopupMenu( menu );
+        connect(zoneMenu, SIGNAL(activated(int)), SLOT(contextMenuActivated(int)));
+        for (int i = 0; i <= zone->remoteZoneCount(); i++)
+        {
+            if (i == 0)
+            {
+                zoneMenu->insertItem(i18n("Local Timezone"), 500 + i);
+            }
+            else
+            {
+                zoneMenu->insertItem(i18n(zone->zone(i).utf8()).replace("_", " "), 500 + i);
+            }
+        }
+        zoneMenu->setItemChecked(500 + zone->zoneIndex(),true);
+        zoneMenu->insertSeparator();
+        zoneMenu->insertItem(SmallIcon("configure"), i18n("&Configure Timezones..."), 110);
+
+        KPopupMenu *type_menu = new KPopupMenu(menu);
+        connect(type_menu, SIGNAL(activated(int)), SLOT(contextMenuActivated(int)));
+        type_menu->insertItem(i18n("&Plain"), Prefs::EnumType::Plain, 1);
+        type_menu->insertItem(i18n("&Digital"), Prefs::EnumType::Digital, 2);
+        type_menu->insertItem(i18n("&Analog"), Prefs::EnumType::Analog, 3);
+        type_menu->insertItem(i18n("&Fuzzy"), Prefs::EnumType::Fuzzy, 4);
+        type_menu->setItemChecked(_prefs->type(),true);
+
+        menu->insertItem(i18n("&Type"), type_menu, 101, 1);
+        menu->insertItem(i18n("Show Time&zone"), zoneMenu, 110, 2);
+        if (kapp->authorize("user/root"))
+        {
+            menu->insertItem(SmallIcon("date"), i18n("&Adjust Date && Time..."), 103, 4);
+        }
+        menu->insertItem(SmallIcon("kcontrol"), i18n("Date && Time &Format..."), 104, 5);
+    }
+
+    menu->insertItem(SmallIcon("editcopy"), i18n("C&opy to Clipboard"), copyMenu, 105, 6);
+    if (!bImmutable)
+    {
+        menu->insertSeparator(7);
+        menu->insertItem(SmallIcon("configure"), i18n("&Configure Clock..."), 102, 8);
+    }
+}
+
+
+void ClockApplet::slotCopyMenuActivated( int id )
+{
+    QPopupMenu *m = (QPopupMenu *) sender();
+    QString s = m->text(id);
+    QApplication::clipboard()->setText(s);
+}
+
+QTime ClockApplet::clockGetTime()
+{
+    return QTime::currentTime().addSecs(TZoffset);
+}
+
+QDate ClockApplet::clockGetDate()
+{
+    return QDateTime::currentDateTime().addSecs(TZoffset).date();
+}
+
+void ClockApplet::showZone(int z)
+{
+    zone->setZone(z);
+    TZoffset = zone->calc_TZ_offset( zone->zone() );
+    updateDateLabel();
+    _clock->forceUpdate(); /* force repaint */
+}
+
+void ClockApplet::nextZone()
+{
+    zone->nextZone();
+    showZone(zone->zoneIndex());
+}
+
+void ClockApplet::prevZone()
+{
+    zone->prevZone();
+    showZone(zone->zoneIndex());
+}
+
+void ClockApplet::mousePressEvent(QMouseEvent *ev)
+{
+    switch (ev->button()) 
+    {
+        case QMouseEvent::LeftButton:
+            toggleCalendar();
+            break;
+        case QMouseEvent::RightButton:
+            openContextMenu();
+            break;
+        case QMouseEvent::MidButton:
+            nextZone();
+            QToolTip::remove(_clock->widget());
+            break;
+        default:
+            break;
+    }
+}
+
+void ClockApplet::wheelEvent(QWheelEvent* e)
+{
+    if (e->delta() < 0)
+    {
+        prevZone();
+    }
+    else
+    {
+        nextZone();
+    }
+
+    QToolTip::remove(_clock->widget());
+    KickerTip::Client::updateKickerTip();
+}
+
+// catch the mouse clicks of our child widgets
+bool ClockApplet::eventFilter( QObject *o, QEvent *e )
+{
+    if (( o == _clock->widget() || o == _date || o == _dayOfWeek) &&
+        e->type() == QEvent::MouseButtonPress )
+    {
+        mousePressEvent(static_cast<QMouseEvent*>(e) );
+        return true;
+    }
+
+    return KPanelApplet::eventFilter(o, e);
+}
+
+void ClockApplet::positionChange(Position p)
+{
+    KPanelApplet::positionChange(p);
+    reconfigure();
+}
+
+void ClockApplet::updateDateLabel(bool reLayout)
+{
+    _lastDate = clockGetDate();
+    _dayOfWeek->setText(KGlobal::locale()->calendar()->weekDayName(_lastDate));
+
+    if (zone->zoneIndex() != 0)
+    {
+        QString zone_s = i18n(zone->zone().utf8());
+        _date->setText(zone_s.mid(zone_s.find('/') + 1).replace("_", " "));
+        _date->setShown(true);
+    }
+    else
+    {
+        QString dateStr = KGlobal::locale()->formatDate(_lastDate, true);
+        _date->setText(dateStr);
+        _date->setShown(showDate);
+    }
+
+    if (reLayout)
+    {
+        if (_calendar && _lastDate != _calendar->date())
+        {
+            _calendar->setDate(_lastDate);
+        }
+
+        m_layoutTimer->stop();
+        m_layoutTimer->start(m_layoutDelay, true);
+    }
+}
+
+void ClockApplet::updateKickerTip(KickerTip::Data& data)
+{
+    int zoneCount = zone->remoteZoneCount();
+
+    QString activeZone = zone->zone();
+    if (zoneCount == 0)
+    {
+        QString _time = KGlobal::locale()->formatTime(clockGetTime(),
+                                                    _prefs->plainShowSeconds());
+        QString _date = KGlobal::locale()->formatDate(clockGetDate(), false);
+        data.message = _time;
+        data.subtext = _date;
+
+        if (!activeZone.isEmpty())
+        {
+            activeZone = i18n(activeZone.utf8());
+            data.subtext.append("<br>").append(activeZone.mid(activeZone.find('/') + 1).replace("_", " "));
+        }
+    }
+    else
+    {
+        int activeIndex = zone->zoneIndex();
+
+        for (int i = 0; i <= zone->remoteZoneCount(); i++)
+        {
+            QString m_zone = zone->zone(i);
+            TZoffset = zone->calc_TZ_offset(m_zone);
+
+            if (!m_zone.isEmpty())
+            {
+                m_zone = i18n(m_zone.utf8()); // ensure it gets translated
+            }
+
+            QString _time = KGlobal::locale()->formatTime(clockGetTime(),
+                                                          _prefs->plainShowSeconds());
+            QString _date = KGlobal::locale()->formatDate(clockGetDate(), false);
+
+            if (activeIndex == i)
+            {
+                data.message = m_zone.mid(m_zone.find('/') + 1).replace("_", " ");
+                data.message += "  " + _time + "<br>" + _date;
+            }
+            else
+            {
+                if (i == 0)
+                {
+                    data.subtext += "<b>" + i18n("Local Timezone") + "</b>";
+                }
+                else
+                {
+                    data.subtext += "<b>" + m_zone.mid(m_zone.find('/') + 1).replace("_", " ") + "</b>";
+                }
+                data.subtext += " " + _time + ", " + _date + "<br>";
+            }
+        }
+
+        TZoffset = zone->calc_TZ_offset(activeZone);
+    }
+
+    data.icon = DesktopIcon("date", KIcon::SizeMedium);
+    data.direction = popupDirection();
+    data.duration = 4000;
+}
+
+void ClockApplet::fixupLayout()
+{
+    m_layoutDelay = 0;
+
+    // ensure we have the right widget line up in horizontal mode
+    // when we are showing date beside the clock
+    // this fixes problems triggered by having the date first
+    // because of the date format (e.g. YY/MM/DD) and then hiding
+    // the date
+    if (orientation() == Qt::Horizontal && height() < 32)
+    {
+        bool mustShowDate = showDate || (zone->zoneIndex() != 0);
+
+        if (!mustShowDate && !showDayOfWeek)
+        {
+            _clock->widget()->move(0,0);
+        }
+
+        int dayWidth = 0;
+        if (!showDayOfWeek)
+        {
+            _dayOfWeek->move(_clock->widget()->width() + 4, 0);
+        }
+        else
+        {
+            dayWidth = _dayOfWeek->width();
+        }
+
+        if (!showDate)
+        {
+            _date->move(_clock->widget()->width() + dayWidth + 4, 0);
+        }
+    }
+
+    emit updateLayout();
+}
+
+int ClockApplet::type()
+{
+    return _prefs->type();
+}
+
+ClockAppletToolTip::ClockAppletToolTip( ClockApplet* clock )
+    : QToolTip( clock ),
+      m_clock( clock )
+{
+}
+
+void ClockAppletToolTip::maybeTip( const QPoint & /*point*/ )
+{
+    QString tipText;
+    if ( (m_clock->type() == Prefs::EnumType::Fuzzy) ||
+         (m_clock->type() == Prefs::EnumType::Analog) )
+    {
+        // show full time (incl. hour) as tooltip for Fuzzy clock
+        tipText = KGlobal::locale()->formatDateTime(QDateTime::currentDateTime().addSecs(m_clock->TZoffset));
+    }
+    else
+    {
+        tipText = KGlobal::locale()->formatDate(m_clock->clockGetDate());
+    }
+
+    if (m_clock->timezones() && m_clock->timezones()->zoneIndex() > 0)
+    {
+        tipText += "\n" + i18n("Showing time for %1").arg(i18n(m_clock->timezones()->zone().utf8()), false);
+    }
+
+    tip(m_clock->geometry(), tipText);
+}
+
+//************************************************************
+
+#include "clock.moc"
diff -Nurp kicker.orig/applets/launcher/quicklauncher.cpp kicker/applets/launcher/quicklauncher.cpp
--- kicker.orig/applets/launcher/quicklauncher.cpp	2008-08-19 18:16:57.000000000 +0000
+++ kicker/applets/launcher/quicklauncher.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -110,7 +110,7 @@ QuickLauncher::QuickLauncher(const QStri
     m_configAction = new KAction(i18n("Configure Quicklauncher..."), "configure", KShortcut(),
         this, SLOT(slotConfigure()), this);
 
-    m_saveTimer = new QTimer(this);
+    m_saveTimer = new QTimer(this, "m_saveTimer");
     connect(m_saveTimer, SIGNAL(timeout()), this, SLOT(saveConfig()));
 
     m_popularity = new PopularityStatistics();
diff -Nurp kicker.orig/applets/media/mediumbutton.cpp kicker/applets/media/mediumbutton.cpp
--- kicker.orig/applets/media/mediumbutton.cpp	2008-08-19 18:16:57.000000000 +0000
+++ kicker/applets/media/mediumbutton.cpp	2008-09-17 15:17:47.000000000 +0000
@@ -45,7 +45,8 @@
 #include <konq_drag.h>
 
 MediumButton::MediumButton(QWidget *parent, const KFileItem &fileItem)
-    : PanelPopupButton(parent), mActions(this, this), mFileItem(fileItem)
+	: PanelPopupButton(parent), mActions(this, this), mFileItem(fileItem), mOpenTimer(0,
+                "MediumButton::mOpenTimer")
 {
     KAction *a = KStdAction::paste(this, SLOT(slotPaste()),
                                     &mActions, "pasteto");
@@ -74,7 +75,7 @@ MediumButton::MediumButton(QWidget *pare
 
 MediumButton::~MediumButton()
 {
-    QPopupMenu *menu = popup();
+    QPopupMenu *menu = static_cast<QPopupMenu*>(popup());
     setPopup(0);
     delete menu;
 }
@@ -94,7 +95,8 @@ void MediumButton::setFileItem(const KFi
 
 void MediumButton::initPopup()
 {
-    QPopupMenu *old_popup = popup();
+
+    QPopupMenu *old_popup = static_cast<QPopupMenu*>(popup());
     
     KFileItemList items;
     items.append(&mFileItem);
diff -Nurp kicker.orig/applets/minipager/pagerbutton.cpp.orig kicker/applets/minipager/pagerbutton.cpp.orig
--- kicker.orig/applets/minipager/pagerbutton.cpp.orig	1970-01-01 00:00:00.000000000 +0000
+++ kicker/applets/minipager/pagerbutton.cpp.orig	2008-08-19 18:16:58.000000000 +0000
@@ -0,0 +1,824 @@
+/*****************************************************************
+
+Copyright (c) 1996-2000 the kicker authors. See file AUTHORS.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#include <stdlib.h>
+
+#include <qcursor.h>
+#include <qdrawutil.h>
+#include <qlineedit.h>
+#include <qpainter.h>
+#include <qpopupmenu.h>
+#include <qstylesheet.h>
+
+#include <netwm.h>
+#include <dcopclient.h>
+
+#include <kwinmodule.h>
+#include <ksharedpixmap.h>
+#include <kpixmapio.h>
+#include <kpixmapeffect.h>
+#include <kstringhandler.h>
+#include <kiconloader.h>
+
+#include "global.h"
+#include "kickertip.h"
+#include "kickerSettings.h"
+#include "kshadowengine.h"
+#include "paneldrag.h"
+
+#include "pagerapplet.h"
+#include "pagerbutton.h"
+#include "pagerbutton.moc"
+#include "pagersettings.h"
+
+#ifdef FocusOut
+#undef FocusOut
+#endif
+
+KSharedPixmap* KMiniPagerButton::s_commonSharedPixmap;
+KPixmap* KMiniPagerButton::s_commonBgPixmap;
+
+KMiniPagerButton::KMiniPagerButton(int desk, bool useViewPorts, const QPoint& viewport,
+        KMiniPager *parent, const char *name)
+    : QButton(parent, name),
+      m_pager(parent),
+      m_desktop(desk),
+      m_useViewports(useViewPorts),
+      m_viewport(viewport),
+      m_lineEdit(0),
+      m_sharedPixmap(0),
+      m_bgPixmap(0),
+      m_isCommon(false),
+      m_currentWindow(0),
+      m_inside(false)
+{
+    setToggleButton(true);
+    setAcceptDrops(true);
+    setWFlags(WNoAutoErase);
+
+    setBackgroundOrigin(AncestorOrigin);
+    installEventFilter(KickerTip::the());
+
+    m_desktopName = m_pager->kwin()->desktopName(m_desktop);
+
+    connect(this, SIGNAL(clicked()), SLOT(slotClicked()));
+    connect(this, SIGNAL(toggled(bool)), SLOT(slotToggled(bool)));
+    connect(&m_dragSwitchTimer, SIGNAL(timeout()), this, SLOT(slotDragSwitch()));
+    connect(&m_updateCompressor, SIGNAL(timeout()), this, SLOT(update()));
+
+    if (m_pager->desktopPreview())
+    {
+        setMouseTracking(true);
+    }
+    loadBgPixmap();
+}
+
+KMiniPagerButton::~KMiniPagerButton()
+{
+    delete m_sharedPixmap;
+    delete m_bgPixmap;
+}
+
+QRect KMiniPagerButton::mapGeometryToViewport(const KWin::WindowInfo& info) const
+{
+    if (!m_useViewports)
+        return info.frameGeometry();
+
+    // ### fix vertically layouted viewports
+    QRect _r(info.frameGeometry());
+    QPoint vx(m_pager->kwin()->currentViewport(m_pager->kwin()->currentDesktop()));
+
+    _r.moveBy( - (m_desktop - vx.x()) * QApplication::desktop()->width(),
+               0);
+
+    if ((info.state() & NET::Sticky))
+    {
+        _r.moveTopLeft(QPoint(_r.x() % QApplication::desktop()->width(),
+                    _r.y() % QApplication::desktop()->height()));
+
+    }
+
+    return _r;
+}
+
+QPoint KMiniPagerButton::mapPointToViewport(const QPoint& _p) const
+{
+    if (!m_useViewports) return _p;
+
+    QPoint vx(m_pager->kwin()->currentViewport(m_pager->kwin()->currentDesktop()));
+
+    // ### fix vertically layouted viewports
+    QPoint p(_p);
+    p.setX(p.x() + (m_desktop - vx.x()) * QApplication::desktop()->width());
+    return p;
+}
+
+bool KMiniPagerButton::shouldPaintWindow( KWin::WindowInfo *info ) const
+{
+    if (!info)
+      return false;
+
+//  if (info->mappingState != NET::Visible)
+//    return false;
+
+    NET::WindowType type = info->windowType( NET::NormalMask | NET::DesktopMask
+        | NET::DockMask | NET::ToolbarMask | NET::MenuMask | NET::DialogMask
+        | NET::OverrideMask | NET::TopMenuMask | NET::UtilityMask | NET::SplashMask );
+
+    if (type == NET::Desktop || type == NET::Dock || type == NET::TopMenu)
+      return false;
+
+    if (!m_useViewports && !info->isOnDesktop(m_desktop))
+      return false;
+
+    if (m_useViewports) {
+        QRect r = mapGeometryToViewport(*info);
+
+        if (!info->hasState(NET::Sticky) &&
+            !QApplication::desktop()->geometry().contains(r.topLeft()) &&
+            !QApplication::desktop()->geometry().contains(r.topRight()))
+            return false;
+    }
+
+    if (info->state() & NET::SkipPager || info->state() & NET::Shaded )
+      return false;
+
+    if (info->win() == m_pager->winId())
+      return false;
+
+    if ( info->isMinimized() )
+      return false;
+
+    return true;
+}
+
+void KMiniPagerButton::resizeEvent(QResizeEvent *ev)
+{
+    if (m_lineEdit)
+    {
+        m_lineEdit->setGeometry(rect());
+    }
+
+    delete m_bgPixmap;
+    m_bgPixmap = 0;
+
+    QButton::resizeEvent(ev);
+}
+
+void KMiniPagerButton::windowsChanged()
+{
+    m_currentWindow = 0;
+
+    if (!m_updateCompressor.isActive())
+    {
+        m_updateCompressor.start(50, true);
+    }
+}
+
+void KMiniPagerButton::backgroundChanged()
+{
+    delete s_commonSharedPixmap;
+    s_commonSharedPixmap = 0;
+    delete s_commonBgPixmap;
+    s_commonBgPixmap = 0;
+    loadBgPixmap();
+}
+
+void KMiniPagerButton::loadBgPixmap()
+{
+    if (m_pager->bgType() != PagerSettings::EnumBackgroundType::BgLive)
+        return; // not needed
+
+    DCOPClient *client = kapp->dcopClient();
+    if (!client->isAttached())
+    {
+        client->attach();
+    }
+
+    QCString kdesktop_name;
+    int screen_number = DefaultScreen(qt_xdisplay());
+    if (screen_number == 0)
+        kdesktop_name = "kdesktop";
+    else
+        kdesktop_name.sprintf("kdesktop-screen-%d", screen_number);
+
+    QByteArray data, replyData;
+    QCString replyType;
+    if (client->call(kdesktop_name, "KBackgroundIface", "isCommon()",
+                     data, replyType, replyData))
+    {
+        if (replyType == "bool")
+        {
+            QDataStream reply(replyData, IO_ReadOnly);
+            reply >> m_isCommon;
+        }
+    }
+
+    if (m_isCommon)
+    {
+        if (s_commonBgPixmap)
+        { // pixmap is already ready, just use it
+            backgroundLoaded( true );
+            return;
+        }
+        else if (s_commonSharedPixmap)
+        { // other button is already fetching the pixmap
+            connect(s_commonSharedPixmap, SIGNAL(done(bool)),
+                    SLOT(backgroundLoaded(bool)));
+            return;
+        }
+    }
+
+    QDataStream args( data, IO_WriteOnly );
+    args << 1;
+    client->send(kdesktop_name, "KBackgroundIface", "setExport(int)", data);
+
+    if (m_isCommon)
+    {
+        if (!s_commonSharedPixmap)
+        {
+            s_commonSharedPixmap = new KSharedPixmap;
+            connect(s_commonSharedPixmap, SIGNAL(done(bool)),
+                    SLOT(backgroundLoaded(bool)));
+        }
+        s_commonSharedPixmap->loadFromShared(QString("DESKTOP1"));
+    }
+    else
+    {
+        if (!m_sharedPixmap)
+        {
+            m_sharedPixmap = new KSharedPixmap;
+            connect(m_sharedPixmap, SIGNAL(done(bool)),
+                    SLOT(backgroundLoaded(bool)));
+        }
+        m_sharedPixmap->loadFromShared(QString("DESKTOP%1").arg(m_desktop));
+    }
+}
+
+static QPixmap scalePixmap(const QPixmap &pixmap, int width, int height)
+{
+    if (pixmap.width()>100)
+    {
+        KPixmapIO io;
+        QImage img( io.convertToImage( pixmap ) );
+        return io.convertToPixmap( img.smoothScale( width, height ) );
+    }
+
+    QImage img( pixmap.convertToImage().smoothScale( width, height ) );
+    QPixmap pix;
+    pix.convertFromImage( img );
+
+    return pix;
+}
+
+void KMiniPagerButton::backgroundLoaded( bool loaded )
+{
+    if (loaded)
+    {
+        if (!m_bgPixmap)
+        {
+            m_bgPixmap = new KPixmap;
+        }
+        if (m_isCommon)
+        {
+            if (!s_commonBgPixmap)
+            {
+                s_commonBgPixmap = new KPixmap;
+                *s_commonBgPixmap = scalePixmap(*s_commonSharedPixmap, width(), height());
+                s_commonSharedPixmap->deleteLater(); // let others get the signal too
+                s_commonSharedPixmap = 0;
+            }
+            *m_bgPixmap = *s_commonBgPixmap;
+        }
+        else
+        {
+            *m_bgPixmap = scalePixmap(*m_sharedPixmap, width(), height());
+            delete m_sharedPixmap;
+            m_sharedPixmap = 0L;
+        }
+
+        update();
+    }
+    else
+    {
+        kdWarning() << "Error getting the background\n";
+    }
+}
+
+void KMiniPagerButton::enterEvent(QEvent *)
+{
+    m_inside = true;
+    update();
+}
+
+void KMiniPagerButton::leaveEvent(QEvent *)
+{
+    m_inside = false;
+    update();
+}
+
+void KMiniPagerButton::drawButton(QPainter *bp)
+{
+    int w = width();
+    int h = height();
+    bool on = isOn();
+    bool down = isDown();
+
+    QBrush background;
+
+    bool liveBkgnd = m_pager->bgType() == PagerSettings::EnumBackgroundType::BgLive;
+    bool transparent = m_pager->bgType() == PagerSettings::EnumBackgroundType::BgTransparent;
+
+    // background
+
+    if (backgroundPixmap())
+    {
+        QPoint pt = backgroundOffset();
+        bp->drawTiledPixmap(0, 0, width(), height(), *backgroundPixmap(), pt.x(), pt.y());
+    }
+    else
+    {
+        bp->fillRect(0, 0, width(), height(), paletteBackgroundColor());
+    }
+    
+
+    // desktop background
+    
+    if (liveBkgnd)
+    {
+        if (m_bgPixmap && !m_bgPixmap->isNull())
+        {
+            if (on)
+            {
+                KPixmap tmp = *m_bgPixmap;
+                KPixmapEffect::intensity(tmp, 0.33);
+                bp->drawPixmap(0, 0, tmp);
+            }
+            else
+            {
+                bp->drawPixmap(0, 0, *m_bgPixmap);
+            }
+        }
+        else
+        {
+            liveBkgnd = false;
+        }
+    }
+
+    if (!liveBkgnd)
+    {
+        if (transparent)
+        {
+            // transparent windows get an 1 pixel frame...
+            if (on)
+            {
+                bp->setPen(colorGroup().midlight());
+            }
+            else if (down)
+            {
+                bp->setPen(KickerLib::blendColors(colorGroup().mid(),
+                                                 colorGroup().midlight()));
+            }
+            else
+            {
+                bp->setPen(colorGroup().dark());
+            }
+
+            bp->drawRect(0, 0, w, h);
+        }
+        else
+        {
+            QBrush background;
+
+            if (on)
+            {
+                background = colorGroup().brush(QColorGroup::Midlight);
+            }
+            else if (down)
+            {
+                background = KickerLib::blendColors(colorGroup().mid(),
+                                                    colorGroup().midlight());
+            }
+            else
+            {
+                background = colorGroup().brush(QColorGroup::Mid);
+            }
+
+            bp->fillRect(0, 0, w, h, background);
+        }
+    }
+
+    // window preview...
+    if (m_pager->desktopPreview())
+    {
+        KWinModule* kwin = m_pager->kwin();
+        KWin::WindowInfo *info = 0;
+        int dw = QApplication::desktop()->width();
+        int dh = QApplication::desktop()->height();
+
+        QValueList<WId> windows = kwin->stackingOrder();
+        QValueList<WId>::const_iterator itEnd = windows.constEnd();
+        for (QValueList<WId>::ConstIterator it = windows.constBegin(); it != itEnd; ++it)
+        {
+            info = m_pager->info(*it);
+
+            if (shouldPaintWindow(info))
+            {
+                QRect r = mapGeometryToViewport(*info);
+                r = QRect(r.x() * width() / dw, 2 + r.y() * height() / dh,
+                          r.width() * width() / dw, r.height() * height() / dh);
+
+                if (kwin->activeWindow() == info->win())
+                {
+                    QBrush brush = colorGroup().brush(QColorGroup::Highlight);
+                    qDrawShadeRect(bp, r, colorGroup(), false, 1, 0, &brush);
+                }
+                else
+                {
+                    QBrush brush = colorGroup().brush(QColorGroup::Button);
+
+                    if (on)
+                    {
+                        brush.setColor(brush.color().light(120));
+                    }
+
+                    bp->fillRect(r, brush);
+                    qDrawShadeRect(bp, r, colorGroup(), true, 1, 0);
+                }
+
+                if (m_pager->windowIcons() && r.width() > 15 && r.height() > 15)
+                {
+                    QPixmap icon = KWin::icon(*it, 16, 16, true);
+                    if (!icon.isNull())
+                    {
+                        bp->drawPixmap(r.left() + ((r.width() - 16) / 2),
+                                      r.top() + ((r.height() - 16) / 2),
+                                      icon);
+                    }
+                }
+            }
+        }
+    }
+
+    if (liveBkgnd)
+    {
+        // draw a little border around the individual buttons
+        // makes it look a bit more finished.
+        if (on)
+        {
+            bp->setPen(colorGroup().midlight());
+        }
+        else
+        {
+            bp->setPen(colorGroup().mid());
+        }
+
+        bp->drawRect(0, 0, w, h);
+    }
+
+    if (m_pager->labelType() != PagerSettings::EnumLabelType::LabelNone)
+    {
+        QString label = (m_pager->labelType() == PagerSettings::EnumLabelType::LabelNumber) ?
+                            QString::number(m_desktop) : m_desktopName;
+        
+        if (transparent || liveBkgnd)
+        {
+            bp->setPen(on ? colorGroup().midlight() : colorGroup().buttonText());
+            m_pager->shadowEngine()->drawText(*bp, QRect(0, 0, w, h), AlignCenter, label, size());
+        }
+        else
+            bp->drawText(0, 0, w, h, AlignCenter, label);
+    }
+    
+    if (m_inside)
+        KickerLib::drawBlendedRect(bp, QRect(1, 1, width() - 2, height() - 2), colorGroup().foreground());
+}
+
+void KMiniPagerButton::mousePressEvent(QMouseEvent * e)
+{
+    if (e->button() == RightButton)
+    {
+        // prevent LMB down -> RMB down -> LMB up sequence
+        if ((e->state() & MouseButtonMask ) == NoButton)
+        {
+            emit showMenu(e->globalPos(), m_desktop);
+            return;
+        }
+    }
+
+    if (m_pager->desktopPreview())
+    {
+        m_pager->clickPos = e->pos();
+    }
+
+    QButton::mousePressEvent(e);
+}
+
+void KMiniPagerButton::mouseReleaseEvent(QMouseEvent* e)
+{
+    m_pager->clickPos = QPoint();
+    QButton::mouseReleaseEvent(e);
+}
+
+void KMiniPagerButton::mouseMoveEvent(QMouseEvent* e)
+{
+    if (!m_pager->desktopPreview())
+    {
+        return;
+    }
+
+    int dw = QApplication::desktop()->width();
+    int dh = QApplication::desktop()->height();
+    int w = width();
+    int h = height();
+
+    QPoint pos(m_pager->clickPos.isNull() ? mapFromGlobal(QCursor::pos()) : m_pager->clickPos);
+    QPoint p = mapPointToViewport(QPoint(pos.x() * dw / w, pos.y() * dh / h));
+
+    Task::Ptr wasWindow = m_currentWindow;
+    m_currentWindow = TaskManager::the()->findTask(m_useViewports ? 1 : m_desktop, p);
+
+    if (wasWindow != m_currentWindow)
+    {
+        KickerTip::Client::updateKickerTip();
+    }
+
+    if (m_currentWindow && !m_pager->clickPos.isNull() &&
+        (m_pager->clickPos - e->pos()).manhattanLength() > KGlobalSettings::dndEventDelay())
+    {
+        QRect r = m_currentWindow->geometry();
+
+        // preview window height, window width
+        int ww = r.width() * w / dw;
+        int wh = r.height() * h / dh;
+        QPixmap windowImage(ww, wh);
+        QPainter bp(&windowImage, this);
+
+        bp.setPen(colorGroup().foreground());
+        bp.drawRect(0, 0, ww, wh);
+        bp.fillRect(1, 1, ww - 2, wh - 2, colorGroup().background());
+
+        Task::List tasklist;
+        tasklist.append(m_currentWindow);
+        TaskDrag* drag = new TaskDrag(tasklist, this);
+        QPoint offset(m_pager->clickPos.x() - (r.x() * w / dw),
+                m_pager->clickPos.y() - (r.y() * h / dh));
+        drag->setPixmap(windowImage, offset);
+        drag->dragMove();
+
+        if (isDown())
+        {
+            setDown(false);
+        }
+
+        m_pager->clickPos = QPoint();
+    }
+}
+
+void KMiniPagerButton::dragEnterEvent(QDragEnterEvent* e)
+{
+    if (PanelDrag::canDecode(e))
+    {
+        // ignore container drags
+        return;
+    }
+    else if (TaskDrag::canDecode(e))
+    {
+        // if it's a task drag don't switch the desktop, just accept it
+        e->accept();
+        setDown(true);
+    }
+    else
+    {
+        // if a dragitem is held for over a pager button for two seconds,
+        // activate corresponding desktop
+        m_dragSwitchTimer.start(1000, true);
+        QButton::dragEnterEvent(e);
+    }
+}
+
+void KMiniPagerButton::dropEvent(QDropEvent* e)
+{
+    if (TaskDrag::canDecode(e))
+    {
+        e->accept();
+        Task::List tasks(TaskDrag::decode(e));
+
+        if ((m_useViewports || e->source() == this) && tasks.count() == 1)
+        {
+            Task::Ptr task = tasks[0];
+            int dw = QApplication::desktop()->width();
+            int dh = QApplication::desktop()->height();
+            int w = width();
+            int h = height();
+            QRect location = mapGeometryToViewport(task->info());
+            QPoint pos = mapPointToViewport(e->pos());
+            int deltaX = pos.x() - m_pager->clickPos.x();
+            int deltaY = pos.y() - m_pager->clickPos.y();
+
+            if (abs(deltaX) < 3)
+            {
+                deltaX = 0;
+            }
+            else
+            {
+                deltaX = deltaX * dw / w;
+            }
+
+            if (abs(deltaY) < 3)
+            {
+                deltaY = 0;
+            }
+            else
+            {
+                deltaY = deltaY * dh / h;
+            }
+
+            location.moveBy(deltaX, deltaY);
+
+            XMoveWindow(x11Display(), task->window(), location.x(), location.y());
+            if ((e->source() != this || !task->isOnAllDesktops()) &&
+                task->desktop() != m_desktop)
+            {
+                task->toDesktop(m_desktop);
+            }
+        }
+        else
+        {
+            Task::List::iterator itEnd = tasks.end();
+            for (Task::List::iterator it = tasks.begin(); it != itEnd; ++it)
+            {
+                (*it)->toDesktop(m_desktop);
+            }
+        }
+
+        setDown(false);
+    }
+
+    QButton::dropEvent( e );
+}
+
+void KMiniPagerButton::enabledChange( bool oldEnabled )
+{
+    if (m_pager->bgType() == PagerSettings::EnumBackgroundType::BgLive)
+    {
+        m_pager->refresh();
+    }
+
+    QButton::enabledChange(oldEnabled);
+}
+
+void KMiniPagerButton::dragLeaveEvent( QDragLeaveEvent* e )
+{
+    m_dragSwitchTimer.stop();
+
+    if (m_pager->kwin()->currentDesktop() != m_desktop)
+    {
+        setDown(false);
+    }
+
+    QButton::dragLeaveEvent( e );
+}
+
+void KMiniPagerButton::slotDragSwitch()
+{
+    emit buttonSelected(m_desktop);
+}
+
+void KMiniPagerButton::slotClicked()
+{
+    emit buttonSelected(m_desktop);
+}
+
+void KMiniPagerButton::rename()
+{
+  if ( !m_lineEdit ) {
+    m_lineEdit = new QLineEdit( this );
+    connect( m_lineEdit, SIGNAL( returnPressed() ), m_lineEdit, SLOT( hide() ) );
+    m_lineEdit->installEventFilter( this );
+  }
+  m_lineEdit->setGeometry( rect() );
+  m_lineEdit->setText(m_desktopName);
+  m_lineEdit->show();
+  m_lineEdit->setFocus();
+  m_lineEdit->selectAll();
+  m_pager->emitRequestFocus();
+}
+
+void KMiniPagerButton::slotToggled( bool b )
+{
+    if ( !b && m_lineEdit )
+    {
+        m_lineEdit->hide();
+    }
+}
+
+bool KMiniPagerButton::eventFilter( QObject *o, QEvent * e)
+{
+    if (o && o == m_lineEdit &&
+        (e->type() == QEvent::FocusOut || e->type() == QEvent::Hide))
+    {
+        m_pager->kwin()->setDesktopName( m_desktop, m_lineEdit->text() );
+        m_desktopName = m_lineEdit->text();
+        QTimer::singleShot( 0, m_lineEdit, SLOT( deleteLater() ) );
+        m_lineEdit = 0;
+        return true;
+    }
+
+    return QButton::eventFilter(o, e);
+}
+
+void KMiniPagerButton::updateKickerTip(KickerTip::Data &data)
+{
+    Task::Dict tasks = TaskManager::the()->tasks();
+    Task::Dict::iterator taskEnd = tasks.end();
+    uint taskCounter = 0;
+    uint taskLimiter = 4;
+    QString lastWindow;
+
+    for (Task::Dict::iterator it = tasks.begin(); it != taskEnd; ++it)
+    {
+        if (it.data()->desktop() == m_desktop || it.data()->isOnAllDesktops())
+        {
+            taskCounter++;
+            if (taskCounter > taskLimiter)
+            {
+                lastWindow = it.data()->visibleName();
+                continue;
+            }
+
+            QPixmap winIcon = it.data()->pixmap();
+            QString bullet;
+
+            if (winIcon.isNull())
+            {
+                bullet = "&bull;";
+            }
+            else
+            {
+                data.mimeFactory->setPixmap(QString::number(taskCounter), winIcon);
+                bullet = QString("<img src=\"%1\" width=\"%2\" height=\"%3\">").arg(taskCounter).arg(16).arg(16);
+            }
+
+            QString name = KStringHandler::cPixelSqueeze(it.data()->visibleName(), fontMetrics(), 400);
+            name = QStyleSheet::escape(name);
+            if (it.data() == m_currentWindow)
+            {
+                data.subtext.append(QString("<br>%1&nbsp; <u>").arg(bullet));
+                data.subtext.append(name).append("</u>");
+            }
+            else
+            {
+                data.subtext.append(QString("<br>%1&nbsp; ").arg(bullet));
+                data.subtext.append(name);
+            }
+        }
+    }
+
+    if (taskCounter > taskLimiter)
+    {
+        if (taskCounter - taskLimiter == 1)
+        {
+            data.subtext.append("<br>&bull; ").append(lastWindow);
+        }
+        else
+        {
+            data.subtext.append("<br>&bull; <i>")
+                        .append(i18n("and 1 other", "and %n others", taskCounter - taskLimiter))
+                        .append("</i>");
+        }
+    }
+
+    if (taskCounter > 0)
+    {
+        data.subtext.prepend(i18n("One window:",
+                                  "%n windows:",
+                                  taskCounter));
+    }
+
+    data.duration = 4000;
+    data.icon = DesktopIcon("window_list", KIcon::SizeMedium);
+    data.message = QStyleSheet::escape(m_desktopName);
+    data.direction = m_pager->popupDirection();
+}
+
diff -Nurp kicker.orig/applets/minipager/pagerbutton.cpp.rej kicker/applets/minipager/pagerbutton.cpp.rej
--- kicker.orig/applets/minipager/pagerbutton.cpp.rej	1970-01-01 00:00:00.000000000 +0000
+++ kicker/applets/minipager/pagerbutton.cpp.rej	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,19 @@
+***************
+*** 69,75 ****
+        m_sharedPixmap(0),
+        m_bgPixmap(0),
+        m_isCommon(false),
+-       m_currentWindow(0)
+  {
+      setToggleButton(true);
+      setAcceptDrops(true);
+--- 69,77 ----
+        m_sharedPixmap(0),
+        m_bgPixmap(0),
+        m_isCommon(false),
++       m_currentWindow(0),
++       m_updateCompressor(0, "KMiniPagerButton::updateCompressor"),
++       m_dragSwitchTimer(0, "KMiniPagerButton::dragSwitchTimer")
+  {
+      setToggleButton(true);
+      setAcceptDrops(true);
diff -Nurp kicker.orig/applets/naughty/NaughtyProcessMonitor.cpp kicker/applets/naughty/NaughtyProcessMonitor.cpp
--- kicker.orig/applets/naughty/NaughtyProcessMonitor.cpp	2005-10-10 15:03:59.000000000 +0000
+++ kicker/applets/naughty/NaughtyProcessMonitor.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -94,7 +94,7 @@ NaughtyProcessMonitor::NaughtyProcessMon
   d = new NaughtyProcessMonitorPrivate;
   d->interval_ = interval * 1000;
   d->triggerLevel_ = triggerLevel;
-  d->timer_ = new QTimer(this);
+  d->timer_ = new QTimer(this, "NaughtyProcessMonitorPrivate::timer");
   connect(d->timer_, SIGNAL(timeout()), this, SLOT(slotTimeout()));
 }
 
diff -Nurp kicker.orig/applets/systemtray/systemtrayapplet.cpp kicker/applets/systemtray/systemtrayapplet.cpp
--- kicker.orig/applets/systemtray/systemtrayapplet.cpp	2008-08-19 18:16:58.000000000 +0000
+++ kicker/applets/systemtray/systemtrayapplet.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -375,7 +375,7 @@ void SystemTrayApplet::showExpandButton(
             connect(m_expandButton, SIGNAL(clicked()),
                     this, SLOT(toggleExpanded()));
 
-            m_autoRetractTimer = new QTimer(this);
+            m_autoRetractTimer = new QTimer(this, "m_autoRetractTimer");
             connect(m_autoRetractTimer, SIGNAL(timeout()),
                     this, SLOT(checkAutoRetract()));
         }
diff -Nurp kicker.orig/applets/systemtray/systemtrayapplet.cpp.orig kicker/applets/systemtray/systemtrayapplet.cpp.orig
--- kicker.orig/applets/systemtray/systemtrayapplet.cpp.orig	1970-01-01 00:00:00.000000000 +0000
+++ kicker/applets/systemtray/systemtrayapplet.cpp.orig	2008-08-19 18:16:58.000000000 +0000
@@ -0,0 +1,1002 @@
+/*****************************************************************
+
+Copyright (c) 2000-2001 Matthias Ettrich <ettrich@kde.org>
+              2000-2001 Matthias Elter   <elter@kde.org>
+              2001      Carsten Pfeiffer <pfeiffer@kde.org>
+              2001      Martijn Klingens <mklingens@yahoo.com>
+              2004      Aaron J. Seigo   <aseigo@kde.org>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#include <qcursor.h>
+#include <qlayout.h>
+#include <qpopupmenu.h>
+#include <qtimer.h>
+#include <qpixmap.h>
+#include <qevent.h>
+#include <qstyle.h>
+#include <qpainter.h>
+
+#include <dcopclient.h>
+#include <kapplication.h>
+#include <klocale.h>
+#include <kconfig.h>
+#include <kdebug.h>
+#include <kglobal.h>
+#include <krun.h>
+#include <kwinmodule.h>
+#include <kdialogbase.h>
+#include <kactionselector.h>
+#include <kiconloader.h>
+#include <kwin.h>
+
+#include "simplebutton.h"
+
+#include "systemtrayapplet.h"
+#include "systemtrayapplet.moc"
+
+#include <X11/Xlib.h>
+
+extern "C"
+{
+    KDE_EXPORT KPanelApplet* init(QWidget *parent, const QString& configFile)
+    {
+        KGlobal::locale()->insertCatalogue("ksystemtrayapplet");
+        return new SystemTrayApplet(configFile, KPanelApplet::Normal,
+                                    KPanelApplet::Preferences, parent, "ksystemtrayapplet");
+    }
+}
+
+SystemTrayApplet::SystemTrayApplet(const QString& configFile, Type type, int actions,
+                                   QWidget *parent, const char *name)
+  : KPanelApplet(configFile, type, actions, parent, name),
+    m_showFrame(false),
+    m_showHidden(false),
+    m_expandButton(0),
+    m_settingsDialog(0),
+    m_iconSelector(0),
+    m_autoRetractTimer(0),
+    m_autoRetract(false),
+    m_iconSize(24),
+    m_layout(0)
+{
+    loadSettings();
+
+    setBackgroundOrigin(AncestorOrigin);
+
+    kwin_module = new KWinModule(this);
+
+    // kApplication notifies us of settings changes. added to support
+    // disabling of frame effect on mouse hover
+    kapp->dcopClient()->setNotifications(true);
+    connectDCOPSignal("kicker", "kicker", "configurationChanged()", "loadSettings()", false);
+
+    QTimer::singleShot(0, this, SLOT(initialize()));
+}
+
+void SystemTrayApplet::initialize()
+{
+    // register existing tray windows
+    const QValueList<WId> systemTrayWindows = kwin_module->systemTrayWindows();
+    bool existing = false;
+    for (QValueList<WId>::ConstIterator it = systemTrayWindows.begin();
+         it != systemTrayWindows.end(); ++it )
+    {
+        embedWindow(*it, true);
+        existing = true;
+    }
+
+    showExpandButton(!m_hiddenWins.isEmpty());
+
+    if (existing)
+    {
+        updateVisibleWins();
+        layoutTray();
+    }
+
+    // the KWinModule notifies us when tray windows are added or removed
+    connect( kwin_module, SIGNAL( systemTrayWindowAdded(WId) ),
+             this, SLOT( systemTrayWindowAdded(WId) ) );
+    connect( kwin_module, SIGNAL( systemTrayWindowRemoved(WId) ),
+             this, SLOT( updateTrayWindows() ) );
+
+    QCString screenstr;
+    screenstr.setNum(qt_xscreen());
+    QCString trayatom = "_NET_SYSTEM_TRAY_S" + screenstr;
+
+    Display *display = qt_xdisplay();
+
+    net_system_tray_selection = XInternAtom(display, trayatom, false);
+    net_system_tray_opcode = XInternAtom(display, "_NET_SYSTEM_TRAY_OPCODE", false);
+
+    // Acquire system tray
+    XSetSelectionOwner(display,
+                       net_system_tray_selection,
+                       winId(),
+                       CurrentTime);
+
+    WId root = qt_xrootwin();
+
+    if (XGetSelectionOwner (display, net_system_tray_selection) == winId())
+    {
+        XClientMessageEvent xev;
+
+        xev.type = ClientMessage;
+        xev.window = root;
+
+        xev.message_type = XInternAtom (display, "MANAGER", False);
+        xev.format = 32;
+        xev.data.l[0] = CurrentTime;
+        xev.data.l[1] = net_system_tray_selection;
+        xev.data.l[2] = winId();
+        xev.data.l[3] = 0;        /* manager specific data */
+        xev.data.l[4] = 0;        /* manager specific data */
+
+        XSendEvent (display, root, False, StructureNotifyMask, (XEvent *)&xev);
+    }
+    
+    setBackground();
+}
+
+SystemTrayApplet::~SystemTrayApplet()
+{
+    for (TrayEmbedList::const_iterator it = m_hiddenWins.constBegin();
+         it != m_hiddenWins.constEnd();
+         ++it)
+    {
+        delete *it;
+    }
+
+    for (TrayEmbedList::const_iterator it = m_shownWins.constBegin();
+         it != m_shownWins.constEnd();
+         ++it)
+    {
+        delete *it;
+    }
+
+    KGlobal::locale()->removeCatalogue("ksystemtrayapplet");
+}
+
+bool SystemTrayApplet::x11Event( XEvent *e )
+{
+#define SYSTEM_TRAY_REQUEST_DOCK    0
+#define SYSTEM_TRAY_BEGIN_MESSAGE   1
+#define SYSTEM_TRAY_CANCEL_MESSAGE  2
+    if ( e->type == ClientMessage ) {
+        if ( e->xclient.message_type == net_system_tray_opcode &&
+             e->xclient.data.l[1] == SYSTEM_TRAY_REQUEST_DOCK) {
+            if( isWinManaged( (WId)e->xclient.data.l[2] ) ) // we already manage it
+                return true;
+            embedWindow( e->xclient.data.l[2], false );
+            layoutTray();
+            return true;
+        }
+    }
+    return KPanelApplet::x11Event( e ) ;
+}
+
+void SystemTrayApplet::preferences()
+{
+    if (m_settingsDialog)
+    {
+        m_settingsDialog->show();
+        m_settingsDialog->raise();
+        return;
+    }
+
+    m_settingsDialog = new KDialogBase(0, "systrayconfig",
+                                       false, i18n("Configure System Tray"),
+                                       KDialogBase::Ok | KDialogBase::Apply | KDialogBase::Cancel,
+                                       KDialogBase::Ok, true);
+    m_settingsDialog->resize(450, 400);
+    connect(m_settingsDialog, SIGNAL(applyClicked()), this, SLOT(applySettings()));
+    connect(m_settingsDialog, SIGNAL(okClicked()), this, SLOT(applySettings()));
+    connect(m_settingsDialog, SIGNAL(finished()), this, SLOT(settingsDialogFinished()));
+
+    m_iconSelector = new KActionSelector(m_settingsDialog);
+    m_iconSelector->setAvailableLabel(i18n("Visible icons:"));
+    m_iconSelector->setSelectedLabel(i18n("Hidden icons:"));
+    m_iconSelector->setShowUpDownButtons(false);
+    m_settingsDialog->setMainWidget(m_iconSelector);
+
+    QListBox *shownListBox = m_iconSelector->availableListBox();
+    QListBox *hiddenListBox = m_iconSelector->selectedListBox();
+
+    TrayEmbedList::const_iterator it = m_shownWins.begin();
+    TrayEmbedList::const_iterator itEnd = m_shownWins.end();
+    for (; it != itEnd; ++it)
+    {
+        QString name = KWin::windowInfo((*it)->embeddedWinId()).name();
+        if(!shownListBox->findItem(name, Qt::ExactMatch | Qt::CaseSensitive))
+        {
+            shownListBox->insertItem(KWin::icon((*it)->embeddedWinId(), 22, 22, true), name);
+        }
+    }
+
+    it = m_hiddenWins.begin();
+    itEnd = m_hiddenWins.end();
+    for (; it != itEnd; ++it)
+    {
+        QString name = KWin::windowInfo((*it)->embeddedWinId()).name();
+        if(!hiddenListBox->findItem(name, Qt::ExactMatch | Qt::CaseSensitive))
+        {
+            hiddenListBox->insertItem(KWin::icon((*it)->embeddedWinId(), 22, 22, true), name);
+        }
+    }
+
+    m_settingsDialog->show();
+}
+
+void SystemTrayApplet::settingsDialogFinished()
+{
+    m_settingsDialog->delayedDestruct();
+    m_settingsDialog = 0;
+    m_iconSelector = 0;
+}
+
+void SystemTrayApplet::applySettings()
+{
+    if (!m_iconSelector)
+    {
+        return;
+    }
+
+    KConfig *conf = config();
+    conf->setGroup("HiddenTrayIcons");
+    QString name;
+
+    // use the following snippet of code someday to implement ordering
+    // of icons
+    /*
+    m_visibleIconList.clear();
+    QListBoxItem* item = m_iconSelector->availableListBox()->firstItem();
+    for (; item; item = item->next())
+    {
+        m_visibleIconList.append(item->text());
+    }
+    conf->writeEntry("Visible", m_visibleIconList);
+    selection.clear();*/
+
+    m_hiddenIconList.clear();
+    QListBoxItem* item = m_iconSelector->selectedListBox()->firstItem();
+    for (; item; item = item->next())
+    {
+        m_hiddenIconList.append(item->text());
+    }
+    conf->writeEntry("Hidden", m_hiddenIconList);
+    conf->sync();
+
+    TrayEmbedList::iterator it = m_shownWins.begin();
+    while (it != m_shownWins.end())
+    {
+        if (shouldHide((*it)->embeddedWinId()))
+        {
+            m_hiddenWins.append(*it);
+            it = m_shownWins.erase(it);
+        }
+        else
+        {
+            ++it;
+        }
+    }
+
+    it = m_hiddenWins.begin();
+    while (it != m_hiddenWins.end())
+    {
+        if (!shouldHide((*it)->embeddedWinId()))
+        {
+            m_shownWins.append(*it);
+            it = m_hiddenWins.erase(it);
+        }
+        else
+        {
+            ++it;
+        }
+    }
+
+    showExpandButton(!m_hiddenWins.isEmpty());
+
+    updateVisibleWins();
+    layoutTray();
+}
+
+void SystemTrayApplet::checkAutoRetract()
+{
+    if (!m_autoRetractTimer)
+    {
+        return;
+    }
+
+    if (!geometry().contains(mapFromGlobal(QCursor::pos())))
+    {
+        m_autoRetractTimer->stop();
+        if (m_autoRetract)
+        {
+            m_autoRetract = false;
+
+            if (m_showHidden)
+            {
+                retract();
+            }
+        }
+        else
+        {
+            m_autoRetract = true;
+            m_autoRetractTimer->start(2000, true);
+        }
+
+    }
+    else
+    {
+        m_autoRetract = false;
+        m_autoRetractTimer->start(250, true);
+    }
+}
+
+void SystemTrayApplet::showExpandButton(bool show)
+{
+    if (show)
+    {
+        if (!m_expandButton)
+        {
+            m_expandButton = new SimpleArrowButton(this);
+            m_expandButton->installEventFilter(this);
+            refreshExpandButton();
+
+            if (orientation() == Vertical)
+            {
+                m_expandButton->setFixedSize(width() - 4,
+                                             m_expandButton->sizeHint()
+                                                            .height());
+            }
+            else
+            {
+                m_expandButton->setFixedSize(m_expandButton->sizeHint()
+                                                            .width(),
+                                             height() - 4);
+            }
+            connect(m_expandButton, SIGNAL(clicked()),
+                    this, SLOT(toggleExpanded()));
+
+            m_autoRetractTimer = new QTimer(this);
+            connect(m_autoRetractTimer, SIGNAL(timeout()),
+                    this, SLOT(checkAutoRetract()));
+        }
+        else
+        {
+            refreshExpandButton();
+        }
+
+        m_expandButton->show();
+    }
+    else if (m_expandButton)
+    {
+        m_expandButton->hide();
+    }
+}
+
+void SystemTrayApplet::orientationChange( Orientation /*orientation*/ )
+{
+    refreshExpandButton();
+}
+
+void SystemTrayApplet::loadSettings()
+{
+    // set our defaults
+    setFrameStyle(NoFrame);
+    m_showFrame = false;
+
+    KConfig *conf = config();
+    conf->setGroup("General");
+
+    if (conf->readBoolEntry("ShowPanelFrame", false))
+    {
+        setFrameStyle(Panel | Sunken);
+    }
+
+    conf->setGroup("HiddenTrayIcons");
+    m_hiddenIconList = conf->readListEntry("Hidden");
+
+    //Note This setting comes from kdeglobal.
+    conf->setGroup("System Tray");
+    m_iconSize = conf->readNumEntry("systrayIconWidth", 22);
+}
+
+void SystemTrayApplet::systemTrayWindowAdded( WId w )
+{
+    if (isWinManaged(w))
+    {
+        // we already manage it
+        return;
+    }
+
+    embedWindow(w, true);
+    updateVisibleWins();
+    layoutTray();
+
+    if (m_showFrame && frameStyle() == NoFrame)
+    {
+        setFrameStyle(Panel|Sunken);
+    }
+}
+
+void SystemTrayApplet::embedWindow( WId w, bool kde_tray )
+{
+    TrayEmbed* emb = new TrayEmbed(kde_tray, this);
+    emb->setAutoDelete(false);
+
+    if (kde_tray)
+    {
+        static Atom hack_atom = XInternAtom( qt_xdisplay(), "_KDE_SYSTEM_TRAY_EMBEDDING", False );
+        XChangeProperty( qt_xdisplay(), w, hack_atom, hack_atom, 32, PropModeReplace, NULL, 0 );
+        emb->embed(w);
+        XDeleteProperty( qt_xdisplay(), w, hack_atom );
+    }
+    else
+    {
+        emb->embed(w);
+    }
+
+    if (emb->embeddedWinId() == 0)  // error embedding
+    {
+        delete emb;
+        return;
+    }
+
+    connect(emb, SIGNAL(embeddedWindowDestroyed()), SLOT(updateTrayWindows()));
+    emb->setMinimumSize(m_iconSize, m_iconSize);
+
+    if (shouldHide(w))
+    {
+        emb->hide();
+        m_hiddenWins.append(emb);
+        showExpandButton(true);
+    }
+    else
+    {
+        emb->hide();
+        emb->setBackground();
+        emb->show();
+        m_shownWins.append(emb);
+    }
+}
+
+bool SystemTrayApplet::isWinManaged(WId w)
+{
+    TrayEmbedList::const_iterator lastEmb = m_shownWins.end();
+    for (TrayEmbedList::const_iterator emb = m_shownWins.begin(); emb != lastEmb; ++emb)
+    {
+        if ((*emb)->embeddedWinId() == w) // we already manage it
+        {
+            return true;
+        }
+    }
+
+    lastEmb = m_hiddenWins.end();
+    for (TrayEmbedList::const_iterator emb = m_hiddenWins.begin(); emb != lastEmb; ++emb)
+    {
+        if ((*emb)->embeddedWinId() == w) // we already manage it
+        {
+            return true;
+        }
+    }
+
+    return false;
+}
+
+bool SystemTrayApplet::shouldHide(WId w)
+{
+    return m_hiddenIconList.find(KWin::windowInfo(w).name()) != m_hiddenIconList.end();
+}
+
+void SystemTrayApplet::updateVisibleWins()
+{
+    TrayEmbedList::const_iterator lastEmb = m_hiddenWins.end();
+    TrayEmbedList::const_iterator emb = m_hiddenWins.begin();
+
+    if (m_showHidden)
+    {
+        for (; emb != lastEmb; ++emb)
+        {
+            (*emb)->hide();
+            (*emb)->setBackground();
+            (*emb)->show();
+        }
+    }
+    else
+    {
+        for (; emb != lastEmb; ++emb)
+        {
+            (*emb)->hide();
+        }
+    }
+}
+
+void SystemTrayApplet::toggleExpanded()
+{
+    if (m_showHidden)
+    {
+        retract();
+    }
+    else
+    {
+        expand();
+    }
+}
+
+void SystemTrayApplet::refreshExpandButton()
+{
+    if (!m_expandButton)
+    {
+        return;
+    }
+
+    Qt::ArrowType a;
+
+    if (orientation() == Vertical)
+        a = m_showHidden ? Qt::DownArrow : Qt::UpArrow;
+    else
+        a = (m_showHidden ^ kapp->reverseLayout()) ? Qt::RightArrow : Qt::LeftArrow;
+    
+    m_expandButton->setArrowType(a);
+}
+
+void SystemTrayApplet::expand()
+{
+    m_showHidden = true;
+    refreshExpandButton();
+
+    updateVisibleWins();
+    layoutTray();
+
+    if (m_autoRetractTimer)
+    {
+        m_autoRetractTimer->start(250, true);
+    }
+}
+
+void SystemTrayApplet::retract()
+{
+    if (m_autoRetractTimer)
+    {
+        m_autoRetractTimer->stop();
+    }
+
+    m_showHidden = false;
+    refreshExpandButton();
+
+    updateVisibleWins();
+    layoutTray();
+}
+
+void SystemTrayApplet::updateTrayWindows()
+{
+    TrayEmbedList::iterator emb = m_shownWins.begin();
+    while (emb != m_shownWins.end())
+    {
+        WId wid = (*emb)->embeddedWinId();
+        if ((wid == 0) ||
+            ((*emb)->kdeTray() &&
+             !kwin_module->systemTrayWindows().contains(wid)))
+        {
+            (*emb)->deleteLater();
+            emb = m_shownWins.erase(emb);
+        }
+        else
+        {
+            ++emb;
+        }
+    }
+
+    emb = m_hiddenWins.begin();
+    while (emb != m_hiddenWins.end())
+    {
+        WId wid = (*emb)->embeddedWinId();
+        if ((wid == 0) ||
+            ((*emb)->kdeTray() &&
+             !kwin_module->systemTrayWindows().contains(wid)))
+        {
+            (*emb)->deleteLater();
+            emb = m_hiddenWins.erase(emb);
+        }
+        else
+        {
+            ++emb;
+        }
+    }
+
+    showExpandButton(!m_hiddenWins.isEmpty());
+    updateVisibleWins();
+    layoutTray();
+}
+
+int SystemTrayApplet::maxIconWidth() const
+{
+    int largest = m_iconSize;
+
+    TrayEmbedList::const_iterator lastEmb = m_shownWins.end();
+    for (TrayEmbedList::const_iterator emb = m_shownWins.begin(); emb != lastEmb; ++emb)
+    {
+        if (*emb == 0)
+        {
+            continue;
+        }
+
+        int width = (*emb)->width();
+        if (width > largest)
+        {
+            largest = width;
+        }
+    }
+
+    if (m_showHidden)
+    {
+        lastEmb = m_hiddenWins.end();
+        for (TrayEmbedList::const_iterator emb = m_hiddenWins.begin(); emb != lastEmb; ++emb)
+        {
+            int width = (*emb)->width();
+            if (width > largest)
+            {
+                largest = width;
+            }
+        }
+    }
+
+    return largest;
+}
+
+int SystemTrayApplet::maxIconHeight() const
+{
+    int largest = m_iconSize;
+
+    TrayEmbedList::const_iterator lastEmb = m_shownWins.end();
+    for (TrayEmbedList::const_iterator emb = m_shownWins.begin(); emb != m_shownWins.end(); ++emb)
+    {
+        if (*emb == 0)
+        {
+            continue;
+        }
+
+        int height = (*emb)->height();
+        if (height > largest)
+        {
+            largest = height;
+        }
+    }
+
+    if (m_showHidden)
+    {
+        lastEmb = m_hiddenWins.end();
+        for (TrayEmbedList::const_iterator emb = m_hiddenWins.begin(); emb != m_hiddenWins.end(); ++emb)
+        {
+            if (*emb == 0)
+            {
+                continue;
+            }
+
+            int height = (*emb)->height();
+            if (height > largest)
+            {
+                largest = height;
+            }
+        }
+    }
+
+    return largest;
+}
+
+bool SystemTrayApplet::eventFilter(QObject* watched, QEvent* e)
+{
+    if (watched == m_expandButton)
+    {
+        QPoint p;
+        if (e->type() == QEvent::ContextMenu)
+        {
+            p = static_cast<QContextMenuEvent*>(e)->globalPos();
+        }
+        else if (e->type() == QEvent::MouseButtonPress)
+        {
+            QMouseEvent* me = static_cast<QMouseEvent*>(e);
+            if (me->button() == Qt::RightButton)
+            {
+                p = me->globalPos();
+            }
+        }
+
+        if (!p.isNull())
+        {
+            QPopupMenu* contextMenu = new QPopupMenu(this);
+            contextMenu->insertItem(SmallIcon("configure"), i18n("Configure System Tray..."),
+                                    this, SLOT(configure()));
+
+            contextMenu->exec(static_cast<QContextMenuEvent*>(e)->globalPos());
+
+            delete contextMenu;
+            return true;
+        }
+    }
+
+    return false;
+}
+
+int SystemTrayApplet::widthForHeight(int h) const
+{
+    if (orientation() == Qt::Vertical)
+    {
+        return width();
+    }
+
+    int currentHeight = height();
+    int minHeight = m_iconSize + 4;
+    if (currentHeight != h && currentHeight != minHeight)
+    {
+        SystemTrayApplet* me = const_cast<SystemTrayApplet*>(this);
+        me->setMinimumSize(0, 0);
+        me->setMaximumSize(32767, 32767);
+        me->setFixedHeight(h);
+    }
+
+    return sizeHint().width(); 
+}
+
+int SystemTrayApplet::heightForWidth(int w) const
+{
+    if (orientation() == Qt::Horizontal)
+    {
+        return height();
+    }
+
+    int currentWidth = width();
+    int minSize = m_iconSize + 4;
+    if (currentWidth != w && currentWidth != minSize)
+    {
+        SystemTrayApplet* me = const_cast<SystemTrayApplet*>(this);
+        me->setMinimumSize(0, 0);
+        me->setMaximumSize(32767, 32767);
+        me->setFixedWidth(w);
+    }
+
+    return sizeHint().height(); 
+}
+
+void SystemTrayApplet::moveEvent( QMoveEvent* )
+{
+    setBackground();
+}
+
+
+void SystemTrayApplet::resizeEvent( QResizeEvent* e )
+{
+    KPanelApplet::resizeEvent(e);
+    
+    layoutTray();
+    // we need to give ourselves a chance to adjust our size before calling this
+    QTimer::singleShot(0, this, SIGNAL(updateLayout()));
+}
+
+void SystemTrayApplet::layoutTray()
+{
+    setUpdatesEnabled(false);
+
+    int iconCount = m_shownWins.count();
+
+    if (m_showHidden)
+    {
+        iconCount += m_hiddenWins.count();
+    }
+
+    /* heightWidth = height or width in pixels (depends on orientation())
+     * nbrOfLines = number of rows or cols (depends on orientation())
+     * line = what line to draw an icon in */
+    int i = 0, line, nbrOfLines, heightWidth;
+    bool showExpandButton = m_expandButton && m_expandButton->isVisibleTo(this);
+    delete m_layout;
+    m_layout = new QGridLayout(this, 1, 1, 2, 2);
+
+    if (m_expandButton)
+    {
+        if (orientation() == Vertical)
+        {
+            m_expandButton->setFixedSize(width() - 4, m_expandButton->sizeHint().height());
+        }
+        else
+        {
+            m_expandButton->setFixedSize(m_expandButton->sizeHint().width(), height() - 4);
+        }
+    }
+
+    // col = column or row, depends on orientation(),
+    // the opposite direction of line
+    int col = 0;
+
+    // 
+    // The margin and spacing specified in the layout implies that:
+    // [-- 2 pixels --] [-- first icon --] [-- 2 pixels --] ... [-- 2 pixels --] [-- last icon --] [-- 2 pixels --]
+    //
+    // So, if we say that iconWidth is the icon width plus the 2 pixels spacing, then the available width for the icons
+    // is the widget width minus 2 pixels margin. Forgetting these 2 pixels broke the layout algorithm in KDE <= 3.5.9.
+    //
+    // This fix makes the workaround in the heightForWidth() and widthForHeight() methods unneeded.
+    //
+
+    if (orientation() == Vertical)
+    {
+        int iconWidth = maxIconWidth() + 2; // +2 for the margins that implied by the layout
+        heightWidth = width() - 2;
+        // to avoid nbrOfLines=0 we ensure heightWidth >= iconWidth!
+        heightWidth = heightWidth < iconWidth ? iconWidth : heightWidth;
+        nbrOfLines = heightWidth / iconWidth;
+        
+        if (showExpandButton)
+        {
+            m_layout->addMultiCellWidget(m_expandButton,
+                                         0, 0,
+                                         0, nbrOfLines - 1,
+                                         Qt::AlignHCenter | Qt::AlignVCenter);
+            col = 1;
+        }
+
+        if (m_showHidden)
+        {
+            TrayEmbedList::const_iterator lastEmb = m_hiddenWins.end();
+            for (TrayEmbedList::const_iterator emb = m_hiddenWins.begin();
+                 emb != lastEmb; ++emb)
+            {
+                line = i % nbrOfLines;
+                (*emb)->hide();
+                (*emb)->show();
+                m_layout->addWidget(*emb, col, line,
+                                    Qt::AlignHCenter | Qt::AlignVCenter);
+
+                if (line + 1 == nbrOfLines)
+                {
+                    ++col;
+                }
+
+                ++i;
+            }
+        }
+
+        TrayEmbedList::const_iterator lastEmb = m_shownWins.end();
+        for (TrayEmbedList::const_iterator emb = m_shownWins.begin();
+             emb != lastEmb; ++emb)
+        {
+            line = i % nbrOfLines;
+            (*emb)->hide();
+            (*emb)->show();
+            m_layout->addWidget(*emb, col, line,
+                                Qt::AlignHCenter | Qt::AlignVCenter);
+
+            if (line + 1 == nbrOfLines)
+            {
+                ++col;
+            }
+
+            ++i;
+        }
+    }
+    else // horizontal
+    {
+        int iconHeight = maxIconHeight() + 2; // +2 for the margins that implied by the layout
+        heightWidth = height() - 2;
+        heightWidth = heightWidth < iconHeight ? iconHeight : heightWidth; // to avoid nbrOfLines=0
+        nbrOfLines = heightWidth / iconHeight;
+
+        if (showExpandButton)
+        {
+            m_layout->addMultiCellWidget(m_expandButton,
+                                         0, nbrOfLines - 1,
+                                         0, 0,
+                                         Qt::AlignHCenter | Qt::AlignVCenter);
+            col = 1;
+        }
+
+        if (m_showHidden)
+        {
+            TrayEmbedList::const_iterator lastEmb = m_hiddenWins.end();
+            for (TrayEmbedList::const_iterator emb = m_hiddenWins.begin(); emb != lastEmb; ++emb)
+            {
+                line = i % nbrOfLines;
+                (*emb)->hide();
+                (*emb)->show();
+                m_layout->addWidget(*emb, line, col,
+                                    Qt::AlignHCenter | Qt::AlignVCenter);
+
+                if (line + 1 == nbrOfLines)
+                {
+                    ++col;
+                }
+
+                ++i;
+            }
+        }
+
+        TrayEmbedList::const_iterator lastEmb = m_shownWins.end();
+        for (TrayEmbedList::const_iterator emb = m_shownWins.begin();
+             emb != lastEmb; ++emb)
+        {
+            line = i % nbrOfLines;
+            (*emb)->hide();
+            (*emb)->show();
+            m_layout->addWidget(*emb, line, col,
+                                Qt::AlignHCenter | Qt::AlignVCenter);
+
+            if (line + 1 == nbrOfLines)
+            {
+                ++col;
+            }
+
+            ++i;
+        }
+    }
+
+    setUpdatesEnabled(true);
+    updateGeometry();
+    setBackground();
+}
+
+void SystemTrayApplet::paletteChange(const QPalette & /* oldPalette */)
+{
+    setBackground();
+}
+
+void SystemTrayApplet::setBackground()
+{
+    TrayEmbedList::const_iterator lastEmb;
+    
+    lastEmb = m_shownWins.end();
+    for (TrayEmbedList::const_iterator emb = m_shownWins.begin(); emb != lastEmb; ++emb)
+        (*emb)->setBackground();
+    
+    lastEmb = m_hiddenWins.end();
+    for (TrayEmbedList::const_iterator emb = m_hiddenWins.begin(); emb != lastEmb; ++emb)
+        (*emb)->setBackground();
+}
+
+
+TrayEmbed::TrayEmbed( bool kdeTray, QWidget* parent )
+    : QXEmbed( parent ), kde_tray( kdeTray )
+{
+    hide();
+    setBackground();
+}
+
+void TrayEmbed::setBackground()
+{
+    const QPixmap *pbg = parentWidget()->backgroundPixmap();
+    
+    if (pbg)
+    {
+        QPixmap bg(width(), height());
+        bg.fill(parentWidget(), pos());
+        setPaletteBackgroundPixmap(bg);
+        setBackgroundOrigin(WidgetOrigin);
+    }
+    else
+        unsetPalette();
+    
+    if (!isHidden())
+    {
+        hide(); 
+        show();
+    }
+    //XClearArea(x11Display(), embeddedWinId(), 0, 0, 0, 0, True);
+}
+
diff -Nurp kicker.orig/applets/trash/trashbutton.cpp kicker/applets/trash/trashbutton.cpp
--- kicker.orig/applets/trash/trashbutton.cpp	2005-10-10 15:04:00.000000000 +0000
+++ kicker/applets/trash/trashbutton.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -78,7 +78,7 @@ void TrashButton::setItemCount(int count
 
 void TrashButton::initPopup()
 {
-	QPopupMenu *old_popup = popup();
+	QPopupMenu *old_popup = static_cast<QPopupMenu*>(popup());
 
 	KFileItemList items;
 	items.append(&mFileItem);
diff -Nurp kicker.orig/configure.in.in kicker/configure.in.in
--- kicker.orig/configure.in.in	1970-01-01 00:00:00.000000000 +0000
+++ kicker/configure.in.in	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,78 @@
+dnl Check for pkg-config
+AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
+
+if test "$PKG_CONFIG" = "no"; then
+  AC_MSG_ERROR([
+This package requires pkg-config.
+])
+fi
+
+dnl Check for Glib-2.0
+# GLIB_CFLAGS:  cflags for compiling glib dependant sources
+# GLIB_LIBADD:  glib libraries (-l options)
+# GLIB_LDFLAGS: flags containing path to glib libraries (-L options)
+
+GLIB_PACKAGES="gmodule-2.0 gthread-2.0"
+GLIB_VERSION="1.3.3"
+AC_MSG_CHECKING(for GLib-2.0 (at least $GLIB_VERSION))
+
+if $PKG_CONFIG --atleast-pkgconfig-version 0.15 ; then
+   if $PKG_CONFIG --atleast-version $GLIB_VERSION $GLIB_PACKAGES >/dev/null 2>&1 ; then
+       GLIB_CFLAGS="`$PKG_CONFIG --cflags $GLIB_PACKAGES`"
+       GLIB_LIBADD="`$PKG_CONFIG --libs-only-l --libs-only-other $GLIB_PACKAGES`"
+       GLIB_LDFLAGS="`$PKG_CONFIG --libs-only-L $GLIB_PACKAGES`"
+       AC_MSG_RESULT(yes)
+   fi
+else
+   if $PKG_CONFIG --atleast-version $GLIB_VERSION $GLIB_PACKAGES >/dev/null 2>&1 ; then
+       GLIB_CFLAGS="`$PKG_CONFIG --cflags $GLIB_PACKAGES`"
+       GLIB_LIBADD="`$PKG_CONFIG --libs-only-l $GLIB_PACKAGES`"
+       GLIB_LDFLAGS="`$PKG_CONFIG --libs-only-L $GLIB_PACKAGES`"
+       AC_MSG_RESULT(yes)
+       AC_MSG_WARN([you may need to run make LDFLAGS=-pthread to compile arts])
+   fi
+fi
+
+if test -z "$GLIB_LIBADD"; then
+        AC_MSG_RESULT(not installed)
+    DO_NOT_COMPILE="$DO_NOT_COMPILE kerry gmcop"
+fi
+
+AC_SUBST(GLIB_CFLAGS)
+AC_SUBST(GLIB_LIBADD)
+AC_SUBST(GLIB_LDFLAGS)
+
+dnl Check for libbeagle 0.2.0
+# LIBBEAGLE_CFLAGS:  cflags for compiling libbeagle dependant sources
+# LIBBEAGLE_LIBADD:  libbeagle libraries (-l options)
+# LIBBEAGLE_LDFLAGS: flags containing path to libbeagle libraries (-L options)
+
+LIBBEAGLE_PACKAGES="libbeagle-0.0"
+LIBBEAGLE_VERSION="0.2.4"
+AC_MSG_CHECKING(for libbeagle-0.2.4 (at least $LIBBEAGLE_VERSION))
+
+if $PKG_CONFIG --atleast-pkgconfig-version 0.15 ; then
+   if $PKG_CONFIG --atleast-version $LIBBEAGLE_VERSION $LIBBEAGLE_PACKAGES >/dev/null 2>&1 ; then
+       LIBBEAGLE_CFLAGS="`$PKG_CONFIG --cflags $LIBBEAGLE_PACKAGES`"
+       LIBBEAGLE_LIBADD="`$PKG_CONFIG --libs-only-l --libs-only-other $LIBBEAGLE_PACKAGES`"
+       LIBBEAGLE_LDFLAGS="`$PKG_CONFIG --libs-only-L $LIBBEAGLE_PACKAGES`"
+       AC_MSG_RESULT(yes)
+   fi
+else
+   if $PKG_CONFIG --atleast-version $LIBBEAGLE_VERSION $LIBBEAGLE_PACKAGES >/dev/null 2>&1 ; then
+       LIBBEAGLE_CFLAGS="`$PKG_CONFIG --cflags $LIBBEAGLE_PACKAGES`"
+       LIBBEAGLE_LIBADD="`$PKG_CONFIG --libs-only-l $LIBBEAGLE_PACKAGES`"
+       LIBBEAGLE_LDFLAGS="`$PKG_CONFIG --libs-only-L $LIBBEAGLE_PACKAGES`"
+       AC_MSG_RESULT(yes)
+       AC_MSG_WARN([you may need to run make LDFLAGS=-pthread to compile arts])
+   fi
+fi
+
+if test -z "$LIBBEAGLE_LIBADD"; then
+        AC_MSG_RESULT(not installed)
+    DO_NOT_COMPILE="$DO_NOT_COMPILE kerry gmcop"
+fi
+
+AC_SUBST(LIBBEAGLE_CFLAGS)
+AC_SUBST(LIBBEAGLE_LIBADD)
+AC_SUBST(LIBBEAGLE_LDFLAGS)
diff -Nurp kicker.orig/data/kickoff/Makefile.am kicker/data/kickoff/Makefile.am
--- kicker.orig/data/kickoff/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ kicker/data/kickoff/Makefile.am	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,14 @@
+kicker_kmenuside_pics_data_DATA = resize_handle.png \
+	main_corner_tl.png main_corner_tr.png search-gradient.png \
+	menu_separator.png search-tab-center.png search-tab-left.png \
+	search-tab-right.png search-tab-top-center.png search-tab-top-left.png \
+	left_triangle.png right_triangle.png \
+       	kmenu_basic.mng kmenu_flipped.mng kmenu_vertical.mng \
+       	search-tab-top-right.png search-gradient-topdown.png search-running.mng
+
+kicker_kmenuside_pics_datadir = $(kde_datadir)/kicker/pics
+
+EXTRA_DIST = $(kicker_kmenuside_pics_data_DATA)
+
+kickerdir = $(kde_datadir)/kicker/icons
+kicker_ICON = leave recently_used suspend2disk suspend2ram
diff -Nurp kicker.orig/data/kmenu_side/Makefile.am kicker/data/kmenu_side/Makefile.am
--- kicker.orig/data/kmenu_side/Makefile.am	2005-09-10 08:25:35.000000000 +0000
+++ kicker/data/kmenu_side/Makefile.am	2008-09-17 15:14:41.000000000 +0000
@@ -1,6 +1,5 @@
-kicker_kmenuside_pics_data_DATA = kside.png kside_tile.png
-
-kicker_kmenuside_pics_datadir = $(kde_datadir)/kicker/pics/
+kicker_kmenuside_pics_data_DATA = kside.png kside_tile.png 
+kicker_kmenuside_pics_datadir = $(kde_datadir)/kicker/pics
 
 EXTRA_DIST = $(kicker_kmenuside_pics_data_DATA)
 
diff -Nurp kicker.orig/data/Makefile.am kicker/data/Makefile.am
--- kicker.orig/data/Makefile.am	2005-09-10 08:25:35.000000000 +0000
+++ kicker/data/Makefile.am	2008-09-17 15:14:41.000000000 +0000
@@ -1 +1 @@
-SUBDIRS = icons tiles app_start_anim wallpaper kmenu_side
+SUBDIRS = icons tiles app_start_anim wallpaper kmenu_side kickoff
diff -Nurp kicker.orig/extensions/kasbar/kasbar.cpp kicker/extensions/kasbar/kasbar.cpp
--- kicker.orig/extensions/kasbar/kasbar.cpp	2005-10-10 15:03:59.000000000 +0000
+++ kicker/extensions/kasbar/kasbar.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -719,7 +719,7 @@ void KasBar::addTestItems()
    i->setText( "Animated" );
    i->setIcon( KGlobal::iconLoader()->loadIcon( "icons", KIcon::NoGroup, KIcon::SizeMedium ) );
    i->setAnimation( resources()->startupAnimation() );
-   QTimer *aniTimer = new QTimer( i );
+   QTimer *aniTimer = new QTimer( i, "aniTimer" );
    connect( aniTimer, SIGNAL( timeout() ), i, SLOT( advanceAnimation() ) );
    aniTimer->start( 100 );
    i->setShowAnimation( true );
diff -Nurp kicker.orig/extensions/kasbar/kasclockitem.cpp kicker/extensions/kasbar/kasclockitem.cpp
--- kicker.orig/extensions/kasbar/kasclockitem.cpp	2005-09-10 08:25:29.000000000 +0000
+++ kicker/extensions/kasbar/kasclockitem.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -38,7 +38,7 @@ KasClockItem::KasClockItem( KasBar *pare
 {
     setCustomPopup( true );
 
-    QTimer *t = new QTimer( this );
+    QTimer *t = new QTimer( this, "t" );
     connect( t, SIGNAL( timeout() ), SLOT( updateTime() ) );
     t->start( 1000 );
 
diff -Nurp kicker.orig/extensions/kasbar/kasloaditem.cpp kicker/extensions/kasbar/kasloaditem.cpp
--- kicker.orig/extensions/kasbar/kasloaditem.cpp	2005-09-10 08:25:29.000000000 +0000
+++ kicker/extensions/kasbar/kasloaditem.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -33,7 +33,7 @@
 KasLoadItem::KasLoadItem( KasBar *parent )
     : KasItem( parent )
 {
-    QTimer *t = new QTimer( this );
+    QTimer *t = new QTimer( this, "KasLoadItem::t" );
     connect( t, SIGNAL( timeout() ), SLOT( updateDisplay() ) );
     t->start( 1000 );
     updateDisplay();
diff -Nurp kicker.orig/extensions/kasbar/kasstartupitem.cpp kicker/extensions/kasbar/kasstartupitem.cpp
--- kicker.orig/extensions/kasbar/kasstartupitem.cpp	2005-10-10 15:03:59.000000000 +0000
+++ kicker/extensions/kasbar/kasstartupitem.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -79,7 +79,7 @@ KasStartupItem::KasStartupItem( KasBar *
     setShowFrame( false );
     setAnimation( resources()->startupAnimation() );
 
-    aniTimer = new QTimer( this );
+    aniTimer = new QTimer( this, "aniTimer" );
     connect( aniTimer, SIGNAL( timeout() ), SLOT( aniTimerFired() ) );
     aniTimer->start( 100 );
 }
diff -Nurp kicker.orig/kicker/buttons/browserbutton.cpp kicker/kicker/buttons/browserbutton.cpp
--- kicker.orig/kicker/buttons/browserbutton.cpp	2005-09-10 08:25:31.000000000 +0000
+++ kicker/kicker/buttons/browserbutton.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -65,7 +65,7 @@ void BrowserButton::initialize( const QS
     topMenu = new PanelBrowserMenu( path );
     setPopup(topMenu);
 
-    _menuTimer = new QTimer( this );
+    _menuTimer = new QTimer( this, "_menuTimer" );
     connect( _menuTimer, SIGNAL(timeout()), SLOT(slotDelayedPopup()) );
 
     QToolTip::add(this, i18n("Browse: %1").arg(path));
diff -Nurp kicker.orig/kicker/buttons/kbutton.cpp kicker/kicker/buttons/kbutton.cpp
--- kicker.orig/kicker/buttons/kbutton.cpp	2005-09-10 08:25:31.000000000 +0000
+++ kicker/kicker/buttons/kbutton.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -33,6 +33,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE 
 
 #include "menumanager.h"
 #include "k_mnu.h"
+#include "k_mnu_stub.h"
 
 #include "kbutton.h"
 #include "kbutton.moc"
@@ -43,7 +44,7 @@ KButton::KButton( QWidget* parent )
     QToolTip::add(this, i18n("Applications, tasks and desktop sessions"));
     setTitle(i18n("K Menu"));
 
-    setPopup(MenuManager::the()->kmenu());
+    setPopup(MenuManager::the()->kmenu()->widget());
     MenuManager::the()->registerKButton(this);
     setIcon("kmenu");
 
diff -Nurp kicker.orig/kicker/buttons/knewbutton.cpp kicker/kicker/buttons/knewbutton.cpp
--- kicker.orig/kicker/buttons/knewbutton.cpp	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/buttons/knewbutton.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,455 @@
+/*****************************************************************
+
+Copyright (c) 2006 Stephan Binner <binner@kde.org>
+                   Stephan Kulow <coolo@kde.org>
+                   Dirk Mueller <mueller@kde.org>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#include <cassert>
+#include <cmath>
+
+#include <qtooltip.h>
+#include <qpainter.h>
+#include <qcursor.h>
+#include <private/qeffects_p.h>
+
+#include <klocale.h>
+#include <kapplication.h>
+#include <kstandarddirs.h>
+#include <kiconloader.h>
+#include <kdebug.h>
+
+#include "kickerSettings.h"
+
+#include "config.h"
+#include "global.h"
+
+#include "menumanager.h"
+#include "k_mnu_stub.h"
+#include "k_new_mnu.h"
+
+#include "knewbutton.h"
+#include "knewbutton.moc"
+
+KNewButton *KNewButton::m_self = 0;
+
+KNewButton::KNewButton( QWidget* parent )
+    : KButton( parent ),
+      m_oldPos(0,0)
+{
+    Q_ASSERT( !m_self );
+    m_self = this;
+    m_hoverTimer = -1;
+    m_openTimer = -1;
+    m_active = false;
+    m_mouseInside = false;
+    m_drag = false;
+
+    setIconAlignment((Qt::AlignmentFlags)(AlignTop|AlignRight));
+    setAcceptDrops(true);
+    setIcon("kmenu-suse");
+    setDrawArrow(false);
+
+    m_movie = new QMovie(locate("data", "kicker/pics/kmenu_basic.mng"));
+    m_movie->connectUpdate(this, SLOT(updateMovie()));
+    m_movie->connectStatus(this, SLOT(slotStatus(int)));
+    m_movie->connectResize(this, SLOT(slotSetSize(const QSize&)));
+
+    QApplication::desktop()->screen()->installEventFilter(this);
+    setMouseTracking(true);
+}
+
+KNewButton::~KNewButton()
+{
+    if ( m_self == this )
+        m_self = 0;
+    setMouseTracking(false);
+    delete m_movie;
+}
+
+void KNewButton::slotStatus(int status)
+{
+    if(status == QMovie::EndOfLoop)
+        slotStopAnimation();
+}
+
+QColor KNewButton::borderColor() const
+{
+    QImage img = m_active_pixmap.convertToImage();
+
+    for (int i = 0; i < img.width(); ++i) {
+        QRgb rgb = img.pixel(orientation() == Qt::Horizontal ? img.width() - i - 1 :
+                    i, 2);
+
+        if (qGreen(rgb) > 0x50)
+            return rgb;
+    }
+
+    return img.pixel( orientation() == Qt::Horizontal ? img.width() - 2 : 2, 2);
+}
+
+void KNewButton::show()
+{
+     KButton::show();
+
+     if (KickerSettings::firstRun()) {
+         QTimer::singleShot(500,this,SLOT(slotExecMenu()));
+         KickerSettings::setFirstRun(false);
+         KickerSettings::writeConfig();
+     }
+}
+
+void KNewButton::updateMovie()
+{
+    m_oldPos = QPoint( -1, -1 );
+    drawEye();
+
+    if (!m_active && m_movie->running())
+        m_movie->pause();
+}
+
+void KNewButton::setPopupDirection(KPanelApplet::Direction d)
+{
+    KButton::setPopupDirection(d);
+
+    delete m_movie;
+
+    switch (d) {
+    case KPanelApplet::Left:
+        setIconAlignment((Qt::AlignmentFlags)(AlignTop|AlignLeft));
+        m_movie = new QMovie(locate("data", "kicker/pics/kmenu_vertical.mng"));
+        break;
+    case KPanelApplet::Right:
+        setIconAlignment((Qt::AlignmentFlags)(AlignTop|AlignRight));
+        m_movie = new QMovie(locate("data", "kicker/pics/kmenu_vertical.mng"));
+        break;
+    case KPanelApplet::Up:
+        setIconAlignment((Qt::AlignmentFlags)(AlignTop|AlignHCenter));
+        m_movie = new QMovie(locate("data", "kicker/pics/kmenu_basic.mng"));
+        break;
+    case KPanelApplet::Down:
+        setIconAlignment((Qt::AlignmentFlags)(AlignBottom|AlignHCenter));
+        m_movie = new QMovie(locate("data", "kicker/pics/kmenu_flipped.mng"));
+    }
+
+    m_movie->connectUpdate(this, SLOT(updateMovie()));
+    m_movie->connectStatus(this, SLOT(slotStatus(int)));
+    m_movie->connectResize(this, SLOT(slotSetSize(const QSize&)));
+}
+
+void KNewButton::slotSetSize(const QSize& s)
+{
+    m_iconSize = s;
+}
+
+double KNewButton::buttonScaleFactor(const QSize& s) const
+{
+    double sf = 1.0;
+
+    switch (popupDirection()) {
+        case KPanelApplet::Left:
+        case KPanelApplet::Right:
+//            sf = kMin(double(s.width()) / m_iconSize.height(), double(s.height()) / m_iconSize.width());
+//            break;
+        case KPanelApplet::Up:
+        case KPanelApplet::Down:
+            sf = kMin(double(s.width()) / m_iconSize.width(), double(s.height()) / m_iconSize.height());
+            break;
+    }
+
+    if (sf > 0.8) sf = 1.0;
+    return sf;
+}
+
+int KNewButton::widthForHeight(int height) const
+{
+    int r = m_iconSize.width() * buttonScaleFactor(QSize(m_iconSize.width(), height));
+
+    if (!m_movie->running() && height != m_active_pixmap.height())
+    {
+        KNewButton* that = const_cast<KNewButton*>(this);
+        QTimer::singleShot(0, that, SLOT(slotStopAnimation()));
+    }
+ 
+    return r;
+}
+
+int KNewButton::preferredDimension(int panelDim) const
+{
+    return kMax(m_icon.width(), m_icon.height());
+}
+
+int KNewButton::heightForWidth(int width) const
+{
+    int r = m_iconSize.width() * buttonScaleFactor(QSize(width, m_iconSize.height()));
+    if (!m_movie->running() && width != m_active_pixmap.width())
+    {
+        KNewButton* that = const_cast<KNewButton*>(this);
+        QTimer::singleShot(0, that, SLOT(slotStopAnimation()));
+    }
+    return r;
+}
+
+bool KNewButton::eventFilter(QObject *o, QEvent *e)
+{
+    if (e->type() == QEvent::MouseButtonRelease ||
+        e->type() == QEvent::MouseButtonPress   ||
+        e->type() == QEvent::MouseButtonDblClick )
+    {
+        QMouseEvent *me = static_cast<QMouseEvent *>(e);
+        if (rect().contains(mapFromGlobal(me->globalPos())))
+        {
+            if (m_pressedDuringPopup && m_popup && m_openTimer != -1
+                    && (me->button() & Qt::LeftButton) )
+                return true;
+        }
+    }
+
+    if (KickerSettings::kickoffDrawGeekoEye() && e->type() == QEvent::MouseMove)
+    {
+        QMouseEvent *me = static_cast<QMouseEvent *>(e);
+        if ((me->state() & MouseButtonMask) == NoButton) 
+            drawEye();
+    }
+
+    return KButton::eventFilter(o, e);
+}
+
+void KNewButton::drawEye()
+{
+#define eye_x 62
+#define eye_y 13
+    QPoint mouse = QCursor::pos();
+    QPoint me = mapToGlobal(QPoint(eye_x, eye_y));
+    double a = atan2(mouse.y() - me.y(), mouse.x() - me.x());
+    int dx = int(2.1 * cos(a));
+    int dy = int(2.1 * sin(a));
+
+    QPoint newpos(eye_x+dx,eye_y+dy);
+    if (newpos!=m_oldPos) {
+        m_oldPos = newpos;
+        QPixmap pixmap = m_active_pixmap;
+
+        double sf = 1.0;
+
+        if(!m_movie->framePixmap().isNull())
+        {
+            pixmap = m_movie->framePixmap();
+            pixmap.detach();
+            m_iconSize = pixmap.size();
+            sf = buttonScaleFactor(size());
+
+            if (KickerSettings::kickoffDrawGeekoEye()) {
+               QPainter p(&pixmap);
+               p.setPen(white);
+               p.setBrush(white);
+               //      p.setPen(QColor(110,185,55));
+               p.drawRect(eye_x+dx, eye_y+dy, 2, 2);
+               p. end();
+            }
+        }
+
+        QWMatrix matrix;
+        switch (popupDirection()) {
+        case KPanelApplet::Left:
+            matrix.scale(sf, -sf);
+            matrix.rotate(90);
+            break;
+        case KPanelApplet::Up:
+            matrix.scale(sf, sf);
+            break;
+        case KPanelApplet::Right:
+            matrix.scale(sf, -sf);
+            matrix.rotate(90);
+            break;
+        case KPanelApplet::Down:
+            matrix.scale(sf, sf);
+            break;
+        }
+        m_active_pixmap = pixmap.xForm(matrix);
+
+        repaint(false);
+    }
+#undef eye_x
+#undef eye_y
+}
+
+void KNewButton::enterEvent(QEvent* e)
+{
+    KButton::enterEvent(e);
+
+    QSize s(size());
+    s *= 0.25;
+    s = s.expandedTo(QSize(6,6));
+
+    switch (popupDirection()) {
+    case KPanelApplet::Left:
+        m_sloppyRegion = QRect(rect().topRight() - QPoint(s.width()-1, 0), s);
+        break;
+    case KPanelApplet::Right:
+        m_sloppyRegion = QRect(rect().topLeft(), s);
+        break;
+    case KPanelApplet::Up:
+        m_sloppyRegion = QRect(rect().bottomLeft() - QPoint(0, s.height()-1), s);
+        break;
+    case KPanelApplet::Down:
+        m_sloppyRegion = QRect(rect().topLeft(), s);
+    }
+
+    m_active = true;
+    m_movie->unpause();
+    m_movie->restart();
+}
+
+void KNewButton::rewindMovie()
+{
+    m_oldPos = QPoint( -1, -1 );
+    m_movie->unpause();
+}
+
+void KNewButton::dragEnterEvent(QDragEnterEvent* /*e*/)
+{
+    if (m_hoverTimer != -1)
+        killTimer(m_hoverTimer);
+
+    m_hoverTimer = startTimer(QApplication::startDragTime());
+    m_mouseInside = true;
+    m_drag = true;
+}
+
+void KNewButton::dragLeaveEvent(QDragLeaveEvent* /*e*/)
+{
+    m_mouseInside = false;
+    m_drag = false;
+}
+
+void KNewButton::leaveEvent(QEvent* e)
+{
+    m_mouseInside = false;
+    if (m_hoverTimer != -1)
+        killTimer(m_hoverTimer);
+    m_hoverTimer = -1;
+
+    KButton::leaveEvent(e);
+}
+
+void KNewButton::mouseMoveEvent(QMouseEvent* e)
+{
+    KButton::mouseMoveEvent(e);
+
+    m_mouseInside = m_sloppyRegion.contains(e->pos());
+
+    if ( m_sloppyRegion.contains(e->pos())) 
+    {
+        if (m_hoverTimer == -1 && KickerSettings::openOnHover())
+            m_hoverTimer = startTimer(kMax(200,QApplication::doubleClickInterval()/2));
+    }
+    else if (m_hoverTimer != -1) 
+    {
+        killTimer(m_hoverTimer);
+        m_hoverTimer = -1;
+    }
+}
+
+void KNewButton::slotStopAnimation()
+{
+    m_active = false;
+    m_movie->pause();
+    m_movie->restart();
+    QTimer::singleShot(200, this, SLOT(rewindMovie()));
+}
+
+const QPixmap& KNewButton::labelIcon() const
+{
+    return m_active_pixmap;
+}
+
+void KNewButton::slotExecMenu()
+{
+    if (m_openTimer != -1)
+        killTimer(m_openTimer);
+
+    m_openTimer = startTimer(QApplication::doubleClickInterval() * 3);
+
+    if (m_active)
+    {
+        m_active = false;
+        m_movie->pause();
+        m_movie->restart();
+    }
+
+    KButton::slotExecMenu();
+
+    assert(!KickerTip::tippingEnabled());
+    assert(dynamic_cast<KMenu*>(m_popup));
+
+    disconnect(dynamic_cast<KMenu*>(m_popup), SIGNAL(aboutToHide()), this,
+            SLOT(slotStopAnimation()));
+    connect(dynamic_cast<KMenu*>(m_popup), SIGNAL(aboutToHide()),
+            SLOT(slotStopAnimation()));
+
+    m_popup->move(KickerLib::popupPosition(popupDirection(), m_popup, this));
+    // I wish KMenu would properly done itself when it closes. But it doesn't.
+
+    bool useEffect = true; // could be QApplication::isEffectEnabled()
+    useEffect = false; // too many Qt bugs to be useful
+    if (m_drag)
+	useEffect = false;
+
+    m_drag = false; // once is enough
+
+    if (useEffect) 
+    {
+        switch (popupDirection()) {
+        case KPanelApplet::Left:
+            qScrollEffect(m_popup, QEffects::LeftScroll);
+            break;
+        case KPanelApplet::Up:
+            qScrollEffect(m_popup, QEffects::UpScroll);
+            break;
+        case KPanelApplet::Right:
+            qScrollEffect(m_popup, QEffects::RightScroll);
+            break;
+        case KPanelApplet::Down:
+            qScrollEffect(m_popup, QEffects::DownScroll);
+            break;
+        }
+    }
+    else
+        static_cast<KMenu*>(m_popup)->show();
+}
+
+void KNewButton::timerEvent(QTimerEvent* e)
+{
+    if (e->timerId() == m_hoverTimer)
+    {
+        if (m_mouseInside && !isDown())
+            showMenu();
+
+        killTimer(m_hoverTimer);
+        m_hoverTimer = -1;
+    }
+    if (e->timerId() == m_openTimer)
+    {
+        killTimer(m_openTimer);
+        m_openTimer = -1;
+    }
+}
diff -Nurp kicker.orig/kicker/buttons/knewbutton.h kicker/kicker/buttons/knewbutton.h
--- kicker.orig/kicker/buttons/knewbutton.h	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/buttons/knewbutton.h	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,98 @@
+/*****************************************************************
+
+Copyright (c) 2006 Stephan Binner <binner@kde.org>
+                   Stephan Kulow <coolo@kde.org>
+                   Dirk Mueller <mueller@kde.org>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#ifndef __knewbutton_h__
+#define __knewbutton_h__
+
+#include "kbutton.h"
+
+#include <qmovie.h>
+#include <qpoint.h>
+
+/**
+ * Button that contains the PanelKMenu and client menu manager.
+ */
+class KNewButton : public KButton
+{
+    Q_OBJECT
+
+public:
+    KNewButton( QWidget *parent );
+    ~KNewButton();
+
+    static KNewButton *self() { return m_self; }
+
+    void loadConfig( const KConfigGroup& config );
+
+    virtual const QPixmap& labelIcon() const;
+
+    virtual int widthForHeight(int height) const;
+    virtual int preferredDimension(int panelDim) const;
+    virtual int heightForWidth(int width) const;
+
+    QColor borderColor() const;
+
+    virtual void setPopupDirection(KPanelApplet::Direction d);
+
+private slots:
+    void slotStatus(int);
+    void slotSetSize(const QSize&);
+    void slotStopAnimation();
+    void rewindMovie();
+    void updateMovie();
+
+protected:
+    virtual void show();
+    virtual void slotExecMenu();
+    virtual QString tileName() { return "KMenu"; }
+    virtual QString defaultIcon() const { return "go"; }
+
+    virtual void enterEvent(QEvent* e);
+    virtual void leaveEvent(QEvent* e);
+    virtual void mouseMoveEvent(QMouseEvent* e);
+    virtual void dragEnterEvent(QDragEnterEvent*);
+    virtual void dragLeaveEvent(QDragLeaveEvent*);
+    virtual bool eventFilter(QObject *, QEvent *);
+    void timerEvent(QTimerEvent*);
+
+private:
+    void drawEye();
+    double buttonScaleFactor(const QSize& s) const;
+
+    QMovie* m_movie;
+    QPixmap m_active_pixmap;
+    QPoint m_oldPos;
+    QSize m_iconSize;
+    QRect m_sloppyRegion;
+    int m_hoverTimer;
+    int m_openTimer;
+    bool m_active;
+    bool m_mouseInside;
+    bool m_drag;
+
+    static KNewButton *m_self;
+};
+
+#endif
diff -Nurp kicker.orig/kicker/buttons/Makefile.am kicker/kicker/buttons/Makefile.am
--- kicker.orig/kicker/buttons/Makefile.am	2005-09-10 08:25:31.000000000 +0000
+++ kicker/kicker/buttons/Makefile.am	2008-09-17 15:14:41.000000000 +0000
@@ -1,10 +1,10 @@
 INCLUDES = -I$(srcdir)/../core -I$(srcdir)/../../libkicker -I../../libkicker \
-	-I$(srcdir)/../ui -I$(top_srcdir)/libkonq $(all_includes)
+	-I../ui -I$(srcdir)/../ui -I$(top_srcdir)/libkonq $(all_includes) $(LIBBEAGLE_CFLAGS) $(GLIB_CFLAGS)
 
 noinst_LTLIBRARIES = libkicker_buttons.la
 
 libkicker_buttons_la_SOURCES = servicebutton.cpp bookmarksbutton.cpp \
-	browserbutton.cpp \
+	browserbutton.cpp knewbutton.cpp \
 	desktopbutton.cpp extensionbutton.cpp kbutton.cpp \
 	nonkdeappbutton.cpp servicemenubutton.cpp urlbutton.cpp \
 	windowlistbutton.cpp
diff -Nurp kicker.orig/kicker/core/applethandle.cpp kicker/kicker/core/applethandle.cpp
--- kicker.orig/kicker/core/applethandle.cpp	2008-08-19 18:16:56.000000000 +0000
+++ kicker/kicker/core/applethandle.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -150,7 +150,7 @@ void AppletHandle::setFadeOutHandle(bool
     {
         if (!m_handleHoverTimer)
         {
-            m_handleHoverTimer = new QTimer(this);
+            m_handleHoverTimer = new QTimer(this, "m_handleHoverTimer");
             connect(m_handleHoverTimer, SIGNAL(timeout()),
                     this, SLOT(checkHandleHover()));
             m_applet->installEventFilter(this);
@@ -177,11 +177,7 @@ bool AppletHandle::eventFilter(QObject *
                 m_drawHandle = true;
                 resetLayout();
 
-                if (m_handleHoverTimer)
-                {
-                    m_handleHoverTimer->start(250);
-                }
-                break;
+               break;
             }
 
             case QEvent::Leave:
@@ -191,6 +187,11 @@ bool AppletHandle::eventFilter(QObject *
                     break;
                 }
 
+                if (m_handleHoverTimer)
+                {
+                    m_handleHoverTimer->start(250);
+                }
+
                 QWidget* w = dynamic_cast<QWidget*>(o);
 
                 bool nowDrawIt = false;
@@ -207,11 +208,6 @@ bool AppletHandle::eventFilter(QObject *
 
                 if (nowDrawIt != m_drawHandle)
                 {
-                    if (m_handleHoverTimer)
-                    {
-                        m_handleHoverTimer->stop();
-                    }
-
                     m_drawHandle = nowDrawIt;
                     resetLayout();
                 }
@@ -297,6 +293,11 @@ void AppletHandle::toggleMenuButtonOff()
     }
 
     m_menuButton->setDown(false);
+
+    if (m_handleHoverTimer)
+    {
+        m_handleHoverTimer->start(250);
+    }
 }
 
 AppletHandleDrag::AppletHandleDrag(AppletHandle* parent)
diff -Nurp kicker.orig/kicker/core/applethandle.cpp.orig kicker/kicker/core/applethandle.cpp.orig
--- kicker.orig/kicker/core/applethandle.cpp.orig	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/core/applethandle.cpp.orig	2008-08-19 18:16:56.000000000 +0000
@@ -0,0 +1,402 @@
+/*****************************************************************
+
+Copyright (c) 1996-2000 the kicker authors. See file AUTHORS.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#include <qcursor.h>
+#include <qlayout.h>
+#include <qpainter.h>
+#include <qstyle.h>
+#include <qpixmapcache.h>
+#include <qtimer.h>
+#include <qtooltip.h>
+#include <qimage.h>
+
+#include <kpushbutton.h>
+#include <kapplication.h>
+#include <kdebug.h>
+#include <kglobal.h>
+#include <klocale.h>
+
+#include "global.h"
+#include "container_applet.h"
+#include "kickerSettings.h"
+
+#include "applethandle.h"
+
+AppletHandle::AppletHandle(AppletContainer* parent)
+    : QWidget(parent),
+      m_applet(parent),
+      m_menuButton(0),
+      m_drawHandle(false),
+      m_popupDirection(KPanelApplet::Up),
+      m_handleHoverTimer(0)
+{
+    setBackgroundOrigin(AncestorOrigin);
+    setMinimumSize(widthForHeight(0), heightForWidth(0));
+    m_layout = new QBoxLayout(this, QBoxLayout::BottomToTop, 0, 0);
+
+    m_dragBar = new AppletHandleDrag(this);
+    m_dragBar->installEventFilter(this);
+    m_layout->addWidget(m_dragBar);
+
+    if (kapp->authorizeKAction("kicker_rmb"))
+    {
+        m_menuButton = new AppletHandleButton( this );
+        m_menuButton->installEventFilter(this);
+        m_layout->addWidget(m_menuButton);
+
+        connect(m_menuButton, SIGNAL(pressed()),
+                this, SLOT(menuButtonPressed()));
+        QToolTip::add(m_menuButton, i18n("%1 menu").arg(parent->info().name()));
+    }
+
+    QToolTip::add(this, i18n("%1 applet handle").arg(parent->info().name()));
+    resetLayout();
+}
+
+int AppletHandle::heightForWidth( int /* w */ ) const
+{
+    int size = style().pixelMetric(QStyle::PM_DockWindowHandleExtent, this);
+
+    return size;
+}
+
+int AppletHandle::widthForHeight( int /* h */ ) const
+{
+    int size = style().pixelMetric(QStyle::PM_DockWindowHandleExtent, this);
+
+    return size;
+}
+
+void AppletHandle::setPopupDirection(KPanelApplet::Direction d)
+{
+    Qt::ArrowType a = Qt::UpArrow;
+
+    if (d == m_popupDirection || !m_menuButton)
+    {
+        return;
+    }
+
+    m_popupDirection = d;
+
+    switch (m_popupDirection)
+    {
+        case KPanelApplet::Up:
+            m_layout->setDirection(QBoxLayout::BottomToTop);
+            a = Qt::UpArrow;
+            break;
+        case KPanelApplet::Down:
+            m_layout->setDirection(QBoxLayout::TopToBottom);
+            a = Qt::DownArrow;
+            break;
+        case KPanelApplet::Left:
+            m_layout->setDirection(QBoxLayout::RightToLeft);
+            a = Qt::LeftArrow;
+            break;
+        case KPanelApplet::Right:
+            m_layout->setDirection(QBoxLayout::LeftToRight);
+            a = Qt::RightArrow;
+            break;
+    }
+
+    m_menuButton->setArrowType(a);
+    m_layout->activate();
+}
+
+void AppletHandle::resetLayout()
+{
+    if (m_handleHoverTimer && !m_drawHandle)
+    {
+        m_dragBar->hide();
+
+        if (m_menuButton)
+        {
+            m_menuButton->hide();
+        }
+    }
+    else
+    {
+        m_dragBar->show();
+
+        if (m_menuButton)
+        {
+            m_menuButton->show();
+        }
+    }
+}
+
+void AppletHandle::setFadeOutHandle(bool fadeOut)
+{
+    if (fadeOut)
+    {
+        if (!m_handleHoverTimer)
+        {
+            m_handleHoverTimer = new QTimer(this);
+            connect(m_handleHoverTimer, SIGNAL(timeout()),
+                    this, SLOT(checkHandleHover()));
+            m_applet->installEventFilter(this);
+        }
+    }
+    else
+    {
+        delete m_handleHoverTimer;
+        m_handleHoverTimer = 0;
+        m_applet->removeEventFilter(this);
+    }
+
+    resetLayout();
+}
+
+bool AppletHandle::eventFilter(QObject *o, QEvent *e)
+{
+    if (o == parent())
+    {
+        switch (e->type())
+        {
+            case QEvent::Enter:
+            {
+                m_drawHandle = true;
+                resetLayout();
+
+                if (m_handleHoverTimer)
+                {
+                    m_handleHoverTimer->start(250);
+                }
+                break;
+            }
+
+            case QEvent::Leave:
+            {
+                if (m_menuButton && m_menuButton->isOn())
+                {
+                    break;
+                }
+
+                QWidget* w = dynamic_cast<QWidget*>(o);
+
+                bool nowDrawIt = false;
+                if (w)
+                {
+                    // a hack for applets that have out-of-process
+                    // elements (e.g the systray) so that the handle
+                    // doesn't flicker when moving over those elements
+                    if (w->rect().contains(w->mapFromGlobal(QCursor::pos())))
+                    {
+                        nowDrawIt = true;
+                    }
+                }
+
+                if (nowDrawIt != m_drawHandle)
+                {
+                    if (m_handleHoverTimer)
+                    {
+                        m_handleHoverTimer->stop();
+                    }
+
+                    m_drawHandle = nowDrawIt;
+                    resetLayout();
+                }
+                break;
+            }
+
+            default:
+                break;
+        }
+
+        return QWidget::eventFilter( o, e );
+    }
+    else if (o == m_dragBar)
+    {
+        if (e->type() == QEvent::MouseButtonPress)
+        {
+            QMouseEvent* ev = static_cast<QMouseEvent*>(e);
+            if (ev->button() == LeftButton || ev->button() == MidButton)
+            {
+                emit moveApplet(m_applet->mapFromGlobal(ev->globalPos()));
+            }
+        }
+    }
+
+    if (m_menuButton && e->type() == QEvent::MouseButtonPress)
+    {
+        QMouseEvent* ev = static_cast<QMouseEvent*>(e);
+        if (ev->button() == RightButton)
+        {
+            if (!m_menuButton->isDown())
+            {
+                m_menuButton->setDown(true);
+                menuButtonPressed();
+            }
+
+            return true;
+        }
+    }
+
+    return QWidget::eventFilter(o, e);    // standard event processing
+}
+
+void AppletHandle::menuButtonPressed()
+{
+    if (!kapp->authorizeKAction("kicker_rmb"))
+    {
+        return;
+    }
+
+    emit showAppletMenu();
+
+    if (!onMenuButton(QCursor::pos()))
+    {
+        toggleMenuButtonOff();
+    }
+}
+
+void AppletHandle::checkHandleHover()
+{
+    if (!m_handleHoverTimer ||
+        (m_menuButton && m_menuButton->isOn()) ||
+        m_applet->geometry().contains(m_applet->mapToParent(
+                                      m_applet->mapFromGlobal(QCursor::pos()))))
+    {
+        return;
+    }
+
+    m_handleHoverTimer->stop();
+    m_drawHandle = false;
+    resetLayout();
+}
+
+bool AppletHandle::onMenuButton(const QPoint& point) const
+{
+    return m_menuButton && (childAt(mapFromGlobal(point)) == m_menuButton);
+}
+
+void AppletHandle::toggleMenuButtonOff()
+{
+    if (!m_menuButton)
+    {
+        return;
+    }
+
+    m_menuButton->setDown(false);
+}
+
+AppletHandleDrag::AppletHandleDrag(AppletHandle* parent)
+    : QWidget(parent),
+      m_parent(parent),
+      m_inside(false)
+{
+   setBackgroundOrigin( AncestorOrigin );
+}
+
+QSize AppletHandleDrag::minimumSizeHint() const
+{
+    int wh = style().pixelMetric(QStyle::PM_DockWindowHandleExtent, this);
+
+    if (m_parent->orientation() == Horizontal)
+    {
+        return QSize(wh, 0);
+    }
+
+    return QSize(0, wh);
+}
+
+QSizePolicy AppletHandleDrag::sizePolicy() const
+{
+    if (m_parent->orientation() == Horizontal)
+    {
+        return QSizePolicy( QSizePolicy::Fixed, QSizePolicy::Preferred );
+    }
+
+    return QSizePolicy( QSizePolicy::Preferred, QSizePolicy::Fixed );
+}
+
+void AppletHandleDrag::enterEvent( QEvent *e )
+{
+    m_inside = true;
+    QWidget::enterEvent( e );
+    update();
+}
+
+void AppletHandleDrag::leaveEvent( QEvent *e )
+{
+    m_inside = false;
+    QWidget::enterEvent( e );
+    update();
+}
+
+void AppletHandleDrag::paintEvent(QPaintEvent *)
+{
+    QPainter p(this);
+    
+    if (!KickerSettings::transparent())
+    {
+        if (paletteBackgroundPixmap())
+        {
+            QPoint offset = backgroundOffset();
+            int ox = offset.x();
+            int oy = offset.y();
+            p.drawTiledPixmap( 0, 0, width(), height(),*paletteBackgroundPixmap(), ox, oy);
+        }
+        
+        QStyle::SFlags flags = QStyle::Style_Default;
+        flags |= QStyle::Style_Enabled;
+        if (m_parent->orientation() == Horizontal)
+        {
+            flags |= QStyle::Style_Horizontal;
+        }
+    
+        QRect r = rect();
+    
+        style().drawPrimitive(QStyle::PE_DockWindowHandle, &p, r,
+                            colorGroup(), flags);
+    }
+    else
+    {
+        KickerLib::drawBlendedRect(&p, QRect(0, 0, width(), height()), paletteForegroundColor(), m_inside ? 0x40 : 0x20);
+    }
+}
+
+AppletHandleButton::AppletHandleButton(AppletHandle *parent)
+  : SimpleArrowButton(parent),
+    m_parent(parent)
+{
+}
+
+QSize AppletHandleButton::minimumSizeHint() const
+{
+    int height = style().pixelMetric(QStyle::PM_DockWindowHandleExtent, this);
+    int width = height;
+
+    if (m_parent->orientation() == Horizontal)
+    {
+        return QSize(width, height);
+    }
+
+    return QSize(height, width);
+}
+
+QSizePolicy AppletHandleButton::sizePolicy() const
+{
+    return QSizePolicy( QSizePolicy::Fixed, QSizePolicy::Fixed );
+}
+
+#include "applethandle.moc"
diff -Nurp kicker.orig/kicker/core/containerarea.cpp kicker/kicker/core/containerarea.cpp
--- kicker.orig/kicker/core/containerarea.cpp	2008-08-19 18:16:56.000000000 +0000
+++ kicker/kicker/core/containerarea.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -87,7 +87,8 @@ ContainerArea::ContainerArea(KConfig* _c
       m_immutable(_c->isImmutable()),
       m_updateBackgroundsCalled(false),
       m_layout(0),
-      m_addAppletDialog(0)
+      m_addAppletDialog(0),
+      _autoScrollTimer(0, "ContainerArea::autoScrollTimer")
 {
     setBackgroundOrigin( WidgetOrigin );
     viewport()->setBackgroundOrigin( AncestorOrigin );
diff -Nurp kicker.orig/kicker/core/container_button.cpp kicker/kicker/core/container_button.cpp
--- kicker.orig/kicker/core/container_button.cpp	2008-08-19 18:16:56.000000000 +0000
+++ kicker/kicker/core/container_button.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -43,6 +43,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE 
 #include "desktopbutton.h"
 #include "extensionbutton.h"
 #include "kbutton.h"
+#include "knewbutton.h"
 #include "kicker.h"
 #include "kickerSettings.h"
 #include "kickertip.h"
@@ -326,14 +327,20 @@ KMenuButtonContainer::KMenuButtonContain
   : ButtonContainer(opMenu, parent)
 {
     checkImmutability(config);
-    embedButton( new KButton(this) );
+    if(KickerSettings::legacyKMenu())
+	embedButton( new KButton(this) );
+    else
+	embedButton( new KNewButton(this) );
     _actions = PanelAppletOpMenu::KMenuEditor;
 }
 
 KMenuButtonContainer::KMenuButtonContainer(QPopupMenu *opMenu, QWidget* parent)
   : ButtonContainer(opMenu, parent)
 {
-    embedButton( new KButton(this) );
+    if(KickerSettings::legacyKMenu())
+	embedButton( new KButton(this) );
+    else
+	embedButton( new KNewButton(this) );
     _actions = PanelAppletOpMenu::KMenuEditor;
 }
 
diff -Nurp kicker.orig/kicker/core/container_button.cpp.orig kicker/kicker/core/container_button.cpp.orig
--- kicker.orig/kicker/core/container_button.cpp.orig	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/core/container_button.cpp.orig	2008-08-19 18:16:56.000000000 +0000
@@ -0,0 +1,542 @@
+/*****************************************************************
+
+Copyright (c) 1996-2003 the kicker authors. See file AUTHORS.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#include <algorithm>
+
+#include <qlayout.h>
+
+#include <kapplication.h>
+#include <kconfig.h>
+#include <kdebug.h>
+#include <kglobal.h>
+#include <kmultipledrag.h>
+#include <kpanelapplet.h>
+#include <kurldrag.h>
+
+#include "global.h"
+#include "appletop_mnu.h"
+
+#include "containerarea.h"
+#include "panelbutton.h"
+#include "bookmarksbutton.h"
+#include "browserbutton.h"
+#include "desktopbutton.h"
+#include "extensionbutton.h"
+#include "kbutton.h"
+#include "kicker.h"
+#include "kickerSettings.h"
+#include "kickertip.h"
+#include "nonkdeappbutton.h"
+#include "paneldrag.h"
+#include "servicebutton.h"
+#include "servicemenubutton.h"
+#include "urlbutton.h"
+#include "windowlistbutton.h"
+
+#include "container_button.h"
+#include "container_button.moc"
+
+ButtonContainer::ButtonContainer(QPopupMenu* opMenu, QWidget* parent)
+  : BaseContainer(opMenu, parent)
+  , _button(0)
+  , _layout(0)
+  , _oldpos(0,0)
+{
+     setBackgroundOrigin(AncestorOrigin);
+}
+
+bool ButtonContainer::isValid() const
+{
+   if (_button)
+   {
+       return _button->isValid();
+   }
+
+   return false; // Can this happen?
+}
+
+// Buttons Shouldn't be square when larger than a certain size.
+int ButtonContainer::widthForHeight(int height) const
+{
+    if (isValid())
+    {
+        return _button->widthForHeight(height);
+    }
+
+    return height;
+}
+
+int ButtonContainer::heightForWidth(int width)  const
+{
+    if (isValid())
+    {
+        return _button->heightForWidth(width);
+    }
+
+    return width;
+}
+
+void ButtonContainer::setBackground()
+{
+    PanelButton* b = button();
+    if (!b)
+        return;
+
+    b->unsetPalette();
+}
+
+void ButtonContainer::configure()
+{
+    if (_button)
+    {
+        _button->configure();
+    }
+}
+
+void ButtonContainer::doSaveConfiguration(KConfigGroup& config, bool layoutOnly) const
+{
+    // immutability is checked by ContainerBase
+    if (_button && !layoutOnly)
+    {
+        _button->saveConfig(config);
+    }
+}
+
+void ButtonContainer::setPopupDirection(KPanelApplet::Direction d)
+{
+    BaseContainer::setPopupDirection(d);
+
+    if (_button)
+    {
+        _button->setPopupDirection(d);
+    }
+}
+
+void ButtonContainer::setOrientation(Orientation o)
+{
+    BaseContainer::setOrientation(o);
+
+    if(_button)
+        _button->setOrientation(o);
+}
+
+void ButtonContainer::embedButton(PanelButton* b)
+{
+    if (!b) return;
+
+    delete _layout;
+    _layout = new QVBoxLayout(this);
+    _button = b;
+
+    _button->installEventFilter(this);
+    _layout->add(_button);
+    connect(_button, SIGNAL(requestSave()), SIGNAL(requestSave()));
+    connect(_button, SIGNAL(hideme(bool)), SLOT(hideRequested(bool)));
+    connect(_button, SIGNAL(removeme()), SLOT(removeRequested()));
+    connect(_button, SIGNAL(dragme(const QPixmap)),
+            SLOT(dragButton(const QPixmap)));
+    connect(_button, SIGNAL(dragme(const KURL::List, const QPixmap)),
+            SLOT(dragButton(const KURL::List, const QPixmap)));
+}
+
+QPopupMenu* ButtonContainer::createOpMenu()
+{
+    return new PanelAppletOpMenu(_actions, appletOpMenu(), 0, _button->title(),
+                                 _button->icon(), this);
+}
+
+void ButtonContainer::removeRequested()
+{
+    if (isImmutable())
+    {
+        return;
+    }
+
+    emit removeme(this);
+}
+
+void ButtonContainer::hideRequested(bool shouldHide)
+{
+    if (shouldHide)
+    {
+        hide();
+    }
+    else
+    {
+        show();
+    }
+}
+
+void ButtonContainer::dragButton(const KURL::List urls, const QPixmap icon)
+{
+    if (isImmutable())
+    {
+        return;
+    }
+
+    KMultipleDrag* dd = new KMultipleDrag(this);
+    dd->addDragObject(new KURLDrag(urls, 0));
+    dd->addDragObject(new PanelDrag(this, 0));
+    dd->setPixmap(icon);
+    grabKeyboard();
+    dd->dragMove();
+    releaseKeyboard();
+}
+
+void ButtonContainer::dragButton(const QPixmap icon)
+{
+    PanelDrag* dd = new PanelDrag(this, this);
+    dd->setPixmap(icon);
+    grabKeyboard();
+    dd->drag();
+    releaseKeyboard();
+}
+
+bool ButtonContainer::eventFilter(QObject *o, QEvent *e)
+{
+    if (o == _button && e->type() == QEvent::MouseButtonPress)
+    {
+        static bool sentinal = false;
+
+        if (sentinal)
+        {
+            return false;
+        }
+
+        sentinal = true;
+        QMouseEvent* me = static_cast<QMouseEvent*>(e);
+        switch (me->button())
+        {
+        case MidButton:
+        {
+            if (isImmutable())
+            {
+                break;
+            }
+
+            _button->setDown(true);
+            _moveOffset = me->pos();
+            emit moveme(this);
+            sentinal = false;
+            return true;
+        }
+
+        case RightButton:
+        {
+            if (!kapp->authorizeKAction("kicker_rmb") ||
+                isImmutable())
+            {
+                break;
+            }
+
+            QPopupMenu* menu = opMenu();
+            connect( menu, SIGNAL( aboutToHide() ), this, SLOT( slotMenuClosed() ) );
+            QPoint pos = KickerLib::popupPosition(popupDirection(), menu, this,
+                                                  (orientation() == Horizontal) ?
+                                                   QPoint(0, 0) : me->pos());
+
+            Kicker::the()->setInsertionPoint(me->globalPos());
+
+            KickerTip::enableTipping(false);
+            switch (menu->exec(pos))
+            {
+            case PanelAppletOpMenu::Move:
+                _moveOffset = rect().center();
+                emit moveme(this);
+                break;
+            case PanelAppletOpMenu::Remove:
+                emit removeme(this);
+                break;
+            case PanelAppletOpMenu::Help:
+                help();
+                break;
+            case PanelAppletOpMenu::About:
+                about();
+                break;
+            case PanelAppletOpMenu::Preferences:
+                if (_button)
+                {
+                    _button->properties();
+                }
+                break;
+            default:
+                break;
+            }
+            KickerTip::enableTipping(true);
+
+            Kicker::the()->setInsertionPoint(QPoint());
+            clearOpMenu();
+            sentinal = false;
+            return true;
+        }
+
+        default:
+            break;
+        }
+
+        sentinal = false;
+    }
+    return false;
+}
+
+void ButtonContainer::completeMoveOperation()
+{
+    if (_button)
+    {
+        _button->setDown(false);
+        setBackground();
+    }
+}
+
+void ButtonContainer::slotMenuClosed()
+{
+    if (_button)
+        _button->setDown(false);
+}
+
+void ButtonContainer::checkImmutability(const KConfigGroup& config)
+{
+    m_immutable = config.groupIsImmutable() ||
+                  config.entryIsImmutable("ConfigFile") ||
+                  config.entryIsImmutable("FreeSpace2");
+}
+
+// KMenuButton containerpan
+KMenuButtonContainer::KMenuButtonContainer(const KConfigGroup& config, QPopupMenu *opMenu, QWidget* parent)
+  : ButtonContainer(opMenu, parent)
+{
+    checkImmutability(config);
+    embedButton( new KButton(this) );
+    _actions = PanelAppletOpMenu::KMenuEditor;
+}
+
+KMenuButtonContainer::KMenuButtonContainer(QPopupMenu *opMenu, QWidget* parent)
+  : ButtonContainer(opMenu, parent)
+{
+    embedButton( new KButton(this) );
+    _actions = PanelAppletOpMenu::KMenuEditor;
+}
+
+int KMenuButtonContainer::heightForWidth( int width ) const
+{
+    if ( width < 32 )
+        return width + 10;
+    else
+        return ButtonContainer::heightForWidth(width);
+}
+
+// DesktopButton container
+DesktopButtonContainer::DesktopButtonContainer(QPopupMenu *opMenu, QWidget* parent)
+  : ButtonContainer(opMenu, parent)
+{
+    embedButton( new DesktopButton(this) );
+}
+
+DesktopButtonContainer::DesktopButtonContainer(const KConfigGroup& config,
+                                               QPopupMenu *opMenu, QWidget* parent)
+  : ButtonContainer(opMenu, parent)
+{
+    checkImmutability(config);
+    embedButton( new DesktopButton(this) );
+}
+
+// ServiceButton container
+ServiceButtonContainer::ServiceButtonContainer( const QString& desktopFile,
+                                                QPopupMenu* opMenu, QWidget* parent)
+  : ButtonContainer(opMenu, parent)
+{
+    embedButton( new ServiceButton( desktopFile, this ) );
+    _actions = KPanelApplet::Preferences;
+}
+
+ServiceButtonContainer::ServiceButtonContainer( const KService::Ptr &service,
+                                                QPopupMenu* opMenu, QWidget* parent)
+  : ButtonContainer(opMenu, parent)
+{
+    embedButton( new ServiceButton( service, this ) );
+    _actions = KPanelApplet::Preferences;
+}
+
+ServiceButtonContainer::ServiceButtonContainer( const KConfigGroup& config,
+                                                QPopupMenu* opMenu, QWidget* parent)
+  : ButtonContainer(opMenu, parent)
+{
+    checkImmutability(config);
+    embedButton( new ServiceButton( config, this ) );
+    _actions = KPanelApplet::Preferences;
+}
+
+QString ServiceButtonContainer::icon() const
+{
+    return button()->icon();
+}
+
+QString ServiceButtonContainer::visibleName() const
+{
+    return button()->title();
+}
+
+// URLButton container
+URLButtonContainer::URLButtonContainer( const QString& url, QPopupMenu* opMenu, QWidget* parent )
+  : ButtonContainer(opMenu, parent)
+{
+    embedButton( new URLButton( url, this ) );
+    _actions = KPanelApplet::Preferences;
+}
+
+URLButtonContainer::URLButtonContainer( const KConfigGroup& config, QPopupMenu* opMenu, QWidget* parent)
+  : ButtonContainer(opMenu, parent)
+{
+    checkImmutability(config);
+    embedButton( new URLButton( config, this ) );
+    _actions = KPanelApplet::Preferences;
+}
+
+QString URLButtonContainer::icon() const
+{
+    return button()->icon();
+}
+
+QString URLButtonContainer::visibleName() const
+{
+    return button()->title();
+}
+
+// BrowserButton container
+BrowserButtonContainer::BrowserButtonContainer(const QString &startDir, QPopupMenu* opMenu, const QString& icon, QWidget* parent)
+  : ButtonContainer(opMenu, parent)
+{
+    embedButton( new BrowserButton(icon, startDir, this) );
+    _actions = KPanelApplet::Preferences;
+}
+
+BrowserButtonContainer::BrowserButtonContainer( const KConfigGroup& config, QPopupMenu* opMenu, QWidget* parent)
+  : ButtonContainer(opMenu, parent)
+{
+    checkImmutability(config);
+    embedButton( new BrowserButton(config, this) );
+    _actions = KPanelApplet::Preferences;
+}
+
+// ServiceMenuButton container
+ServiceMenuButtonContainer::ServiceMenuButtonContainer(const QString& relPath, QPopupMenu* opMenu, QWidget* parent)
+  : ButtonContainer(opMenu, parent)
+{
+    embedButton( new ServiceMenuButton(relPath, this) );
+}
+
+ServiceMenuButtonContainer::ServiceMenuButtonContainer( const KConfigGroup& config, QPopupMenu* opMenu, QWidget* parent)
+  : ButtonContainer(opMenu, parent)
+{
+    checkImmutability(config);
+    embedButton( new ServiceMenuButton(config, this) );
+}
+
+QString ServiceMenuButtonContainer::icon() const
+{
+    return button()->icon();
+}
+
+QString ServiceMenuButtonContainer::visibleName() const
+{
+    return button()->title();
+}
+
+// WindowListButton container
+WindowListButtonContainer::WindowListButtonContainer(const KConfigGroup& config, QPopupMenu *opMenu, QWidget* parent)
+  : ButtonContainer(opMenu, parent)
+{
+    checkImmutability(config);
+    embedButton( new WindowListButton(this) );
+}
+
+WindowListButtonContainer::WindowListButtonContainer(QPopupMenu *opMenu, QWidget* parent)
+  : ButtonContainer(opMenu, parent)
+{
+    embedButton( new WindowListButton(this) );
+}
+
+// BookmarkButton container
+BookmarksButtonContainer::BookmarksButtonContainer(const KConfigGroup& config, QPopupMenu *opMenu, QWidget* parent)
+  : ButtonContainer(opMenu, parent)
+{
+    checkImmutability(config);
+    embedButton( new BookmarksButton(this) );
+    _actions = PanelAppletOpMenu::BookmarkEditor;
+}
+
+BookmarksButtonContainer::BookmarksButtonContainer(QPopupMenu *opMenu, QWidget* parent)
+  : ButtonContainer(opMenu, parent)
+{
+    embedButton( new BookmarksButton(this) );
+    _actions = PanelAppletOpMenu::BookmarkEditor;
+}
+
+// NonKDEAppButton container
+NonKDEAppButtonContainer::NonKDEAppButtonContainer(const QString &name,
+                                                   const QString &description,
+                                                   const QString &filePath,
+                                                   const QString &icon,
+                                                   const QString &cmdLine,
+                                                   bool inTerm,
+                                                   QPopupMenu* opMenu,
+                                                   QWidget* parent)
+  : ButtonContainer(opMenu, parent)
+{
+    embedButton(new NonKDEAppButton(name, description, filePath, icon, cmdLine,
+                                    inTerm, this));
+    _actions = KPanelApplet::Preferences;
+}
+
+NonKDEAppButtonContainer::NonKDEAppButtonContainer( const KConfigGroup& config, QPopupMenu* opMenu, QWidget *parent)
+  : ButtonContainer(opMenu, parent)
+{
+    checkImmutability(config);
+    embedButton( new NonKDEAppButton(config, this) );
+    _actions = KPanelApplet::Preferences;
+}
+
+// ExtensionButton container
+ExtensionButtonContainer::ExtensionButtonContainer(const QString& df, QPopupMenu* opMenu, QWidget *parent)
+  : ButtonContainer(opMenu, parent)
+{
+    embedButton( new ExtensionButton(df, this) );
+}
+
+ExtensionButtonContainer::ExtensionButtonContainer( const KConfigGroup& config, QPopupMenu* opMenu, QWidget *parent)
+  : ButtonContainer(opMenu, parent)
+{
+    checkImmutability(config);
+    embedButton( new ExtensionButton(config, this) );
+}
+
+QString ExtensionButtonContainer::icon() const
+{
+    return button()->icon();
+}
+
+QString ExtensionButtonContainer::visibleName() const
+{
+    return button()->title();
+}
+
diff -Nurp kicker.orig/kicker/core/kicker.cpp kicker/kicker/core/kicker.cpp
--- kicker.orig/kicker/core/kicker.cpp	2008-08-19 18:16:56.000000000 +0000
+++ kicker/kicker/core/kicker.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -48,6 +48,8 @@
 #include "extensionmanager.h"
 #include "pluginmanager.h"
 #include "menumanager.h"
+#include "k_new_mnu.h"
+#include "k_mnu_stub.h"
 #include "k_mnu.h"
 #include "showdesktop.h"
 #include "panelbutton.h"
@@ -106,6 +108,7 @@ Kicker::Kicker()
 
     KGlobal::iconLoader()->addExtraDesktopThemes();
 
+    KGlobal::locale()->insertCatalogue("kdmgreet");
     KGlobal::locale()->insertCatalogue("libkonq");
     KGlobal::locale()->insertCatalogue("libdmctl");
     KGlobal::locale()->insertCatalogue("libtaskbar");
@@ -212,7 +215,7 @@ bool Kicker::highlightMenuItem(const QSt
 
 void Kicker::showKMenu()
 {
-    MenuManager::the()->showKMenu();
+    MenuManager::the()->kmenuAccelActivated();
 }
 
 void Kicker::popupKMenu(const QPoint &p)
diff -Nurp kicker.orig/kicker/core/kicker.cpp.orig kicker/kicker/core/kicker.cpp.orig
--- kicker.orig/kicker/core/kicker.cpp.orig	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/core/kicker.cpp.orig	2008-08-19 18:16:56.000000000 +0000
@@ -0,0 +1,401 @@
+/*****************************************************************
+
+  Copyright (c) 1996-2001 the kicker authors. See file AUTHORS.
+
+  Permission is hereby granted, free of charge, to any person obtaining a copy
+  of this software and associated documentation files (the "Software"), to deal
+  in the Software without restriction, including without limitation the rights
+  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+  AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+  AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+ ******************************************************************/
+
+#include <stdlib.h>
+#include <unistd.h>
+
+#include <qfile.h>
+#include <qtimer.h>
+#include <qtooltip.h>
+
+#include <dcopclient.h>
+#include <kconfig.h>
+#include <kcmdlineargs.h>
+#include <kcmultidialog.h>
+#include <kcrash.h>
+#include <kdebug.h>
+#include <kdirwatch.h>
+#include <kglobal.h>
+#include <kglobalaccel.h>
+#include <kiconloader.h>
+#include <kimageio.h>
+#include <klocale.h>
+#include <kmessagebox.h>
+#include <kstandarddirs.h>
+#include <kwin.h>
+#include <kwinmodule.h>
+
+#include "extensionmanager.h"
+#include "pluginmanager.h"
+#include "menumanager.h"
+#include "k_mnu.h"
+#include "showdesktop.h"
+#include "panelbutton.h"
+
+#include "kicker.h"
+#include "kickerSettings.h"
+
+#include "kicker.moc"
+
+Kicker* Kicker::the() { return static_cast<Kicker*>(kapp); }
+
+Kicker::Kicker()
+    : KUniqueApplication(),
+      keys(0),
+      m_kwinModule(0),
+      m_configDialog(0),
+      m_canAddContainers(true)
+{
+    // initialize the configuration object
+    KickerSettings::instance(instanceName() + "rc");
+
+    if (KCrash::crashHandler() == 0 )
+    {
+        // this means we've most likely crashed once. so let's see if we
+        // stay up for more than 2 minutes time, and if so reset the
+        // crash handler since the crash isn't a frequent offender
+        QTimer::singleShot(120000, this, SLOT(setCrashHandler()));
+    }
+    else
+    {
+        // See if a crash handler was installed. It was if the -nocrashhandler
+        // argument was given, but the app eats the kde options so we can't
+        // check that directly. If it wasn't, don't install our handler either.
+        setCrashHandler();
+    }
+
+    // Make kicker immutable if configuration modules have been marked immutable
+    if (isKioskImmutable() && kapp->authorizeControlModules(Kicker::configModules(true)).isEmpty())
+    {
+        config()->setReadOnly(true);
+        config()->reparseConfiguration();
+    }
+
+    dcopClient()->setDefaultObject("Panel");
+    disableSessionManagement();
+    QString dataPathBase = KStandardDirs::kde_default("data").append("kicker/");
+    KGlobal::dirs()->addResourceType("mini", dataPathBase + "pics/mini");
+    KGlobal::dirs()->addResourceType("icon", dataPathBase + "pics");
+    KGlobal::dirs()->addResourceType("builtinbuttons", dataPathBase + "builtins");
+    KGlobal::dirs()->addResourceType("specialbuttons", dataPathBase + "menuext");
+    KGlobal::dirs()->addResourceType("applets", dataPathBase + "applets");
+    KGlobal::dirs()->addResourceType("tiles", dataPathBase + "tiles");
+    KGlobal::dirs()->addResourceType("extensions", dataPathBase +  "extensions");
+
+    KImageIO::registerFormats();
+
+    KGlobal::iconLoader()->addExtraDesktopThemes();
+
+    KGlobal::locale()->insertCatalogue("libkonq");
+    KGlobal::locale()->insertCatalogue("libdmctl");
+    KGlobal::locale()->insertCatalogue("libtaskbar");
+
+    // initialize our keys
+    // note that this creates the KMenu by calling MenuManager::the()
+    keys = new KGlobalAccel( this );
+#define KICKER_ALL_BINDINGS
+#include "kickerbindings.cpp"
+    keys->readSettings();
+    keys->updateConnections();
+
+    // set up our global settings
+    configure();
+
+    connect(this, SIGNAL(settingsChanged(int)), SLOT(slotSettingsChanged(int)));
+    connect(this, SIGNAL(kdisplayPaletteChanged()), SLOT(paletteChanged()));
+    connect(this, SIGNAL(kdisplayStyleChanged()), SLOT(slotStyleChanged()));
+
+#if (QT_VERSION-0 >= 0x030200) // XRANDR support
+    connect(desktop(), SIGNAL(resized(int)), SLOT(slotDesktopResized()));
+#endif
+
+    // the panels, aka extensions
+    QTimer::singleShot(0, ExtensionManager::the(), SLOT(initialize()));
+
+    connect(ExtensionManager::the(), SIGNAL(desktopIconsAreaChanged(const QRect &, int)),
+            this, SLOT(slotDesktopIconsAreaChanged(const QRect &, int)));
+}
+
+Kicker::~Kicker()
+{
+    // order of deletion here is critical to avoid crashes
+    delete ExtensionManager::the();
+    delete MenuManager::the();
+}
+
+void Kicker::setCrashHandler()
+{
+    KCrash::setEmergencySaveFunction(Kicker::crashHandler);
+}
+
+void Kicker::crashHandler(int /* signal */)
+{
+    fprintf(stderr, "kicker: crashHandler called\n");
+
+    DCOPClient::emergencyClose();
+    sleep(1);
+    system("kicker --nocrashhandler &"); // try to restart
+}
+
+void Kicker::slotToggleShowDesktop()
+{
+    // don't connect directly to the ShowDesktop::toggle() slot
+    // so that the ShowDesktop object doesn't get created if
+    // this feature is never used, and isn't created until after
+    // startup even if it is
+    ShowDesktop::the()->toggle();
+}
+
+void Kicker::toggleLock()
+{
+    KickerSettings::self()->setLocked(!KickerSettings::locked());
+    KickerSettings::self()->writeConfig();
+    emit immutabilityChanged(isImmutable());
+}
+
+void Kicker::toggleShowDesktop()
+{
+    ShowDesktop::the()->toggle();
+}
+
+bool Kicker::desktopShowing()
+{
+    return ShowDesktop::the()->desktopShowing();
+}
+
+void Kicker::slotSettingsChanged(int category)
+{
+    if (category == (int)KApplication::SETTINGS_SHORTCUTS)
+    {
+        keys->readSettings();
+        keys->updateConnections();
+    }
+}
+
+void Kicker::paletteChanged()
+{
+    KConfigGroup c(KGlobal::config(), "General");
+    KickerSettings::setTintColor(c.readColorEntry("TintColor",
+                                           &palette().active().mid()));
+    KickerSettings::self()->writeConfig();
+}
+
+void Kicker::slotStyleChanged()
+{
+	restart();
+}
+
+bool Kicker::highlightMenuItem(const QString &menuId)
+{
+    return MenuManager::the()->kmenu()->highlightMenuItem( menuId );
+}
+
+void Kicker::showKMenu()
+{
+    MenuManager::the()->showKMenu();
+}
+
+void Kicker::popupKMenu(const QPoint &p)
+{
+    MenuManager::the()->popupKMenu(p);
+}
+
+void Kicker::configure()
+{
+    static bool notFirstConfig = false;
+
+    KConfig* c = KGlobal::config();
+    c->reparseConfiguration();
+    c->setGroup("General");
+    m_canAddContainers = !c->entryIsImmutable("Applets2");
+
+    KickerSettings::self()->readConfig();
+
+    QToolTip::setGloballyEnabled(KickerSettings::showToolTips());
+
+    if (notFirstConfig)
+    {
+        emit configurationChanged();
+        {
+            QByteArray data;
+            emitDCOPSignal("configurationChanged()", data);
+        }
+    }
+
+    notFirstConfig = true;
+//    kdDebug(1210) << "tooltips " << ( _showToolTips ? "enabled" : "disabled" ) << endl;
+}
+
+void Kicker::quit()
+{
+    exit(1);
+}
+
+void Kicker::restart()
+{
+    // do this on a timer to give us time to return true
+    QTimer::singleShot(0, this, SLOT(slotRestart()));
+}
+
+void Kicker::slotRestart()
+{
+    // since the child will awaken before we do, we need to
+    // clear the untrusted list manually; can't rely on the
+    // dtor's to this for us.
+    PluginManager::the()->clearUntrustedLists();
+
+    char ** o_argv = new char*[2];
+    o_argv[0] = strdup("kicker");
+    o_argv[1] = 0L;
+    execv(QFile::encodeName(locate("exe", "kdeinit_wrapper")), o_argv);
+
+    exit(1);
+}
+
+bool Kicker::isImmutable() const
+{
+    return config()->isImmutable() || KickerSettings::locked();
+}
+
+bool Kicker::isKioskImmutable() const
+{
+    return config()->isImmutable();
+}
+
+void Kicker::addExtension( const QString &desktopFile )
+{
+   ExtensionManager::the()->addExtension( desktopFile );
+}
+
+QStringList Kicker::configModules(bool controlCenter)
+{
+    QStringList args;
+
+    if (controlCenter)
+    {
+        args << "kde-panel.desktop";
+    }
+    else
+    {
+        args << "kde-kicker_config_arrangement.desktop"
+             << "kde-kicker_config_hiding.desktop"
+             << "kde-kicker_config_menus.desktop"
+             << "kde-kicker_config_appearance.desktop";
+    }
+    args << "kde-kcmtaskbar.desktop";
+    return args;
+}
+
+QPoint Kicker::insertionPoint()
+{
+    return m_insertionPoint;
+}
+
+void Kicker::setInsertionPoint(const QPoint &p)
+{
+    m_insertionPoint = p;
+}
+
+
+void Kicker::showConfig(const QString& configPath, int page)
+{
+    if (!m_configDialog)
+    {
+         m_configDialog = new KCMultiDialog(0);
+
+         QStringList modules = configModules(false);
+         QStringList::ConstIterator end(modules.end());
+         for (QStringList::ConstIterator it = modules.begin(); it != end; ++it)
+         {
+            m_configDialog->addModule(*it);
+         }
+
+         connect(m_configDialog, SIGNAL(finished()), SLOT(configDialogFinished()));
+    }
+
+    if (!configPath.isEmpty())
+    {
+        QByteArray data;
+        QDataStream stream(data, IO_WriteOnly);
+        stream << configPath;
+        emitDCOPSignal("configSwitchToPanel(QString)", data);
+    }
+
+    KWin::setOnDesktop(m_configDialog->winId(), KWin::currentDesktop());
+    m_configDialog->show();
+    m_configDialog->raise();
+    if (page > -1)
+    {
+        m_configDialog->showPage(page);
+    }
+}
+
+void Kicker::showTaskBarConfig()
+{
+    showConfig(QString(), 4);
+}
+
+void Kicker::configureMenubar()
+{
+    ExtensionManager::the()->configureMenubar(false);
+}
+
+void Kicker::configDialogFinished()
+{
+    m_configDialog->delayedDestruct();
+    m_configDialog = 0;
+}
+
+void Kicker::slotDesktopResized()
+{
+    configure(); // reposition on the desktop
+}
+
+void Kicker::clearQuickStartMenu()
+{
+    MenuManager::the()->kmenu()->clearRecentMenuItems();
+}
+
+KWinModule* Kicker::kwinModule()
+{
+    if (!m_kwinModule)
+    {
+        m_kwinModule = new KWinModule();
+    }
+
+    return m_kwinModule;
+}
+
+QRect Kicker::desktopIconsArea(int screen) const
+{
+    return ExtensionManager::the()->desktopIconsArea(screen);
+}
+
+void Kicker::slotDesktopIconsAreaChanged(const QRect &area, int screen)
+{
+    QByteArray params;
+    QDataStream stream(params, IO_WriteOnly);
+    stream << area;
+    stream << screen;
+    emitDCOPSignal("desktopIconsAreaChanged(QRect, int)", params);
+}
diff -Nurp kicker.orig/kicker/core/main.cpp kicker/kicker/core/main.cpp
--- kicker.orig/kicker/core/main.cpp	2008-08-19 18:16:56.000000000 +0000
+++ kicker/kicker/core/main.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -108,7 +108,7 @@ extern "C" KDE_EXPORT int kdemain( int a
 	appname.sprintf("kicker-screen-%d", kicker_screen_number);
 
     KAboutData aboutData( appname.data(), I18N_NOOP("KDE Panel"),
-                          version, description, KAboutData::License_BSD,
+                          version, description, KAboutData::License_GPL_V2,
                           I18N_NOOP("(c) 1999-2004, The KDE Team") );
 
     aboutData.addAuthor("Aaron J. Seigo", I18N_NOOP("Current maintainer"), "aseigo@kde.org");
diff -Nurp kicker.orig/kicker/core/Makefile.am kicker/kicker/core/Makefile.am
--- kicker.orig/kicker/core/Makefile.am	2005-09-10 08:25:30.000000000 +0000
+++ kicker/kicker/core/Makefile.am	2008-09-17 15:14:41.000000000 +0000
@@ -1,6 +1,6 @@
 INCLUDES = -I$(srcdir)/../../libkicker -I../../libkicker \
-	 -I$(srcdir)/../ui -I$(srcdir)/../buttons -I$(top_srcdir)/libkonq \
-	 $(all_includes)
+	 -I../ui -I$(srcdir)/../ui -I$(srcdir)/../buttons -I$(top_srcdir)/libkonq \
+	 $(all_includes) $(LIBBEAGLE_CFLAGS) $(GLIB_CFLAGS)
 
 noinst_LTLIBRARIES = libkicker_core.la
 
diff -Nurp kicker.orig/kicker/core/menumanager.cpp kicker/kicker/core/menumanager.cpp
--- kicker.orig/kicker/core/menumanager.cpp	2006-03-17 10:17:32.000000000 +0000
+++ kicker/kicker/core/menumanager.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -31,9 +31,12 @@ CONNECTION WITH THE SOFTWARE OR THE USE 
 #include "client_mnu.h"
 #include "container_extension.h"
 #include "global.h"
+#include "k_new_mnu.h"
 #include "k_mnu.h"
+#include "k_mnu_stub.h"
 #include "kicker.h"
 #include "panelbutton.h"
+#include "kickerSettings.h"
 
 #include "menumanager.h"
 #include "menumanager.moc"
@@ -62,7 +65,11 @@ MenuManager* MenuManager::the()
 MenuManager::MenuManager(QObject *parent)
     : QObject(parent, "MenuManager"), DCOPObject("MenuManager")
 {
-    m_kmenu = new PanelKMenu;
+    if (KickerSettings::legacyKMenu()) 
+	m_kmenu = new KMenuStub(new PanelKMenu);
+    else
+	m_kmenu = new KMenuStub(new KMenu);
+
     kapp->dcopClient()->setNotifications(true);
     connect(kapp->dcopClient(), SIGNAL(applicationRemoved(const QCString&)),
             this, SLOT(applicationRemoved(const QCString&)));
@@ -83,14 +90,8 @@ void MenuManager::slotSetKMenuItemActive
     m_kmenu->selectFirstItem();
 }
 
-void MenuManager::showKMenu()
-{
-    m_kmenu->showMenu();
-}
-
 void MenuManager::popupKMenu(const QPoint &p)
 {
-//    kdDebug(1210) << "popupKMenu()" << endl;
     if (m_kmenu->isVisible())
     {
         m_kmenu->hide();
@@ -120,7 +121,7 @@ void MenuManager::unregisterKButton(Pane
     m_kbuttons.remove(button);
 }
 
-PanelPopupButton* MenuManager::findKButtonFor(QPopupMenu* menu)
+PanelPopupButton* MenuManager::findKButtonFor(QWidget* menu)
 {
     KButtonList::const_iterator itEnd = m_kbuttons.constEnd();
     for (KButtonList::const_iterator it = m_kbuttons.constBegin(); it != itEnd; ++it)
@@ -169,7 +170,7 @@ void MenuManager::kmenuAccelActivated()
         const QSize size = m_kmenu->sizeHint();
         m_kmenu->resize(size.width(),size.height());
 
-        PanelPopupButton* button = findKButtonFor(m_kmenu);
+        PanelPopupButton* button = findKButtonFor(m_kmenu->widget());
 
         // let's unhide the panel while we're at it. traverse the widget
         // hierarchy until we find the panel, if any
@@ -189,7 +190,6 @@ void MenuManager::kmenuAccelActivated()
 
             menuParent = menuParent->parent();
         }
-
         button->showMenu();
     }
 }
@@ -213,7 +213,7 @@ QCString MenuManager::createMenu(QPixmap
 
 void MenuManager::removeMenu(QCString menu)
 {
-    bool iterate = true;
+    bool iterate = true, need_adjustSize = false;
     ClientMenuList::iterator it = clientmenus.begin();
     for (; it != clientmenus.end(); iterate ? ++it : it)
     {
@@ -224,15 +224,17 @@ void MenuManager::removeMenu(QCString me
             m_kmenu->removeClientMenu(m->idInParentMenu);
             it = clientmenus.erase(it);
             iterate = false;
+            need_adjustSize = true;
         }
     }
-    m_kmenu->adjustSize();
+    if (need_adjustSize)
+        m_kmenu->adjustSize();
 }
 
 
 void MenuManager::applicationRemoved(const QCString& appRemoved)
 {
-    bool iterate = true;
+    bool iterate = true, need_adjustSize = false;
     ClientMenuList::iterator it = clientmenus.begin();
     for (; it != clientmenus.end(); iterate ? ++it : it)
     {
@@ -243,9 +245,11 @@ void MenuManager::applicationRemoved(con
             m_kmenu->removeClientMenu(m->idInParentMenu);
             it = clientmenus.erase(it);
             iterate = false;
+            need_adjustSize = true;
         }
     }
-    m_kmenu->adjustSize();
+    if (need_adjustSize)
+        m_kmenu->adjustSize();
 }
 
 bool MenuManager::process(const QCString &fun, const QByteArray &data,
diff -Nurp kicker.orig/kicker/core/menumanager.h kicker/kicker/core/menumanager.h
--- kicker.orig/kicker/core/menumanager.h	2006-03-17 10:17:32.000000000 +0000
+++ kicker/kicker/core/menumanager.h	2008-09-17 15:14:41.000000000 +0000
@@ -28,7 +28,9 @@ CONNECTION WITH THE SOFTWARE OR THE USE 
 #include <qvaluelist.h>
 
 class PanelKMenu;
+class KMenu;
 class KickerClientMenu;
+class KMenuStub;
 class PanelPopupButton;
 
 typedef QValueList<PanelPopupButton*> KButtonList;
@@ -50,13 +52,12 @@ public:
     bool process(const QCString &fun, const QByteArray &data, QCString& replyType, QByteArray &reply);
 
     // KMenu controls
-    PanelKMenu* kmenu() { return m_kmenu; }
-    void showKMenu();
+    KMenuStub* kmenu() { return m_kmenu; }
     void popupKMenu(const QPoint &p);
 
     void registerKButton(PanelPopupButton *button);
     void unregisterKButton(PanelPopupButton *button);
-    PanelPopupButton* findKButtonFor(QPopupMenu* menu);
+    PanelPopupButton* findKButtonFor(QWidget* menu);
     ~MenuManager();
 
 public slots:
@@ -67,7 +68,7 @@ protected slots:
     void applicationRemoved(const QCString&);
 
 protected:
-    PanelKMenu* m_kmenu;
+    KMenuStub* m_kmenu;
     typedef QValueList<KickerClientMenu*> ClientMenuList;
     ClientMenuList clientmenus;
 
diff -Nurp kicker.orig/kicker/core/unhidetrigger.cpp kicker/kicker/core/unhidetrigger.cpp
--- kicker.orig/kicker/core/unhidetrigger.cpp	2005-09-10 08:25:30.000000000 +0000
+++ kicker/kicker/core/unhidetrigger.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -39,7 +39,7 @@ UnhideTrigger::UnhideTrigger()
 	, _lastXineramaScreen( -1 )
 	, enabledCount( 0 )
 {
-	_timer = new QTimer( this );
+	_timer = new QTimer( this, "UnhideTrigger" );
 	connect( _timer, SIGNAL(timeout()), SLOT(pollMouse()) );
 }
 
diff -Nurp kicker.orig/kicker/interfaces/kickoffsearchinterface.cpp kicker/kicker/interfaces/kickoffsearchinterface.cpp
--- kicker.orig/kicker/interfaces/kickoffsearchinterface.cpp	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/interfaces/kickoffsearchinterface.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,27 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Stephan Binner <binner@kde.org>                 *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
+ ***************************************************************************/
+
+#include "kickoffsearchinterface.h"
+
+KickoffSearch::KickoffSearchInterface::KickoffSearchInterface( QObject* parent, const char* name )
+    :QObject( parent, name )
+{
+}
+
+#include "kickoffsearchinterface.moc"
diff -Nurp kicker.orig/kicker/interfaces/kickoffsearchinterface.h kicker/kicker/interfaces/kickoffsearchinterface.h
--- kicker.orig/kicker/interfaces/kickoffsearchinterface.h	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/interfaces/kickoffsearchinterface.h	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,46 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Stephan Binner <binner@kde.org>                 *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
+ ***************************************************************************/
+
+#ifndef KICKOFFSEARCHINTERFACE_H
+#define KICKOFFSEARCHINTERFACE_H
+
+#include <qobject.h>
+
+class HitMenuItem;
+
+namespace KickoffSearch
+{
+    class KickoffSearchInterface :public QObject
+    {
+        Q_OBJECT
+
+    public:
+        KickoffSearchInterface( QObject* parent, const char* name = 0);
+
+    public:
+        virtual bool anotherHitMenuItemAllowed(int cat) = 0;
+        virtual void addHitMenuItem(HitMenuItem* item) = 0;
+        virtual void searchOver() = 0;
+        virtual void initCategoryTitlesUpdate() = 0;
+        virtual void updateCategoryTitles() = 0;
+    };
+}
+
+#endif /* SELECTIONINTERFACE_H */
+
diff -Nurp kicker.orig/kicker/interfaces/kickoff-search-plugin.cpp kicker/kicker/interfaces/kickoff-search-plugin.cpp
--- kicker.orig/kicker/interfaces/kickoff-search-plugin.cpp	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/interfaces/kickoff-search-plugin.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,37 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Stephan Binner <binner@kde.org>                 *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
+ ***************************************************************************/
+
+#include "kickoff-search-plugin.h"
+#include <qobjectlist.h>
+
+KickoffSearch::Plugin::Plugin(QObject *parent, const char* name )
+    :QObject( parent, name )
+{
+}
+
+KickoffSearch::Plugin::~Plugin()
+{
+}
+
+KickoffSearch::KickoffSearchInterface* KickoffSearch::Plugin::kickoffSearchInterface()
+{
+    return static_cast<KickoffSearchInterface*>( parent()->child( 0, "KickoffSearch::KickoffSearchInterface" ) );
+}
+
+#include "kickoff-search-plugin.moc"
diff -Nurp kicker.orig/kicker/interfaces/kickoffsearchplugin.desktop kicker/kicker/interfaces/kickoffsearchplugin.desktop
--- kicker.orig/kicker/interfaces/kickoffsearchplugin.desktop	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/interfaces/kickoffsearchplugin.desktop	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,4 @@
+[Desktop Entry]
+Type=ServiceType
+X-KDE-ServiceType=KickoffSearch/Plugin
+Comment=A search plugin for Kickoff
diff -Nurp kicker.orig/kicker/interfaces/kickoff-search-plugin.h kicker/kicker/interfaces/kickoff-search-plugin.h
--- kicker.orig/kicker/interfaces/kickoff-search-plugin.h	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/interfaces/kickoff-search-plugin.h	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,106 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Stephan Binner <binner@kde.org>                 *
+ *   Copyright (c) 2006 Debajyoti Bera <dbera.web@gmail.com>               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
+ ***************************************************************************/
+
+#ifndef KICKOFF_SEARCH_PLUGIN_H
+#define KICKOFF_SEARCH_PLUGIN_H
+
+#include "kickoffsearchinterface.h"
+
+#include <qobject.h>
+#include <kurl.h>
+#include <kservice.h>
+
+typedef enum {
+    ACTIONS = 0,
+    APPS,
+    BOOKMARKS,
+    NOTES,
+    MAILS,
+    FILES,
+    MUSIC,
+    WEBHIST,
+    CHATS,
+    FEEDS,
+    PICS,
+    VIDEOS,
+    DOCS,
+    OTHER,
+    num_categories
+} CATEGORY;
+
+class HitMenuItem
+{
+public:
+    HitMenuItem (int id, int category)
+	: id (id), category (category),score(0) { } /* dummy */
+    HitMenuItem (QString name, QString info, KURL uri, QString mimetype, int id, int category, QString icon=QString::null, int score = 0)
+	: display_name (name)
+	, display_info (info)
+	, uri (uri)
+	, mimetype (mimetype)
+	, id (id)
+	, category (category)
+	, icon (icon)
+	, score (score)
+        , service (NULL) { }
+
+    ~HitMenuItem () { }
+
+    bool operator< (HitMenuItem item)
+    {
+	return ((category == item.category && score > item.score) || (category == item.category && id < item.id) ||
+		(category < item.category));
+    }
+
+    // FIXME: We dont really need to store display_name and display_info
+    QString display_name; // name to display
+    QString display_info; // other information to display
+    KURL uri; // uri to open when clicked
+    QString mimetype;
+    int id; // id of the item in the menu
+    int category;
+    QString icon;
+    int score;
+    KService::Ptr service;
+
+    QString quotedPath () const
+    {
+	return uri.path ().replace ('"', "\\\"");
+    }
+};
+
+namespace KickoffSearch {
+
+    class Plugin : public QObject
+    {
+        Q_OBJECT
+
+    public:
+        Plugin(QObject *parent, const char* name=0);
+        virtual ~Plugin();
+
+        virtual bool daemonRunning()=0;
+        virtual void query(QString,bool)=0;
+
+        KickoffSearchInterface * kickoffSearchInterface();
+    };
+};
+
+#endif /* KICKOFF_SEARCH_PLUGIN_H */
diff -Nurp kicker.orig/kicker/interfaces/Makefile.am kicker/kicker/interfaces/Makefile.am
--- kicker.orig/kicker/interfaces/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/interfaces/Makefile.am	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,12 @@
+METASOURCES = AUTO
+INCLUDES= -I$(top_srcdir)/src $(all_includes) 
+
+# The library containing the plugin base class
+lib_LTLIBRARIES =  libkickoffsearch_interfaces.la
+libkickoffsearch_interfaces_la_SOURCES = kickoff-search-plugin.cpp kickoffsearchinterface.cpp
+libkickoffsearch_interfaces_la_LDFLAGS = $(all_libraries) -version-info 0:0:0
+
+kickoffsearchincludedir = $(includedir)
+kickoffsearchinclude_HEADERS = kickoff-search-plugin.h kickoffsearchinterface.h
+
+kde_servicetypes_DATA = kickoffsearchplugin.desktop
diff -Nurp kicker.orig/kicker/Makefile.am kicker/kicker/Makefile.am
--- kicker.orig/kicker/Makefile.am	2005-09-10 08:25:31.000000000 +0000
+++ kicker/kicker/Makefile.am	2008-09-17 15:14:41.000000000 +0000
@@ -1,6 +1,6 @@
 INCLUDES = $(all_includes)
 
-SUBDIRS = core ui buttons .
+SUBDIRS = core ui buttons interfaces plugins .
 
 bin_PROGRAMS =
 lib_LTLIBRARIES =
@@ -9,7 +9,7 @@ kdeinit_LTLIBRARIES = kicker.la
 CLEANFILES = dummy.cpp
 
 kicker_la_LIBADD = core/libkicker_core.la  buttons/libkicker_buttons.la \
-	ui/libkicker_ui.la ../libkicker/libkickermain.la $(LIB_KIO) $(LIB_KUTILS)
+	ui/libkicker_ui.la ../libkicker/libkickermain.la $(LIB_KIO) $(LIB_KUTILS) $(LIB_KABC)
 
 kicker_la_SOURCES = dummy.cpp
 kicker_la_LDFLAGS = -module $(KDE_PLUGIN) $(all_libraries)
diff -Nurp kicker.orig/kicker/plugins/beaglesearch.cpp kicker/kicker/plugins/beaglesearch.cpp
--- kicker.orig/kicker/plugins/beaglesearch.cpp	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/plugins/beaglesearch.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,362 @@
+/*****************************************************************
+
+   Copyright (c) 2006 Debajyoti Bera <dbera.web@gmail.com>
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+
+******************************************************************/
+
+#include "beaglesearch.h"
+
+#include <qdatetime.h>
+#include <qmutex.h>
+#include <qstringlist.h>
+#include <qapplication.h>
+#include <time.h>
+
+void beagle_init ()
+{
+    g_type_init ();
+}
+
+// ---------------- Hit ---------------------------
+
+Hit::Hit (BeagleHit *_hit) : processed (false)
+{
+    hit = beagle_hit_ref (_hit);
+}
+
+Hit::~Hit ()
+{
+    beagle_hit_unref (hit);
+    if (! processed)
+	return;
+    QDictIterator<QStringList> it (property_map);
+    for( ; it.current(); ++it )
+        ((QStringList *)it.current())->clear ();
+
+}
+
+void Hit::processProperties ()
+{
+    processed = true;
+    GSList *prop_list = beagle_hit_get_all_properties (hit);
+    GSList *it;
+    property_map.setAutoDelete (true);
+    for (it = prop_list; it; it = it->next) {
+        BeagleProperty *property = (BeagleProperty *) it->data;
+        QString key = QString::fromUtf8 (beagle_property_get_key (property));
+        if (! property_map [key])
+            property_map.insert (key, new QStringList ());
+        property_map [key]->append (QString::fromUtf8 (beagle_property_get_value (property)));
+    }
+    g_slist_free (prop_list);
+}
+
+const QString Hit::operator[] (QString prop_name)
+{
+    if (! processed)
+	processProperties ();
+
+    QStringList *prop_list = property_map [prop_name];
+    if (! prop_list)
+        return QString::null;
+    if (prop_list->count () != 1)
+        return QString::null;
+    return (QString)prop_list->first ();
+}
+
+// ---------------- BeagleSearch ------------------
+
+BeagleSearchResult::BeagleSearchResult(int client_id)
+  : client_id (client_id), total (0)
+{
+    hitlist = new QPtrList<Hit>;
+    hitlist->setAutoDelete (true);
+}
+
+
+BeagleSearchResult::~BeagleSearchResult()
+{
+    // everything is set to autodelete
+}
+
+void BeagleSearchResult::addHit(BeagleHit *_hit)
+{
+    Hit *hit = new Hit (_hit);
+    hitlist->prepend (hit);
+}
+
+const QPtrList<Hit> *BeagleSearchResult::getHits () const
+{
+    return hitlist;
+}
+
+
+static int total_hits;
+
+static void print_feed_item_hit (BeagleHit *hit)
+{
+    const char *text;
+
+    if (beagle_hit_get_one_property (hit, "dc:title", &text))
+        g_print ("Blog: %s\n", text);
+}
+
+static void print_file_hit (BeagleHit *hit)
+{
+    g_print ("File: %s, (%s)\n", beagle_hit_get_uri (hit), beagle_hit_get_mime_type (hit));
+}
+
+static void print_other_hit (BeagleHit *hit)
+{
+    const char *text;
+
+    g_print ("%s (%s)", beagle_hit_get_uri (hit),
+             beagle_hit_get_source (hit));
+    if (beagle_hit_get_one_property (hit, "dc:title", &text))
+        g_print ("title = %s\n", text);
+}
+
+static void print_hit (BeagleHit *hit) 
+{
+    if (strcmp (beagle_hit_get_type (hit), "FeedItem") == 0) {
+        print_feed_item_hit (hit);
+    } 
+    else if (strcmp (beagle_hit_get_type (hit), "File") == 0) {
+        print_file_hit (hit);
+    } else {
+        print_other_hit (hit);
+    }
+}
+
+// ---------------- BeagleSearchClient ------------------
+
+void BeagleSearchClient::run ()
+{
+    kdDebug () << "Starting query ..." << endl;
+
+    QTime query_timer;
+    query_timer.start ();
+    
+    g_signal_connect (query, "hits-added",
+                      G_CALLBACK (hitsAddedSlot),
+                      this);
+    g_signal_connect (query, "finished",
+                      G_CALLBACK (finishedSlot),
+                      this);
+    beagle_client_send_request_async (client,
+                                      BEAGLE_REQUEST (query),
+                                      NULL);
+    g_main_loop_run (main_loop);
+    kdDebug () << "Finished query ..." << endl;
+    
+    QCustomEvent *ev;
+    if (collate_results) {
+	result->query_msec = query_timer.elapsed ();
+    
+	ev =  new QCustomEvent (RESULTFOUND, result);
+        QApplication::postEvent (object, ev);
+    }
+
+    ev =  new QCustomEvent (KILLME, this);
+    QApplication::postEvent (object, ev);
+
+}
+
+void BeagleSearchClient::stopClient ()
+{
+   if (finished ())
+       return; // duh!
+   kdDebug () << "Query thread " << id << " not yet finished ..." << endl;
+   // get ready for suicide
+   client_mutex->lock ();
+   kill_me = true;
+   g_signal_handlers_disconnect_by_func (
+           query, 
+           (void *)hitsAddedSlot,
+           this);
+   g_signal_handlers_disconnect_by_func (
+           query,
+           (void *)finishedSlot,
+           this);
+   g_main_loop_quit (main_loop);
+   client_mutex->unlock ();
+}
+
+void BeagleSearchClient::hitsAddedSlot (BeagleQuery *query,
+                                        BeagleHitsAddedResponse *response,
+                                        BeagleSearchClient *bsclient)
+{
+    GSList *hits, *l;
+    gint    i;
+    gint    nr_hits;
+
+    // check if we are supposed to be killed
+    bsclient->client_mutex->lock ();
+    if (bsclient->kill_me) {
+        kdDebug () << "Suicide time before processing" << endl;
+	bsclient->client_mutex->unlock ();
+	return;
+    }
+    bsclient->client_mutex->unlock ();
+
+    hits = beagle_hits_added_response_get_hits (response);
+
+    nr_hits = g_slist_length (hits);
+    total_hits += nr_hits;
+    g_print ("Found hits (%d) at %ld:\n", nr_hits, time (NULL));
+
+    BeagleSearchResult *search_result;
+    if (! bsclient->collate_results)
+        search_result = new BeagleSearchResult (bsclient->id);
+    else
+        search_result = bsclient->result;
+    search_result->total += nr_hits;
+
+    for (l = hits, i = 1; l; l = l->next, ++i) {
+        //g_print ("[%d] ", i);
+        //print_hit (BEAGLE_HIT (l->data));
+        //g_print ("\n");
+
+        search_result->addHit(BEAGLE_HIT (l->data));//hit);
+    }
+    g_print ("[%ld] hits adding finished \n", time (NULL));
+
+    // check if we are supposed to be killed
+    bsclient->client_mutex->lock ();
+    if (bsclient->kill_me) {
+        kdDebug () << "Suicide time before sending ..." << endl;
+	bsclient->client_mutex->unlock ();
+	if (! bsclient->collate_results)
+	    delete search_result;
+	return;
+    }
+    bsclient->client_mutex->unlock ();
+
+    // time to send back results, if user asked so
+    if (bsclient->collate_results)
+        return;
+    QCustomEvent *ev =  new QCustomEvent (RESULTFOUND, search_result);
+    g_print ("[%ld] event notified \n", time (NULL));
+    QApplication::postEvent (bsclient->object, ev);
+}
+
+void BeagleSearchClient::finishedSlot (BeagleQuery *query,
+                                       BeagleFinishedResponse *response,
+                                       BeagleSearchClient *bsclient)
+{
+    // check if we are supposed to be killed
+    bsclient->client_mutex->lock ();
+    bool should_kill = bsclient->kill_me;
+    QObject* receiver = bsclient->object;
+    bsclient->client_mutex->unlock ();
+
+    if (should_kill)
+	return;
+
+    g_main_loop_quit (bsclient->main_loop);
+
+    if (bsclient->collate_results)
+        return; // if we are collating, everything will be send from a central place
+    if (receiver) {
+        QCustomEvent *ev =  new QCustomEvent (SEARCHOVER, bsclient);
+        g_print ("[%ld] query finish notified \n", time (NULL));
+        QApplication::postEvent (receiver, ev);
+    }
+}
+
+// ----------------- BeagleUtil -------------------
+
+BeagleQuery *
+BeagleUtil::createQueryFromString (QString query_str,
+                                    QStringList &sources_menu,
+                                    QStringList &types_menu,
+				    int max_hits_per_source)
+{
+    BeagleQuery *beagle_query = beagle_query_new ();
+    beagle_query_set_max_hits (beagle_query, max_hits_per_source); // this is per source!
+
+    kdDebug () << "Creating query from \"" << query_str << "\"" << endl;
+    for ( QStringList::Iterator it = sources_menu.begin(); it != sources_menu.end(); ++it )
+        beagle_query_add_source (beagle_query, g_strdup ((*it).utf8 ()));
+
+    for ( QStringList::Iterator it = types_menu.begin(); it != types_menu.end(); ++it )
+        beagle_query_add_hit_type (beagle_query, g_strdup ((*it).utf8 ()));
+
+    QStringList query_terms;
+    QString start_date, end_date;
+    QStringList words = QStringList::split (' ', query_str, false);
+    for ( QStringList::Iterator it = words.begin(); it != words.end(); ++it ) {
+        QStringList key_value_pair = QStringList::split ('=', *it, false);
+        if (key_value_pair.count () == 1)
+            query_terms += *it;
+        else if (key_value_pair.count () == 2) {
+            QString key = key_value_pair [0].lower ();
+            QString value = key_value_pair [1];
+            if (key == "mime")
+                beagle_query_add_mime_type (beagle_query, g_strdup (value.utf8 ()));
+            else if (key == "type")
+                beagle_query_add_hit_type (beagle_query, g_strdup (value.utf8 ()));
+            else if (key == "source")
+                beagle_query_add_source (beagle_query, g_strdup (value.utf8 ()));
+            else if (key == "start")
+                start_date = value;
+            else if (key == "end")
+                end_date = value;
+            else
+                query_terms += *it;
+        } else
+            query_terms += *it;
+    }
+
+    beagle_query_add_text (beagle_query, g_strdup (query_terms.join (" ").utf8 ()));
+    kdDebug () << "Adding query text:" << query_terms.join (" ").utf8 () << endl;
+
+    if (start_date.isNull () && end_date.isNull ())
+        return beagle_query;
+
+    //kdDebug () << "Handling dates ..." << endl;
+    BeagleQueryPartDate * date_part = beagle_query_part_date_new ();
+    if (! start_date.isNull ())
+        beagle_query_part_date_set_start_date (date_part, timestringToBeagleTimestamp (start_date));
+    if (! end_date.isNull ())
+        beagle_query_part_date_set_end_date (date_part, timestringToBeagleTimestamp (end_date));
+    beagle_query_add_part (beagle_query, BEAGLE_QUERY_PART (date_part));
+
+    return beagle_query;
+}
+
+// timestring format allowed YYYYmmDD
+BeagleTimestamp *
+BeagleUtil::timestringToBeagleTimestamp(QString timestring)
+{
+    //kdDebug () << "datetime string:" << timestring << endl;
+    // FIXME: error check timestring format
+    if (timestring.isNull () || timestring.stripWhiteSpace () == "" || timestring.length() != 8 )
+        return beagle_timestamp_new_from_unix_time (QDateTime::currentDateTime ().toTime_t ());
+    //QDateTime dt = QDateTime::fromString (timestring, Qt::ISODate);
+    struct tm tm_time;
+    time_t timet_time;
+    time (&timet_time);
+    localtime_r (&timet_time, &tm_time);
+    strptime (timestring.ascii(), "%Y%m%d", &tm_time);
+    tm_time.tm_sec = tm_time.tm_min = tm_time.tm_hour = 0;
+    //kdDebug() << asctime (&tm_time) << endl;
+    timet_time = mktime (&tm_time);
+    return beagle_timestamp_new_from_unix_time (timet_time);
+}
+
diff -Nurp kicker.orig/kicker/plugins/beaglesearch.h kicker/kicker/plugins/beaglesearch.h
--- kicker.orig/kicker/plugins/beaglesearch.h	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/plugins/beaglesearch.h	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,234 @@
+/*****************************************************************
+
+   Copyright (c) 2006 Debajyoti Bera <dbera.web@gmail.com>
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+
+******************************************************************/
+
+#ifndef BEAGLESEARCH_H
+#define BEAGLESEARCH_H
+
+#include <qdict.h>
+#include <qptrlist.h>
+#include <qthread.h>
+#include <qevent.h>
+#include <qmutex.h>
+
+#include <kdebug.h>
+#include <kurl.h>
+
+extern "C" {
+#include <glib.h>
+#include <beagle/beagle.h>
+}
+
+// BeagleSearchClient sends 3 types of events
+// when results are to be sent as they arrive,
+//  - RESULTFOUND : when result is found
+//  - SEARCHOVER :  when search is over
+//  - KILLME : just before thread finishes - used to cleanup the thread object
+// when results are to be sent after receiving all of them
+//  - RESULTFOUND : when all results are obtained
+//  - KILLME : just before thread finishes - used to cleanup the thread object
+#define RESULTFOUND (QEvent::Type)1001 /* QEvent::User + 1 */
+#define SEARCHOVER  (QEvent::Type)1002 /* QEvent::User + 2 */
+#define KILLME      (QEvent::Type)1003 /* QEvent::User + 3 */
+
+class QStringList;
+
+// IMPORTANT: Call this before any beagle calls
+void beagle_init ();
+
+class Hit {
+public:
+    Hit (BeagleHit *_hit);
+    ~Hit ();
+    
+    // convenience wrappers
+    // remember that the hit values are utf8 strings
+    const KURL getUri () const { return KURL (QString::fromUtf8 (beagle_hit_get_uri (hit)));}
+    const QString getType () const { return QString::fromUtf8 (beagle_hit_get_type (hit));}
+    const QString getMimeType () const { return QString::fromUtf8 (beagle_hit_get_mime_type (hit));}
+    const QString getSource () const { return QString::fromUtf8 (beagle_hit_get_source (hit));}
+    const KURL getParentUri () const { return KURL (QString::fromUtf8 (beagle_hit_get_parent_uri (hit)));}
+    const QDict<QStringList>& getAllProperties ()
+    {
+	if (! processed)
+	    processProperties ();
+	return property_map;
+    }
+    const QStringList* getProperties (QString prop_name)
+    {
+	if (! processed)
+	    processProperties ();
+	return property_map [prop_name];
+    }
+    const QString operator[] (QString prop_name);
+
+private:
+    BeagleHit *hit;
+    QDict<QStringList> property_map;
+    // not every hit may be used. so, do a lazy processing of property_map
+    bool processed;
+    void processProperties ();
+};
+
+class BeagleSearchResult{
+public:
+    BeagleSearchResult(int client_id);
+    ~BeagleSearchResult();
+    void addHit (BeagleHit *hit);
+    QString getHitCategory (Hit *hit);
+
+    // id of the bsclient
+    int client_id;
+    // time taken to finish query
+    int query_msec;
+    // total number of results in this query
+    int total;
+
+    const QPtrList<Hit> *getHits () const;
+
+private:
+    // lists of hits
+    QPtrList<Hit> *hitlist;
+};
+
+// caller should delete bsclient->result and bsclient
+class BeagleSearchClient : public QThread {
+public:
+    // passing NULL for client makes bsclient create client itself and
+    // delete it later
+    BeagleSearchClient (int id,
+                        QObject *y,
+                        BeagleClient *client,
+                        BeagleQuery *query,
+                        bool collate_results)
+    : id (id), kill_me (false), object (y), client (client),
+      query (query), destroy_client (false), collate_results (collate_results)
+    {
+        if (client == NULL) {
+	    client = beagle_client_new (NULL);
+            destroy_client = true;
+        }
+	
+//        if (client == NULL)
+//            throw -1;
+
+        main_loop = g_main_loop_new (NULL, FALSE);
+        if (collate_results)
+            result = new BeagleSearchResult (id);
+
+	client_mutex = new QMutex ();
+    }
+
+    // It is never safe to delete BeagleSearchClient directly, the thread might still be running
+    ~BeagleSearchClient ()
+    {
+	if (! finished ()) {
+	    kdDebug () << "Thread " << id << " still running. Waiting.........." << endl;
+	    wait ();
+	}
+
+        if (destroy_client)
+            g_object_unref (client);
+        g_main_loop_unref (main_loop);
+        g_object_unref (query);
+        kdDebug() << "Deleting client ..." << id << endl;
+	delete client_mutex;
+    }
+
+private:
+    static void hitsAddedSlot (BeagleQuery *query,
+                               BeagleHitsAddedResponse *response,
+                               BeagleSearchClient *bsclient);
+
+    static void finishedSlot (BeagleQuery  *query,
+                              BeagleFinishedResponse *response,
+                              BeagleSearchClient *bsclient);
+
+public:
+    // run() starts the query and sends the result as follows:
+    // - either wait till get back all results and send it as RESULTFOUND
+    // - or, send results as it gets them as RESULTFOUND and 
+    //       send SEARCHOVER when finished
+    // collate_results controls the behaviour
+    virtual void run ( );
+    
+    // after stopClient() is called, application can safely go and remove previous menu entries
+    // - i.e. after stopClient is called, app doesnt except the eventhandler to receive any results
+    // - use client_id to determine which is the current client, set it right after stopclient
+    // - Eventhandler checks client id, if it is current, it adds stuff to the menu
+    //   else, it discards everything
+    // Once eventhandler is being processed, doQuery() wont be called and vice versa
+    //   so no need to serialize eventhandler and doquery
+    //
+    // stopClient needs to make sure that once it is called, the thread is finished asap. Use a mutex
+    // to serialize actions. callbacks need to use mutex too.
+    // stopclient has to remove signal handlers to prevent further signal calls, set kill_me flag
+    //   and quite main loop
+    // stopClient can be called at the following times:
+    // - Waiting for the first result:
+    //   nothing extra
+    // - in hitsAddedSlot, processing results
+    //   in callback, before processing, if killme is set, just return.
+    // - in hitsAddedSlot, after sending results
+    //   before sending, if killme is set, dont send results
+    //   (doing it twice in hitsAdded because forming BeagleSearchResult can take time)
+    // - Waiting for more results
+    //   nothing extra
+    // - in finishedSlot, before sending finishedMsg
+    //   if killme is set, just return
+    // - in finishedSlot, after sending finishedMsg
+    //   if killme is set, just return
+    //  in Run(), when return from mainloop, if killme is set, dont do anything more but call delete this
+    void stopClient ();
+
+    // id of the client
+    // this is required in case applications fires many clients in rapid succession
+    int id;
+    
+    GMainLoop * main_loop;
+    BeagleSearchResult *result;
+    
+    // this is set if the client is obsolete now i.e.
+    // the application doesnt need the results from the client anymore
+    bool kill_me;
+private:
+    // the application; need this to send events to the application
+    QObject *object;
+    // mutex to control setting the kill_me shared variable
+    QMutex *client_mutex;
+    BeagleClient *client;
+    BeagleQuery *query;
+    // should the client be destroyed by the client
+    // if the client created it, then most probably it should
+    bool destroy_client;
+    bool collate_results;
+};
+
+class BeagleUtil {
+public:
+
+    static BeagleQuery *createQueryFromString (QString query_str,
+					       QStringList &sources,
+                                               QStringList &types,
+					       int max_hits_per_source = 100);
+    static BeagleTimestamp *timestringToBeagleTimestamp (QString timestring);
+};
+
+#endif
diff -Nurp kicker.orig/kicker/plugins/kickoff-beagle-plugin.cpp kicker/kicker/plugins/kickoff-beagle-plugin.cpp
--- kicker.orig/kicker/plugins/kickoff-beagle-plugin.cpp	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/plugins/kickoff-beagle-plugin.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,499 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Stephan Binner <binner@kde.org>                 *
+ *   Copyright (c) 2006 Debajyoti Bera <dbera.web@gmail.com>               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
+ ***************************************************************************/
+
+#include "kickoff-beagle-plugin.h"
+
+#include <qregexp.h>
+#include <qtimer.h>
+
+#include <kapplication.h>
+#include <kdesktopfile.h>
+#include <kgenericfactory.h>
+#include <kservice.h>
+
+QString dc_identifier = "dc:identifier";
+QString dc_title = "dc:title";
+QString parent_dc_title = "parent:dc:title";
+QString exactfilename = "beagle:ExactFilename";
+QString fixme_name = "fixme:Name";
+QString beagle_filename = "beagle:Filename";
+QString fixme_attachment_title = "fixme:attachment_title";
+QString fixme_hasattachments = "fixme:hasAttachments";
+QString parent_prefix = "parent:";
+QString fixme_folder = "fixme:folder";
+QString fixme_categories = "fixme:Categories";
+QString fixme_comment = "fixme:Comment";
+QString fixme_width = "fixme:width";
+QString fixme_height = "fixme:height";
+QString fixme_from_address = "fixme:from_address";
+QString fixme_artist = "fixme:artist";
+QString fixme_album = "fixme:album";
+QString dc_source = "dc:source";
+QString dc_publisher = "dc:publisher";
+QString digikam_tag = "digikam:Tag";
+QString fixme_speakingto = "fixme:speakingto";
+QString fixme_starttime = "fixme:starttime";
+QString comma_string = ",";
+QString vCard_FN = "vCard:FN";
+QString vCard_PREFEMAIL = "vCard:PREFEMAIL";
+QString fixme_uid = "fixme:uid";
+
+static CATEGORY getHitCategory (Hit *hit)
+{
+    QString hittype = hit->getType();
+    QString hitsource = hit->getSource();
+
+    // if hit source is None, dont handle it. Might be anthrax-envelope :)
+    if (hitsource.isNull())
+        return OTHER;
+
+    if (hitsource == "documentation")
+        return DOCS;
+
+    if (hittype == "IMLog")
+        return CHATS;
+
+    // sure shots
+    if (hittype == "FeedItem")
+        return FEEDS;
+    if (hittype == "WebHistory")
+        return WEBHIST;
+    if (hittype == "MailMessage")
+        return MAILS;
+    if (hittype == "Note")
+        return NOTES;
+
+    // check for applications
+    if (hittype == "File" && (*hit) ["beagle:FilenameExtension"] == ".desktop")
+        return APPS;
+
+    // check for music
+    QString hitmimetype = hit->getMimeType();
+    if (hitsource == "Amarok"
+        || hitmimetype.startsWith ("audio")
+        || hitmimetype == "application/ogg")
+        return MUSIC; // not an exhaustive search
+
+    // check for images from files
+    if (hitsource == "Files" && hitmimetype.startsWith ("image"))
+        return PICS;
+
+    if (hitsource == "Files" && hitmimetype.startsWith ("video"))
+        return VIDEOS;
+
+    if (hitsource == "Files")
+        return FILES;
+
+    if (hitsource == "KAddressBook")
+        return ACTIONS;
+
+    return OTHER;
+}
+
+K_EXPORT_COMPONENT_FACTORY( kickoffsearch_beagle,
+                            KGenericFactory<KickoffBeaglePlugin>( "kickoffsearch_beagle" ) )
+
+KickoffBeaglePlugin::KickoffBeaglePlugin(QObject *parent, const char* name, const QStringList&)
+            : KickoffSearch::Plugin(parent, name ), genericTitle( true )
+{
+    g_type_init ();
+    current_beagle_client = NULL;
+}
+
+bool KickoffBeaglePlugin::daemonRunning()
+{
+    return beagle_util_daemon_is_running();
+}
+
+void KickoffBeaglePlugin::query(QString term, bool _genericTitle)
+{
+    genericTitle = _genericTitle;
+    current_query_str = term;
+
+    // Beagle search
+    if (current_beagle_client != NULL) {
+	kdDebug () << "Previous client w/id " << current_beagle_client->id << " still running ... ignoring it." << endl;
+	current_beagle_client->stopClient ();
+    }
+    current_beagle_client_id = KApplication::random ();
+    kdDebug () << "Creating client with id:" << current_beagle_client_id << endl;
+
+    BeagleClient *beagle_client = beagle_client_new (NULL);
+    if (beagle_client == NULL) {
+        kdDebug() << "beagle service not running ..." << endl;
+        return;
+    }
+
+    QStringList sources, types;
+    BeagleQuery *beagle_query = BeagleUtil::createQueryFromString (term, sources, types, 99); // maximum 99 results, if this doesnt work, blame the stars
+
+    current_beagle_client = new BeagleSearchClient (
+                                current_beagle_client_id,
+                                this,
+                                beagle_client,
+                                beagle_query,
+                                false);
+    current_beagle_client->start();
+//    kdDebug () << "Query dispatched at " << time (NULL) << endl;
+}
+
+void KickoffBeaglePlugin::cleanClientList ()
+{
+    toclean_list_mutex.lock ();
+    BeagleSearchClient *old_client = toclean_client_list.take (0);
+    if (old_client != NULL) { // failsafe
+	kdDebug () << "Cleanup old client " << old_client->id << endl;
+	delete old_client;
+    }
+    toclean_list_mutex.unlock ();
+}
+
+void KickoffBeaglePlugin::customEvent (QCustomEvent *e)
+{
+    if (e->type () == RESULTFOUND) {
+//        kdDebug () << "Quick query thread at " << time (NULL) << " with current_id=" << current_beagle_client_id <<  " finished ..." << endl;
+        BeagleSearchResult *result = (BeagleSearchResult *) e->data ();
+        if (current_beagle_client_id != result->client_id) {
+            kdDebug () << "Stale result from " << result->client_id << endl;
+	    delete result;
+	    // FIXME: Should I also free e ?
+        } else {
+            kdDebug () << "Good results ...total=" << result->total << endl;
+            showResults (result);
+        }
+        //KPassivePopup::message( "This is the message", this );
+    } else if (e->type () == SEARCHOVER) {
+        BeagleSearchClient *client = (BeagleSearchClient *) e->data ();
+	if (client == NULL) {
+//	    kdDebug () << "Query finished event at " << time (NULL) << " but client is already deleted" << endl;
+	    return;
+	}
+//        kdDebug () << "Query finished event at " << time (NULL) << " for id=" << client->id << endl;
+	if (current_beagle_client_id == client->id) {
+	    kickoffSearchInterface()->searchOver();
+ 	    current_beagle_client = NULL; // important !
+	}
+    } else if (e->type () == KILLME) {
+        BeagleSearchClient *client = (BeagleSearchClient *) e->data ();
+	if (client->finished ())
+	    delete client;
+	else {
+	    // add client to cleanup list
+	    toclean_list_mutex.lock ();
+	    toclean_client_list.append (client);
+	    kdDebug () << "Scheduling client to be deleted in 500ms" << endl;
+	    toclean_list_mutex.unlock ();
+	    QTimer::singleShot (500, this, SLOT (cleanClientList ()));
+	}
+    }
+}
+
+// this method decides what to display in the result list
+HitMenuItem *KickoffBeaglePlugin::hitToHitMenuItem (int category, Hit *hit)
+{
+    QString title, info, mimetype, icon;
+    int score = 0;
+    KURL uri;
+
+#if 0
+    kdDebug() << "*** " << hit->getUri() << endl;
+    QDict<QStringList> all = hit->getAllProperties();
+    QDictIterator<QStringList> it( all );
+    for( ; it.current(); ++it )
+        kdDebug() << it.currentKey() << ": " << *(it.current()) << endl;
+#endif
+
+    switch (category) {
+	case FILES:
+	    {
+		uri = hit->getUri ();
+		QString uristr = uri.path ();
+	    	title = (*hit) [exactfilename];
+	    	int last_slash = uristr.findRev ('/', -1);
+                info = i18n("Folder: %1").arg(last_slash == 0 ? "/" 
+                        : uristr.section ('/', -2, -2));
+	    }
+	    break;
+        case ACTIONS:
+            {
+                if (hit->getSource()=="KAddressBook"){
+		    title = i18n("Send Email to %1").arg((*hit)[vCard_FN]);
+		    info = (*hit)[vCard_PREFEMAIL];
+		    uri = "mailto:"+(*hit)[vCard_PREFEMAIL];
+		    mimetype = hit->getMimeType ();
+		    icon = "mail_new";
+
+		    HitMenuItem * first_item=new HitMenuItem (title, info, uri, mimetype, 0, category, icon, score);
+		    kickoffSearchInterface()->addHitMenuItem(first_item);
+
+		    title =i18n("Open Addressbook at %1").arg((*hit)[vCard_FN]);
+		    uri = "kaddressbook:/"+(*hit)[fixme_uid];
+		    icon = "kaddressbook";
+                }
+                break;
+            }
+	case MAILS:
+	    {
+		QString prefix = QString::null;
+		bool is_attachment = ((*hit) [parent_prefix + fixme_hasattachments] == "true");
+		bool has_parent = (! hit->getParentUri ().isEmpty ());
+		bool parent_mbox_file = false;
+		if (has_parent)
+		    parent_mbox_file = ((*hit) [parent_prefix + fixme_folder] == QString::null);
+
+		// Logic:
+		// If has_parent == false, everything is normal
+		// If has_parent == true, parent_mbox_file == false, everything is normal, use uri
+		// FIXME: If has_parent == true, parent_mbox_file == true, ???
+		// If has_parent == true, is_attachment == true, hit is attach and access with prefix "parent:", use parenturi
+		// Else, not attachment (multipart), access with prefix "parent:", use parenturi
+
+		if (has_parent && !parent_mbox_file) {
+		    uri = hit->getParentUri ();
+		    prefix = parent_prefix;
+		    if (is_attachment)
+			title = (*hit) [fixme_attachment_title];
+		    if (title.isEmpty ())
+			title = (*hit) [prefix + dc_title];
+		    if (title.isEmpty ())
+			title = i18n("No subject");
+		    if (is_attachment)
+			title = title.prepend (i18n("(Attachment) "));
+		    info = (i18n("From %1").arg((*hit) [prefix + fixme_from_address]));
+		} else {
+		    uri = hit->getUri ();
+		    title = (*hit) [dc_title];
+		    info = (i18n("From %1").arg((*hit) [fixme_from_address]));
+		}
+	    }
+	    mimetype = "message/rfc822"; // to handle attachment results
+	    break;
+ 	case MUSIC:
+	    uri = hit->getUri ();
+	    title = (*hit) [exactfilename];
+	    {
+		QString artist = (*hit) [fixme_artist];
+		QString album = (*hit) [fixme_album];
+		if (! artist.isEmpty ())
+		    info = (i18n("By %1").arg(artist));
+		else if (! album.isEmpty ())
+		    info = (i18n("From Album %1").arg(album));
+		else {
+		    QString uristr = uri.path ();
+		    int last_slash = uristr.findRev ('/', -1);
+                    info = i18n("Folder: %1")
+                        .arg(last_slash == 0 ? "/" : uristr.section ('/', -2, -2));
+		}
+	    }
+	    break;
+ 	case VIDEOS:
+	    uri = hit->getUri ();
+	    title = (*hit) [exactfilename];
+	    {
+		QString uristr = uri.path ();
+		int last_slash = uristr.findRev ('/', -1);
+                info = i18n("Folder: %1").arg(last_slash == 0 ? "/" : uristr.section ('/', -2, -2));
+	    }
+	    break;
+	case WEBHIST:
+	    uri = hit->getUri ();
+	    title = (*hit) [dc_title];
+	    title = title.replace(QRegExp("\n")," ");
+	    mimetype = "text/html";
+	    if (title.isEmpty () || title.stripWhiteSpace ().isEmpty ()) {
+		title = uri.prettyURL ();
+	    } else {
+		info = uri.host () + uri.path ();
+	    }
+	    break;
+	case FEEDS:
+	    {
+		uri = KURL ((*hit) [dc_identifier]);
+	    	title = (*hit) [dc_title];
+	    	mimetype = "text/html";
+	    	QString publisher = (*hit) [dc_publisher];
+	    	QString source = (*hit) [dc_source];
+	    	if (! publisher.isEmpty ())
+	    	    info = publisher;
+	    	else if (! source.isEmpty ())
+	    	    info = source;
+	    }
+	    break;
+	case PICS:
+	    {
+		uri = hit->getUri ();
+		title = (*hit) [exactfilename];
+		QString width = (*hit) [fixme_width];
+		QString height = (*hit) [fixme_height];
+		if (width.isEmpty () || height.isEmpty ()) {
+		    QString uristr = uri.path ();
+		    int last_slash = uristr.findRev ('/', -1);
+                    info = i18n("Folder: %1")
+                        .arg(last_slash == 0 ? "/" : uristr.section ('/', -2, -2));
+		    break;
+		}
+		info = (QString (" (%1x%2)").arg (width).arg (height));
+		const QStringList *tags = hit->getProperties (digikam_tag);
+		if (tags == NULL)
+		    break;
+		QString tags_string = tags->join (comma_string);
+		info += (" " + tags_string);
+	    }
+	    break;
+	case APPS:
+	    {
+		uri = hit->getUri ();
+	    	title = (*hit) [dc_title];
+		KDesktopFile desktopfile(uri.path(),true);
+		if (genericTitle && !desktopfile.readGenericName().isEmpty()) {
+		  title = desktopfile.readGenericName();
+		  info = desktopfile.readName();
+		}
+		else {
+		  title = desktopfile.readName();
+		  info = desktopfile.readGenericName();
+		}
+		icon = desktopfile.readIcon();
+                QString input = current_query_str.lower();
+		QString command = desktopfile.readEntry("Exec");
+		if (command==input)
+                  score = 100;
+                else if (command.find(input)==0)
+                  score = 50;
+                else if (command.find(input)!=-1)
+                  score = 10;
+		else if (title==input)
+                  score = 100;
+                else if (title.find(input)==0)
+                  score = 50;
+                else if (title.find(input)!=-1)
+                  score = 10;
+	    	break;
+	    }
+	    break;
+	case NOTES:
+            {
+	        uri = hit->getUri ();
+	        title = (*hit) [dc_title];
+	        title = i18n("Title: %1").arg(title.isEmpty() ? i18n("Untitled") : title);
+
+	        if (hit->getSource()=="KNotes")
+                   icon="knotes";
+                else
+                   icon="contents2";
+            }
+	    break;
+	case CHATS:
+            {
+	        uri = hit->getUri ();
+	        title = (*hit) [fixme_speakingto];
+	        title = i18n("Conversation With %1").arg(title.isEmpty() ? i18n("Unknown Person") : title);
+	        QDateTime datetime;
+	        datetime = datetimeFromString((*hit) [fixme_starttime]);
+                info=i18n("Date: %1").arg(KGlobal::locale()->formatDateTime(datetime,false));
+	        if (hit->getMimeType()=="beagle/x-kopete-log")
+                   icon="kopete";
+                else
+                   icon="gaim";
+            }
+	    break;
+	case DOCS:
+	    {
+		uri = hit->getUri ();
+		title = (*hit) [dc_title];
+		if (title.isEmpty () || title.stripWhiteSpace ().isEmpty ())
+		    title = uri.prettyURL ();
+		else {
+			QString uristr = uri.path ();
+			int last_slash = uristr.findRev ('/', -1);
+                        info = i18n("Folder: %1").arg(last_slash == 0 ? "/" : uristr.section ('/',
+                                    -2, -2));
+		}
+	    }
+	    break;
+	default:
+	    return NULL;
+    }
+    if (mimetype.isEmpty ())
+	mimetype = hit->getMimeType ();
+    return new HitMenuItem (title, info, uri, mimetype, 0, category, icon, score);
+}
+
+void KickoffBeaglePlugin::showResults(BeagleSearchResult *result)
+{
+    if (result->total == 0 ) {
+	// Dont report error from here ...
+        kdDebug() << "No matches found" << endl;
+	delete result;
+	return;
+    }
+
+    const QPtrList<Hit> *hits = result->getHits();
+    if (hits == NULL) {
+        kdDebug () << "Hmm... null" << endl;
+	delete result;
+        return;
+    }
+    kickoffSearchInterface()->initCategoryTitlesUpdate();
+
+    QPtrListIterator<Hit> it (*hits);
+    Hit *hit;
+    for (; (hit = it.current ()) != NULL; ++it) {
+	CATEGORY category = getHitCategory (hit);
+
+	// if category is not handled, continue
+	if (category == OTHER)
+          continue;
+
+        if ( category == APPS ) {
+            // we need to check if this is useful
+            KService cs( hit->getUri().path() );
+            if ( cs.noDisplay() )
+                continue;
+        }
+
+        if (!kickoffSearchInterface()->anotherHitMenuItemAllowed(category))
+          continue;
+
+        HitMenuItem *hit_item = hitToHitMenuItem (category, hit);
+
+        if (!hit_item)
+	   continue;
+
+        kickoffSearchInterface()->addHitMenuItem(hit_item);
+    }
+
+    kickoffSearchInterface()->updateCategoryTitles();
+
+    delete result;
+}
+
+QDateTime KickoffBeaglePlugin::datetimeFromString( const QString& s)
+{
+      int year( s.mid( 0, 4 ).toInt() );
+      int month( s.mid( 4, 2 ).toInt() );
+      int day( s.mid( 6, 2 ).toInt() );
+      int hour( s.mid( 8, 2 ).toInt() );
+      int min( s.mid( 10, 2 ).toInt() );
+      int sec( s.mid( 12, 2 ).toInt() );
+      return QDateTime(QDate(year,month,day),QTime(hour,min,sec));
+}
+
+#include "kickoff-beagle-plugin.moc"
diff -Nurp kicker.orig/kicker/plugins/kickoff-beagle-plugin.h kicker/kicker/plugins/kickoff-beagle-plugin.h
--- kicker.orig/kicker/plugins/kickoff-beagle-plugin.h	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/plugins/kickoff-beagle-plugin.h	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,64 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Stephan Binner <binner@kde.org>                 *
+ *   Copyright (c) 2006 Debajyoti Bera <dbera.web@gmail.com>               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
+ ***************************************************************************/
+
+#ifndef CAPITALIZEPLUGIN_H
+#define CAPITALIZEPLUGIN_H
+
+#include "../interfaces/kickoff-search-plugin.h"
+#include "beaglesearch.h"
+
+class KickoffBeaglePlugin :public KickoffSearch::Plugin
+{
+    Q_OBJECT
+
+public:
+    KickoffBeaglePlugin(QObject *parent, const char* name, const QStringList&);
+
+    void query(QString, bool);
+    bool daemonRunning();
+
+protected slots:
+    // to clean beaglesearchclients
+    void cleanClientList ();
+
+private:
+    QString current_query_str;
+
+    // all beagle activity is done through the BSC object
+    BeagleSearchClient *current_beagle_client;
+
+    // used to send notification from the beagle thread to the main event loop
+    virtual void customEvent (QCustomEvent *e);
+
+    QPtrList<BeagleSearchClient> toclean_client_list;
+    QMutex toclean_list_mutex;
+
+    // show the results
+    void showResults (BeagleSearchResult *);
+    HitMenuItem *hitToHitMenuItem (int category, Hit *hit);
+
+    // use a different id for each bsc client, and use that to separate stale responses from current ones
+    int current_beagle_client_id;
+
+    bool genericTitle;
+    QDateTime datetimeFromString( const QString& );
+};
+
+#endif /* CAPITALIZEPLUGIN_H */
diff -Nurp kicker.orig/kicker/plugins/kickoffsearch_beagle.desktop kicker/kicker/plugins/kickoffsearch_beagle.desktop
--- kicker.orig/kicker/plugins/kickoffsearch_beagle.desktop	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/plugins/kickoffsearch_beagle.desktop	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,6 @@
+[Desktop Entry]
+Name=Beagle Search
+Comment=Beagle search plugin for Kickoff search
+ServiceTypes=KickoffSearch/Plugin
+Type=Service
+X-KDE-Library=kickoffsearch_beagle
diff -Nurp kicker.orig/kicker/plugins/Makefile.am kicker/kicker/plugins/Makefile.am
--- kicker.orig/kicker/plugins/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/plugins/Makefile.am	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,24 @@
+INCLUDES    = -I$(top_srcdir)/interfaces $(all_includes) $(LIBBEAGLE_CFLAGS) $(GLIB_CFLAGS)
+METASOURCES = AUTO
+
+# Install this plugin in the KDE modules directory
+kde_module_LTLIBRARIES = kickoffsearch_beagle.la
+
+# Srcs for the plugin
+kickoffsearch_beagle_la_SOURCES = kickoff-beagle-plugin.cpp beaglesearch.cpp
+
+# Libs needed by the plugin
+kickoffsearch_beagle_la_LIBADD = $(LIB_KPARTS) ../interfaces/libkickoffsearch_interfaces.la \
+	$(LIBBEAGLE_LIBADD) $(GLIB_LIBADD)
+
+# LD flags for the plugin
+# -module says: this is a module, i.e. something you're going to dlopen
+# so e.g. it has no version number like a normal shared lib would have.
+kickoffsearch_beagle_la_LDFLAGS = -module $(KDE_PLUGIN) $(all_libraries)
+
+# Install the desktop file needed to detect the plugin
+kde_services_DATA = kickoffsearch_beagle.desktop
+
+# i18n translation messages
+messages: rc.cpp
+	$(XGETTEXT) *.cpp *.h -o $(podir)/kickoffsearch_beagle.pot
diff -Nurp kicker.orig/kicker/ui/addappletvisualfeedback.cpp kicker/kicker/ui/addappletvisualfeedback.cpp
--- kicker.orig/kicker/ui/addappletvisualfeedback.cpp	2006-10-01 17:31:52.000000000 +0000
+++ kicker/kicker/ui/addappletvisualfeedback.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -51,6 +51,7 @@ AddAppletVisualFeedback::AddAppletVisual
       m_richText(0),
       m_dissolveDelta(-1),
       m_frames(1),
+      m_moveTimer(0, "m_moveTimer"),
       m_dirty(false)
 {
     setFocusPolicy(NoFocus);
diff -Nurp kicker.orig/kicker/ui/appletop_mnu.cpp kicker/kicker/ui/appletop_mnu.cpp
--- kicker.orig/kicker/ui/appletop_mnu.cpp	2005-09-10 08:25:31.000000000 +0000
+++ kicker/kicker/ui/appletop_mnu.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -30,6 +30,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE 
 #include "appletop_mnu.h"
 #include "container_button.h"
 #include "containerarea.h"
+#include "kickerSettings.h"
 
 PanelAppletOpMenu::PanelAppletOpMenu(int actions, QPopupMenu *opMenu, const QPopupMenu* appletsMenu,
                                      const QString & title, const QString &icon,
@@ -159,6 +160,20 @@ PanelAppletOpMenu::PanelAppletOpMenu(int
         }
     }
 
+    if ((actions & PanelAppletOpMenu::KMenuEditor))
+    {
+        if (needSeparator)
+        {
+            insertSeparator();
+            needSeparator = false;
+        }
+
+        if (KickerSettings::legacyKMenu()) 
+          insertItem(SmallIcon("suse"), i18n("Switch to SUSE Menu Style"), this, SLOT(toggleLegacy()));
+        else
+          insertItem(SmallIcon("about_kde"), i18n("Switch to KDE Menu Style"), this, SLOT(toggleLegacy()));
+    }
+
     if ((actions & PanelAppletOpMenu::KMenuEditor) && kapp->authorizeKAction("menuedit"))
     {
         if (needSeparator)
@@ -205,4 +220,11 @@ void PanelAppletOpMenu::keyPressEvent(QK
     QPopupMenu::keyPressEvent(e);
 }
 
+void PanelAppletOpMenu::toggleLegacy()
+{
+    KickerSettings::setLegacyKMenu(!KickerSettings::legacyKMenu());
+    KickerSettings::writeConfig();
+    Kicker::the()->restart();
+}
+
 #include "appletop_mnu.moc"
diff -Nurp kicker.orig/kicker/ui/appletop_mnu.h kicker/kicker/ui/appletop_mnu.h
--- kicker.orig/kicker/ui/appletop_mnu.h	2005-09-10 08:25:31.000000000 +0000
+++ kicker/kicker/ui/appletop_mnu.h	2008-09-17 15:14:41.000000000 +0000
@@ -47,6 +47,9 @@ public:
 signals:
     void escapePressed();
 
+protected slots:
+    void toggleLegacy();
+
 protected:
     void keyPressEvent(QKeyEvent* e);
 };
diff -Nurp kicker.orig/kicker/ui/browser_mnu.cpp kicker/kicker/ui/browser_mnu.cpp
--- kicker.orig/kicker/ui/browser_mnu.cpp	2007-01-15 11:31:30.000000000 +0000
+++ kicker/kicker/ui/browser_mnu.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -329,7 +329,7 @@ void PanelBrowserMenu::initialize()
     if(_mimemap.count() > 0) {
 
         if(!_mimecheckTimer)
-            _mimecheckTimer = new QTimer(this);
+            _mimecheckTimer = new QTimer(this, "_mimecheckTimer");
 
         connect(_mimecheckTimer, SIGNAL(timeout()), SLOT(slotMimeCheck()));
         _mimecheckTimer->start(0);
diff -Nurp kicker.orig/kicker/ui/default-favs kicker/kicker/ui/default-favs
--- kicker.orig/kicker/ui/default-favs	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/ui/default-favs	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,9 @@
+MozillaFirefox.desktop
+kde-Kontact.desktop
+writer.desktop
+kde-amarok.desktop
+kde-digikam.desktop
+kde-Home.desktop
+kde-KControl.desktop
+kde-Help.desktop
+kde-konsole.desktop
diff -Nurp kicker.orig/kicker/ui/flipscrollview.cpp kicker/kicker/ui/flipscrollview.cpp
--- kicker.orig/kicker/ui/flipscrollview.cpp	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/ui/flipscrollview.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,324 @@
+/*****************************************************************
+
+Copyright (c) 2006 Will Stephenson <wstephenson@novell.com>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#include <qapplication.h>
+#include <qhbox.h>
+#include <qheader.h>
+#include <assert.h>
+
+#include "itemview.h"
+#include "flipscrollview.h"
+#include "kickerSettings.h"
+
+/* Flip scroll steps, as percentage of itemview width to scroll per
+ * step.  Assumes the itemview is scrolled in ten steps */
+
+/* slow start, then fast */
+//static const double scrollSteps[] = { 0.05, 0.05, 0.1125, 0.1125, 0.1125, 0.1125, 0.1125, 0.1125, 0.1125, 0.1125 };
+
+/* slow fast slow */
+//static const double scrollSteps[] = { 0.05, 0.05, 0.13, 0.13, 0.15, 0.13, 0.13, 0.13, 0.05, 0.05 };
+
+/* slow veryfast slow */
+static const double scrollSteps[] = { 0.03, 0.03, 0.147, 0.147, 0.147, 0.147, 0.147, 0.147, 0.03, 0.028 };
+;
+
+BackFrame::BackFrame( QWidget *parent )
+    : QFrame( parent ), mouse_inside( false )
+{
+    setFrameStyle( QFrame::NoFrame );
+    if ( QApplication::reverseLayout() )
+        left_triangle.load( locate( "data", "kicker/pics/right_triangle.png" ) );
+    else
+        left_triangle.load( locate( "data", "kicker/pics/left_triangle.png" ) );
+}
+
+void BackFrame::drawContents( QPainter *p )
+{
+    QColor gray( 230, 230, 230 );
+    if ( mouse_inside )
+        p->fillRect( 3, 3, width() - 6, height() - 6, colorGroup().color( QColorGroup::Highlight ) );
+    else
+        p->fillRect( 3, 3, width() - 6, height() - 6, gray );
+    p->setPen( gray.dark(110) );
+    p->drawRect( 3, 3, width() - 6, height() - 6 );
+
+    int pixsize = ( width() - 6 ) * 3 / 5;
+    QImage i = left_triangle.convertToImage().smoothScale( pixsize, pixsize );
+    QPixmap tri;
+    tri.convertFromImage( i );
+
+    p->drawPixmap( ( width() - tri.width() ) / 2, ( height() - tri.height() ) / 2, tri );
+}
+
+void BackFrame::enterEvent( QEvent *e )
+{
+    mouse_inside = true;
+    update();
+}
+
+void BackFrame::leaveEvent( QEvent *e )
+{
+    mouse_inside = false;
+    update();
+}
+
+void BackFrame::mousePressEvent ( QMouseEvent * e )
+{
+    emit clicked();
+}
+
+FlipScrollView::FlipScrollView( QWidget * parent, const char * name )
+    : QScrollView( parent, name ), mState( StoppedLeft ), mScrollDirection( 1 ), mShowBack( false )
+{
+    setVScrollBarMode( QScrollView::AlwaysOff );
+    setHScrollBarMode( QScrollView::AlwaysOff );
+    setFrameStyle( QFrame::NoFrame );
+    mLeftView = new ItemView( this, "left_view" );
+    addChild( mLeftView );
+
+    mRightView = new ItemView( this, "right_view" );
+    addChild( mRightView );
+
+    mTimer = new QTimer( this, "mTimer" );
+    connect( mTimer, SIGNAL( timeout() ), SLOT( slotScrollTimer() ) );
+
+    connect( mLeftView, SIGNAL( startService(KService::Ptr) ),
+             SIGNAL( startService(KService::Ptr) ) );
+    connect( mLeftView, SIGNAL( startURL(const QString& ) ),
+             SIGNAL( startURL(const QString& ) ) );
+    connect( mLeftView, SIGNAL( rightButtonPressed(QListViewItem*,const QPoint&,int) ),
+             SIGNAL( rightButtonPressed(QListViewItem*,const QPoint&,int) ) );
+    connect( mRightView, SIGNAL( startService(KService::Ptr) ),
+             SIGNAL( startService(KService::Ptr) ) );
+    connect( mRightView, SIGNAL( startURL(const QString& ) ),
+             SIGNAL( startURL(const QString& ) ) );
+    connect( mRightView, SIGNAL( rightButtonPressed(QListViewItem*,const QPoint&,int) ),
+             SIGNAL( rightButtonPressed(QListViewItem*,const QPoint&,int) ) );
+
+    // wild hack to make sure it has correct width
+    mLeftView->setVScrollBarMode( QScrollView::AlwaysOn );
+    mRightView->setVScrollBarMode( QScrollView::AlwaysOn );
+    mLeftView->setVScrollBarMode( QScrollView::Auto );
+    mRightView->setVScrollBarMode( QScrollView::Auto );
+
+    mBackrow = new BackFrame( this );
+    mBackrow->resize( 24, 100 );
+    connect( mBackrow, SIGNAL( clicked() ), SIGNAL( backButtonClicked() ) );
+}
+
+ItemView* FlipScrollView::prepareRightMove()
+{
+    if ( mState != StoppedLeft )
+    {
+        mTimer->stop();
+        ItemView *swap = mLeftView;
+        mLeftView = mRightView;
+        mRightView = swap;
+        moveChild( mLeftView, 0, 0 );
+        moveChild( mRightView, width(), 0 );
+        mBackrow->hide();
+        mRightView->resize( width(), height() );
+        mLeftView->resize( width(), height() );
+        setContentsPos( 0, 0 );
+    }
+
+    mState = StoppedLeft;
+    mRightView->clear();
+    return mRightView;
+}
+
+void FlipScrollView::showBackButton( bool enable )
+{
+    kdDebug() << "FlipScrollView::showBackButton " << enable << endl;
+    mShowBack = enable;
+}
+
+ItemView* FlipScrollView::prepareLeftMove(bool clear)
+{
+    if ( mState != StoppedRight )
+    {
+        mTimer->stop();
+        ItemView *swap = mLeftView;
+        mLeftView = mRightView;
+        mRightView = swap;
+        moveChild( mLeftView, 0, 0 );
+        moveChild( mRightView, width(), 0 );
+        mRightView->resize( width(), height() );
+        mLeftView->resize( width(), height() );
+        mBackrow->hide();
+        setContentsPos( width(), 0 );
+    }
+
+    mState = StoppedRight;
+    if (clear)
+        mLeftView->clear();
+    return mLeftView;
+}
+
+void FlipScrollView::viewportResizeEvent ( QResizeEvent * )
+{
+    mLeftView->resize( size() );
+    mRightView->resize( width() - mBackrow->width(), height() );
+    mBackrow->resize( mBackrow->width(), height() );
+    resizeContents( width() * 2, height() );
+    moveChild( mBackrow, width(), 0 );
+    moveChild( mRightView, width() + mBackrow->width(), 0 );
+    setContentsPos( 0, 0 );
+}
+
+ItemView *FlipScrollView::currentView() const
+{
+    if ( mState == StoppedRight )
+        return mRightView;
+    else
+        return mLeftView;
+}
+
+ItemView *FlipScrollView::leftView() const
+{
+    return mLeftView;
+}
+
+ItemView *FlipScrollView::rightView() const
+{
+    return mRightView;
+}
+
+FlipScrollView::~FlipScrollView() {}
+
+static const int max_steps = 10;
+
+void FlipScrollView::slotScrollTimer()
+{
+    mStepsRemaining--;
+    assert( mStepsRemaining >= 0 && mStepsRemaining < int(sizeof(  scrollSteps ) / sizeof( double )) );
+    if (KickerSettings::scrollFlipView())
+      scrollBy( ( int )( mScrollDirection * mLeftView->width() * scrollSteps[ mStepsRemaining ] ), 0 );
+    else
+      scrollBy( ( int )( mScrollDirection * mLeftView->width()), 0 );
+
+    if ( mStepsRemaining == 0 )
+    {
+        if ( mState == ScrollingRight )
+        {
+            mState = StoppedRight;
+            setContentsPos( width(), 0 );
+        } else {
+            mState = StoppedLeft;
+            setContentsPos( 0, 0 );
+        }
+
+        kdDebug() << "slotScrollTimer " << mShowBack << endl;
+
+        if ( mShowBack )
+        {
+            mBackrow->show();
+            if ( mState == StoppedRight )
+            {
+            	
+                if ( QApplication::reverseLayout() )
+                    moveChild( mRightView, width(), 0 );
+                else
+                    moveChild( mRightView, width() + mBackrow->width(), 0 );
+                mRightView->resize( width() - mBackrow->width(), height() );
+                mLeftView->resize( width(), height() );
+                if ( QApplication::reverseLayout() )
+                    moveChild( mBackrow, width() + mRightView->width(), 0 );
+                else
+                    moveChild( mBackrow, width(), 0 );
+                moveChild( mLeftView, 0, 0 );
+            } else
+            {
+                moveChild( mRightView, width(), 0 );
+                mRightView->resize( width(), height() );
+                mLeftView->resize( width() - mBackrow->width(), height() );
+                if ( QApplication::reverseLayout() )
+                {
+                    moveChild( mBackrow, mLeftView->width(), 0 );
+                    moveChild( mLeftView, 0, 0 );
+                }
+                else
+                {
+                    moveChild( mBackrow, 0, 0 );
+                    moveChild( mLeftView, mBackrow->width(), 0 );
+                }
+            }
+        } else
+            mBackrow->hide();
+
+        if (!mSelectMenuPath.isEmpty()) {
+            if (mSelectMenuPath=="kicker:/goup/") {
+                currentView()->setSelected(currentView()->firstChild(),true);
+                currentView()->firstChild()->repaint();
+            }
+            else {
+                QListViewItem * child = currentView()->firstChild();
+                while( child ) {
+                    KMenuItem* kitem = dynamic_cast<KMenuItem*>(child);
+                    if (kitem && kitem->menuPath()==mSelectMenuPath) {
+                        currentView()->setSelected(child,true);
+                        kdDebug() << "child repaint\n";
+                        child->repaint();
+                        break;
+                    }
+                    child = child->nextSibling();
+                }
+            }
+        }
+        mLeftView->setVScrollBarMode( QScrollView::Auto );
+        mRightView->setVScrollBarMode( QScrollView::Auto );
+        mTimer->stop();
+	mLeftView->setMouseMoveSelects( true );
+	mRightView->setMouseMoveSelects( true );
+    }
+}
+
+void FlipScrollView::flipScroll(const QString& selectMenuPath)
+{
+    if ( mState == StoppedLeft )
+    {
+        mState = ScrollingRight;
+        mScrollDirection = 1;
+    }
+    else
+    {
+        mState = ScrollingLeft;
+        mScrollDirection = -1;
+    }
+
+    mLeftView->setVScrollBarMode( QScrollView::AlwaysOff );
+    mRightView->setVScrollBarMode( QScrollView::AlwaysOff );
+    if (KickerSettings::scrollFlipView())
+      mStepsRemaining = max_steps;
+    else
+      mStepsRemaining = 1;
+    mTimer->start( 30 );
+    mSelectMenuPath = selectMenuPath;
+    if (!mSelectMenuPath.isEmpty()) {
+	mLeftView->setMouseMoveSelects( false );
+	mRightView->setMouseMoveSelects( false );
+    }
+}
+
+#include "flipscrollview.moc"
diff -Nurp kicker.orig/kicker/ui/flipscrollview.h kicker/kicker/ui/flipscrollview.h
--- kicker.orig/kicker/ui/flipscrollview.h	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/ui/flipscrollview.h	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,118 @@
+/*****************************************************************
+
+Copyright (c) 2006 Will Stephenson <wstephenson@novell.com>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+/*
+ * Flip scroll menu
+ * Each level of the menu is a separate QListView
+ * Child items are added to their own QListView.
+ * When a parent is clicked, we look up its child menu and insert
+ * that in a QScrollView, then scroll to it.
+ *
+ * Need to intercept QListViewItems' parent param and instead of
+ * inserting directly into parent, insert into parent item's listview
+ *
+ * So need
+ * - adapted QLVI
+ * - wrap QLV and offer same interface
+ */
+
+#ifndef FLIPSCROLLVIEW_H
+#define FLIPSCROLLVIEW_H
+
+#include <qscrollview.h>
+#include <qlistview.h>
+#include <qframe.h>
+#include <qtimer.h>
+#include <qpainter.h>
+#include <kstandarddirs.h>
+#include "service_mnu.h"
+
+class ItemView;
+
+class BackFrame : public QFrame
+{
+    Q_OBJECT
+
+public:
+    BackFrame( QWidget *parent );
+    virtual void drawContents( QPainter *p );
+
+    void enterEvent ( QEvent * );
+    void leaveEvent( QEvent * );
+    void mousePressEvent ( QMouseEvent * e );
+
+signals:
+    void clicked();
+
+private:
+    QPixmap left_triangle;
+    bool mouse_inside;
+};
+
+class FlipScrollView : public QScrollView
+{
+    Q_OBJECT
+public:
+    enum State{ StoppedLeft, StoppedRight, ScrollingLeft, ScrollingRight };
+    FlipScrollView( QWidget * parent = 0, const char * name = 0 );
+    ~FlipScrollView();
+
+    ItemView *currentView() const;
+    ItemView *leftView() const;
+    ItemView *rightView() const;
+    ItemView *prepareLeftMove(bool clear=true);
+    ItemView *prepareRightMove();
+
+    void flipScroll(const QString& selectMenuPath = QString::null);
+    void showBackButton(bool enable);
+    bool showsBackButton() const {return mShowBack;}
+
+protected slots:
+    void slotScrollTimer();
+
+signals:
+    void startService(KService::Ptr kservice);
+    void startURL(const QString& u);
+    void rightButtonPressed(QListViewItem*,const QPoint&,int);
+    void backButtonClicked();
+
+protected:
+    void viewportResizeEvent ( QResizeEvent * );
+
+private:
+    ItemView * mLeftView;
+    ItemView * mRightView;
+//  ItemView * mCurrentView;
+    int mStepsRemaining;
+    State mState;
+    QTimer * mTimer;
+    BackFrame *mBackrow;
+    QString mSelectMenuPath;
+    int mScrollDirection;
+    bool mShowBack;
+};
+
+
+
+
+#endif
diff -Nurp kicker.orig/kicker/ui/itemview.cpp kicker/kicker/ui/itemview.cpp
--- kicker.orig/kicker/ui/itemview.cpp	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/ui/itemview.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,1257 @@
+/*****************************************************************
+
+Copyright (c) 1996-2000 the kicker authors. See file AUTHORS.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#include <stdlib.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <dmctl.h>
+
+#include <qapplication.h>
+#include <qimage.h>
+#include <qpainter.h>
+#include <qstyle.h>
+#include <qwidgetstack.h>
+#include <qlayout.h>
+#include <qlabel.h>
+#include <qvbox.h>
+#include <qheader.h>
+#include <qdrawutil.h>
+#include <qdragobject.h>
+#include <qcursor.h>
+#include <qpaintdevicemetrics.h>
+#include <qbuffer.h>
+#include <qtooltip.h>
+#include <qstylesheet.h>
+#include <qiconview.h>
+
+#include <dcopclient.h>
+#include <kapplication.h>
+#include <kaboutkde.h>
+#include <kpixmapeffect.h>
+#include <kaction.h>
+#include <kbookmarkmenu.h>
+#include <kconfig.h>
+#include <kdebug.h>
+#include <kglobal.h>
+#include <kglobalsettings.h>
+#include <kiconloader.h>
+#include <klocale.h>
+#include <kmessagebox.h>
+#include <kstandarddirs.h>
+#include <kcombobox.h>
+#include <kwin.h>
+#include <kdebug.h>
+#include <kmimetype.h>
+#include <kmultipledrag.h>
+
+#include "client_mnu.h"
+#include "container_base.h"
+#include "global.h"
+#include "kbutton.h"
+#include "kicker.h"
+#include "kickerSettings.h"
+#include "konqbookmarkmanager.h"
+#include "menuinfo.h"
+#include "menumanager.h"
+#include "popupmenutitle.h"
+#include "quickbrowser_mnu.h"
+#include "recentapps.h"
+
+#include "k_mnu.h"
+#include "k_new_mnu.h"
+#include "itemview.h"
+
+// --------------------------------------------------------------------------
+
+KMenuItem::~KMenuItem()
+{
+    ItemView *listview = dynamic_cast<ItemView*>( listView() );
+    if ( listview && listview->m_lastOne == this) {
+      listview->m_lastOne = 0;
+      listview->m_old_contentY = -1;
+    }
+}
+
+static double pointSize( double pixelSize, QPaintDevice *w )
+{
+    return pixelSize * 72. / QPaintDevice::x11AppDpiY( w->x11Screen () );
+}
+
+static int pixelSize( double pixelSize, QPaintDevice *w )
+{
+    return qRound( pixelSize * QPaintDevice::x11AppDpiY( w->x11Screen () ) / 72. );
+}
+
+void KMenuItem::init()
+{
+    setMultiLinesEnabled(true);
+    m_s = 0;
+    m_path = QString::null;
+    m_icon = QString::null;
+    m_menuPath = QString::null;
+    setDragEnabled(true);
+    m_has_children = false;
+    m_old_width = -1;
+    if ( QApplication::reverseLayout() )
+        right_triangle.load( locate( "data", "kicker/pics/left_triangle.png" ) );
+    else
+        right_triangle.load( locate( "data", "kicker/pics/right_triangle.png" ) );
+}
+
+void KMenuItem::setTitle(const QString& txt)
+{
+    m_title = txt;
+    setText( 0, txt );
+    setup();
+}
+
+void KMenuItem::setToolTip(const QString& txt)
+{
+    m_tooltip = txt;
+}
+
+void KMenuItem::setDescription(const QString& txt)
+{
+    m_description = txt;
+    setup();
+}
+
+void KMenuItem::setIcon(const QString& icon, int size)
+{
+    m_icon = icon;
+    QListViewItem::setPixmap(0, KGlobal::iconLoader()->loadIcon(icon, KIcon::Panel, size ));
+}
+
+void KMenuItem::setHasChildren( bool flag )
+{
+    m_has_children = flag;
+    repaint();
+}
+
+void KMenuItem::setup()
+{
+    // if someone configured a larger generalFont than 10pt, he might have a _real_ problem with 7pt
+    // the 7pt could be read out of konquerorrc I guess
+    float min_font_size = 7. * QMAX(1., KGlobalSettings::generalFont().pointSizeFloat() / 10.);
+
+    const int expected_height = 38;
+    description_font_size = QMAX( pointSize( expected_height * .3, listView() ) + KickerSettings::kickoffFontPointSizeOffset(), min_font_size ) ;
+    title_font_size = QMAX( pointSize( expected_height * .25, listView() ) + KickerSettings::kickoffFontPointSizeOffset(), min_font_size + 1 );
+
+    //kdDebug() << description_font_size << " " << title_font_size << " " << pointSize( expected_height * .25, listView() ) << endl;
+    QListViewItem::setup();
+    setHeight( (int)QMAX( expected_height, pixelSize( title_font_size + description_font_size * 2.3, listView())));
+}
+
+void KMenuItem::paintCell(QPainter* p, const QColorGroup & cg, int column, int width, int align)
+{
+    ItemView *listview = static_cast<ItemView*>( listView() );
+    int bottom = listView()->itemRect( this ).bottom();
+    int diff = bottom - listView()->viewport()->height();
+
+    KPixmap pm;
+    pm.resize( width, height() );
+    QPainter pp( &pm );
+    paintCellInter( &pp, cg, column, width, align );
+    pp.end();
+
+    if ( diff > 0 && diff <= height() ) // cut off
+    {
+        pm.resize( width, height() - diff );
+        KPixmapEffect::blend( pm, float( diff ) / height(),
+                              cg.color( QColorGroup::Background ),
+                              KPixmapEffect::VerticalGradient );
+        p->drawPixmap( 0, 0, pm );
+        if ( listview->m_lastOne != this )
+        {
+            listview->m_lastOne = this;
+            listview->m_old_contentY = -1;
+        }
+    }
+    else
+    {
+        p->drawPixmap( 0, 0, pm );
+        if ( this == listview->m_lastOne ) {
+            if ( bottom < 0 )
+                listview->m_lastOne = static_cast<KMenuItem*>( itemAbove() );
+            else
+                listview->m_lastOne = static_cast<KMenuItem*>( itemBelow() );
+            listview->m_old_contentY = -1;
+            repaint();
+        }
+    }
+}
+
+void KMenuItem::makeGradient( KPixmap &off, const QColor &c )
+{
+    KPixmap blend;
+    blend.resize( off.width() / 3, off.height() );
+    bitBlt( &blend, 0, 0, &off, off.width() - blend.width(), 0, blend.width(), blend.height() );
+    KPixmapEffect::blend( blend, 0.2, c, KPixmapEffect::HorizontalGradient );
+    QPainter p( &off );
+    p.drawPixmap( off.width() - blend.width(), 0, blend );
+    p.end();
+}
+
+void KMenuItem::paintCellInter(QPainter* p, const QColorGroup & cg, int column, int width, int align)
+{
+    const bool reverseLayout = QApplication::reverseLayout();
+
+    const BackgroundMode bgmode = listView()->viewport()->backgroundMode();
+    const QColorGroup::ColorRole crole = QPalette::backgroundRoleFromMode( bgmode );
+    QColor backg = cg.color( crole );
+
+    if ( isSelected() )
+        backg = cg.color( QColorGroup::Highlight );
+    p->fillRect( 0, 0, width, height(), backg );
+
+    QFontMetrics fm( p->fontMetrics() );
+
+    int pixsize = 32;
+    if ( height() < 36 )
+        pixsize = 16;
+    const int left_margin = 30;
+    const int margin = 3;
+
+//    p->drawText( 2, 2, left_margin - 2, height(), align, QString::number( childCount () ) );
+
+    const QPixmap * pix = pixmap( column );
+
+    if ( pix )
+    {
+        QPixmap pix32 = *pix;
+
+        if ( pix->width() > pixsize )
+        {
+            QImage i = pix->convertToImage().smoothScale( pixsize, pixsize );
+            pix32.convertFromImage( i );
+        }
+        if ( reverseLayout )
+            p->drawPixmap( width - ( (pixsize - pix32.width()) / 2 + left_margin ) - pix32.width(),
+                       ( height() - pix32.height() ) / 2, pix32 );
+        else
+            p->drawPixmap( (pixsize - pix32.width()) / 2 + left_margin,
+                       ( height() - pix32.height() ) / 2, pix32 );
+    }
+
+    if ( m_title.isEmpty() )
+        return;
+
+    int r = left_margin + pixsize + margin * 2;
+
+    QFont f1 = p->font();
+    f1.setPointSizeFloat( title_font_size );
+    f1.setWeight( QFont::Normal ); // QFont::DemiBold == 63
+
+    QFont f2 = p->font();
+    f2.setPointSizeFloat( description_font_size );
+    f2.setWeight( QFont::Light );
+
+    int f1h = QFontMetrics( f1 ).height();
+    int f2h = QFontMetrics( f2 ).height();
+
+    const int text_margin = 2;
+    int spacing = ( height() - f1h - f2h - text_margin ) / 2;
+    if ( m_description.isEmpty() )
+        spacing = ( height() - f1h ) / 2;
+
+    int right_triangle_size = pixelSize( 7, listView() );
+
+    int right_margin = listView()->verticalScrollBar()->width();
+    if ( m_has_children )
+        right_margin += right_triangle_size * 2;
+
+    KPixmap off;
+    QPainter pp;
+
+    off.resize( width-text_margin-r-right_margin, height() );
+    pp.begin( &off );
+    pp.fillRect( 0, 0, off.width(), off.height(), backg );
+
+    if (isSelected())
+       pp.setPen( cg.color( QColorGroup::HighlightedText ) );
+    else
+       pp.setPen( cg.color( QColorGroup::Text ) );
+
+    pp.setFont( f1 );
+    pp.drawText( 0, 0, off.width(), off.height(), align, m_title );
+    pp.end();
+    if ( QFontMetrics( f1 ).width( m_title ) > off.width() )
+    {
+        makeGradient( off, backg );
+        if ( !m_description.isEmpty() )
+            setToolTip( m_title + "<br><br>" + m_description );
+        else
+            setToolTip( m_title );
+    }
+    if ( reverseLayout )
+        p->drawPixmap( width - off.width() - r, spacing, off );
+    else
+        p->drawPixmap( r, spacing, off );
+
+    if ( !m_description.isEmpty() )
+    {
+        pp.begin( &off );
+        pp.fillRect( 0, 0, off.width(), off.height(), backg );
+
+        QColor myColor = cg.color( QColorGroup::Text ).light( 200 );
+        if ( qGray( myColor.rgb() ) == 0 )
+            myColor = QColor( 100, 100, 110 );
+        pp.setPen( myColor );
+        pp.setPen( isSelected() ? cg.color( QColorGroup::Mid ) : myColor );
+        pp.setFont( f2 );
+        pp.drawText( 0, 0, off.width(), off.height(), align, m_description );
+        pp.end();
+        if ( QFontMetrics( f2 ).width( m_description ) > off.width() )
+        {
+            makeGradient( off, backg );
+            setToolTip( m_title + "<br><br>" + m_description );
+        }
+        if ( reverseLayout )
+            p->drawPixmap( width - off.width() - r, spacing + text_margin + f1h, off );
+        else
+            p->drawPixmap( r, spacing + text_margin + f1h, off );
+    }
+
+    if ( m_has_children )
+    {
+        QImage i = right_triangle.convertToImage().smoothScale( right_triangle_size,
+                                                                right_triangle_size );
+        QPixmap tri;
+        tri.convertFromImage( i );
+
+        if ( reverseLayout )
+            p->drawPixmap( right_margin - tri.width(), ( height() - f1h ) / 2, tri );
+        else
+            p->drawPixmap( listView()->width() -  right_margin, ( height() - f1h ) / 2, tri );
+    }
+
+    if ( m_old_width != width )
+    {
+        // the listview caches paint events
+        m_old_width = width;
+        repaint();
+    }
+}
+
+// --------------------------------------------------------------------------
+
+KMenuItemSeparator::KMenuItemSeparator(int nId, QListView* parent)
+    : KMenuItem(nId, parent), lv(parent), cached_width( 0 )
+{
+    setEnabled(false);
+    left_margin = 15;
+}
+
+void KMenuItemSeparator::setup()
+{
+    KMenuItem::setup();
+
+    QFont f = QFont();
+    QFontMetrics fm(f);
+    f.setPointSize( 8 + KickerSettings::kickoffFontPointSizeOffset() );
+    if ( itemAbove() && !text( 0 ).isEmpty() )
+        setHeight( (int)QMAX( 34., fm.height() * 1.4) );
+    else
+        setHeight( (int)QMAX( 26., fm.height() * 1.4 ) );
+}
+
+void KMenuItemSeparator::setLink( const QString &text, const QString &url )
+{
+    m_link_text = text;
+    m_link_url = url;
+    m_link_rect = QRect();
+}
+
+bool KMenuItemSeparator::hitsLink( const QPoint &pos )
+{
+    return m_link_rect.contains( pos );
+}
+
+void KMenuItemSeparator::preparePixmap( int width )
+{
+    if ( cached_width != width )
+    {
+        pixmap.load( locate("data", "kicker/pics/menu_separator.png" ) );
+        QImage i = pixmap.convertToImage().smoothScale( width - 15 - left_margin, pixmap.height() );
+        pixmap.convertFromImage( i );
+        cached_width = width;
+    }
+}
+
+void KMenuItemSeparator::paintCell(QPainter* p, const QColorGroup & cg, int column, int width, int align)
+{
+    preparePixmap(width);
+
+    const int h = height();
+
+    if (text(0).isEmpty()) {
+      KMenuItem::paintCell(p, cg, column, width, align);
+      p->drawPixmap( 15 , h/2, pixmap );
+    }
+    else {
+      const BackgroundMode bgmode = lv->viewport()->backgroundMode();
+      const QColorGroup::ColorRole crole = QPalette::backgroundRoleFromMode( bgmode );
+      p->fillRect( 0, 0, width, h, cg.brush( crole ) );
+
+      int margin = 0;
+      if ( itemAbove() ) {
+          p->drawPixmap( 15 , h/4, pixmap );
+          margin = h / 4;
+      }
+      QFont f = listView()->font();
+      f.setWeight( QFont::Normal );
+      f.setPointSize( 8 + KickerSettings::kickoffFontPointSizeOffset() );
+      p->setFont( f );
+      QColor myColor = cg.color( QColorGroup::Text ).light( 200 );
+      if ( qGray( myColor.rgb() ) == 0 )
+          myColor = QColor( 100, 100, 110 );
+      p->setPen( myColor );
+      int twidth = p->fontMetrics().width(text(0));
+      int lwidth = 0;
+      int swidth = 0;
+      int fwidth = 0;
+
+      if ( !m_link_text.isEmpty() )
+      {
+          swidth = p->fontMetrics().width( " (" );
+          lwidth = p->fontMetrics().width(m_link_text );
+          fwidth = p->fontMetrics().width( ")" );
+      }
+      int pos = int(lv->width() * 0.9 - twidth - swidth - lwidth - fwidth);
+      p->drawText( pos, margin + 5,
+                   width, h - ( margin +5 ), AlignTop, text(0) );
+      if ( !m_link_text.isEmpty() )
+      {
+          pos += twidth;
+          p->drawText( pos, margin + 5,
+                       width, h - ( margin +5 ), AlignTop, " (" );
+          pos += swidth;
+          p->setPen( cg.color( QColorGroup::Link ) );
+          f.setUnderline( true );
+          p->setFont( f );
+          p->drawText( pos, margin + 5,
+                       width, h - ( margin +5 ), AlignTop, m_link_text );
+          m_link_rect = QRect( pos, margin + 5, lwidth, p->fontMetrics().height() );
+          pos += lwidth;
+          f.setUnderline( false );
+          p->setFont( f );
+          p->drawText( pos, margin + 5,
+                       width, h - ( margin +5 ), AlignTop, ")" );
+      }
+    }
+}
+
+KMenuItemHeader::KMenuItemHeader(int nId, const QString& relPath, QListView* parent)
+    : KMenuItemSeparator(nId, parent)
+{
+    setEnabled( false );
+    QString path;
+    if (relPath.startsWith( "new/" /*"kicker:/new/"*/ )) {
+       paths.append( "kicker:/goup/" );
+       texts.append( i18n("New Applications") );
+       icons.append( "clock" );
+    }
+    else if (relPath == "kicker:/restart/") {
+       texts.append( i18n("Restart Computer") );
+    }
+    else if (relPath == "kicker:/switchuser/") {
+       texts.append( i18n("Switch User") );
+    }
+    else {
+      KServiceGroup::Ptr subMenuRoot = KServiceGroup::group(relPath);
+      QStringList items = QStringList::split( '/', relPath );
+      for ( QStringList::ConstIterator it = items.begin(); it != items.end(); ++it )
+      {
+        path += *it + "/";
+        paths.append( "kicker:/goup/" + path );
+        KServiceGroup::Ptr subMenuRoot = KServiceGroup::group(path);
+        QString groupCaption = subMenuRoot->caption();
+        texts.append( groupCaption );
+        icons.append( subMenuRoot->icon() );
+      }
+    }
+
+    setPath( "kicker:/goup/" + path ); // the last wins for now
+    left_margin = 10;
+}
+
+void KMenuItemHeader::setup()
+{
+    KMenuItem::setup();
+
+    QFontMetrics fm( listView()->font() );
+    setHeight( QMAX( int( texts.count() * fm.height() + ( texts.count() + 1 ) * 2 + 10 ), height()) );
+    // nada
+}
+
+void KMenuItemHeader::paintCell(QPainter* p, const QColorGroup & cg, int , int width, int align )
+{
+    preparePixmap(width);
+
+    const BackgroundMode bgmode = listView()->viewport()->backgroundMode();
+    const QColorGroup::ColorRole crole = QPalette::backgroundRoleFromMode( bgmode );
+
+    QBrush br = cg.brush( crole );
+    if ( isSelected() ) {
+        br = cg.brush( QColorGroup::Highlight );
+        p->fillRect( 0, 0, width, height() - 3, br );
+    } else {
+        p->fillRect( 0, 0, width, height(), br );
+    }
+
+    QFontMetrics fm( p->fontMetrics() );
+    const int left_margin = 10;
+
+    const int margin = 3;
+
+    int r = left_margin + margin * 2;
+
+    const int min_font_size = 7;
+    int title_font_pixelSize = qRound( pixelSize( QMAX( pointSize( 12, listView() ) + KickerSettings::kickoffFontPointSizeOffset(), min_font_size + 1 ), listView() ) );
+
+    QFont f1 = p->font();
+    f1.setPixelSize( title_font_pixelSize );
+    p->setFont( f1 );
+    int f1h = QFontMetrics( f1 ).height();
+
+    p->setPen( cg.color( QColorGroup::Text ) );
+
+    const int text_margin = 2;
+    int spacing = ( height() - texts.count() * f1h - QMAX( texts.count() - 1, 0 ) * text_margin ) / 2;
+
+    for ( uint i = 0; i < texts.count(); ++i )
+    {
+        if (i==texts.count()-1) {
+            f1.setWeight( QFont::DemiBold );
+            p->setFont( f1 );
+            f1h = QFontMetrics( f1 ).height();
+        }
+
+        p->drawText( r, spacing, width-text_margin-r, height(), align, texts[i] );
+        spacing += text_margin + f1h;
+        r += title_font_pixelSize;
+    }
+
+    p->drawPixmap( left_margin , height() - 2, pixmap );
+}
+
+KMenuSpacer::KMenuSpacer(int nId, QListView* parent)
+    : KMenuItem(nId, parent)
+{
+    setEnabled(false);
+}
+
+void KMenuSpacer::setup()
+{
+    // nada
+}
+
+void KMenuSpacer::paintCell(QPainter* p, const QColorGroup & cg, int , int width, int )
+{
+    const BackgroundMode bgmode = listView()->viewport()->backgroundMode();
+    const QColorGroup::ColorRole crole = QPalette::backgroundRoleFromMode( bgmode );
+    QBrush br = cg.brush( crole );
+
+    p->fillRect( 0, 0, width, height(), br );
+}
+
+void KMenuSpacer::setHeight( int i )
+{
+    KMenuItem::setHeight( i );
+}
+
+class ItemViewTip : public QToolTip
+{
+public:
+    ItemViewTip( QWidget *parent, QListView *lv );
+
+    void maybeTip( const QPoint &pos );
+
+private:
+    QListView *view;
+
+};
+
+ItemViewTip::ItemViewTip( QWidget *parent, QListView *lv )
+    : QToolTip( parent ), view( lv )
+{
+}
+
+void ItemViewTip::maybeTip( const QPoint &pos )
+{
+    KMenuItem *item = dynamic_cast<KMenuItem*>( view->itemAt( pos ) );
+    QPoint contentsPos = view->viewportToContents( pos );
+    if ( !item )
+        return;
+
+    if ( item->toolTip().isNull() )
+        return;
+
+    QRect r = view->itemRect( item );
+    int headerPos = view->header()->sectionPos( 0 );
+    r.setLeft( headerPos );
+    r.setRight( headerPos + view->header()->sectionSize( 0 ) );
+    tip( r, item->toolTip() );
+}
+
+// --------------------------------------------------------------------------
+
+ItemView::ItemView(QWidget* parent, const char* name)
+    : KListView(parent, name), m_spacer( 0 ),
+      m_mouseMoveSelects(true), m_iconSize(32)
+{
+    setHScrollBarMode( QScrollView::AlwaysOff );
+    setFrameStyle( QFrame::NoFrame );
+    setSelectionMode(QListView::Single);
+    addColumn("");
+    header()->setStretchEnabled(1, 0);
+    //setColumnWidthMode(0, QListView::Maximum);
+    header()->hide();
+    setMouseTracking(true);
+    setItemMargin(0);
+    setSorting(-1);
+    setTreeStepSize(38);
+    setFocusPolicy(QWidget::NoFocus);
+
+    m_lastOne = 0;
+    m_old_contentY = -1;
+
+    connect(this, SIGNAL(mouseButtonClicked( int, QListViewItem*, const QPoint &, int )),
+                  SLOT(slotItemClicked(int, QListViewItem*, const QPoint &, int)));
+
+    connect(this, SIGNAL(returnPressed(QListViewItem*)), SLOT(slotItemClicked(QListViewItem*)));
+    connect(this, SIGNAL(spacePressed(QListViewItem*)), SLOT(slotItemClicked(QListViewItem*)));
+
+    new ItemViewTip( viewport(), this );
+}
+
+KMenuItemHeader *ItemView::insertHeader(int id, const QString &relpath)
+{
+    KMenuItemHeader *newItem = new KMenuItemHeader(id, relpath, this );
+    moveItemToIndex(newItem, 1);
+    setBackPath( "kicker:/goup/" + relpath ); // the last wins for now
+
+    return newItem;
+}
+
+KMenuItem* ItemView::findItem(int nId)
+{
+    for (QListViewItemIterator it(this); it.current(); ++it)
+    {
+	if(static_cast<KMenuItem*>(it.current())->id() == nId)
+	    return static_cast<KMenuItem*>(it.current());
+    }
+
+    return 0L;
+}
+
+bool ItemView::focusNextPrevChild(bool /*next*/)
+{
+    return false;
+}
+
+KMenuItem* ItemView::itemAtIndex(int nIndex)
+{
+    if(nIndex <= 0)
+	return 0L;
+
+    if(nIndex >= childCount())
+      return static_cast<KMenuItem*>(lastItem());
+
+    int i = 1;
+    QListViewItemIterator it(this);
+    for (;it.current(); ++i, ++it) {
+	if(i == nIndex)
+	    return static_cast<KMenuItem*>(it.current());
+    }
+
+    return static_cast<KMenuItem*>(lastItem());
+}
+
+KMenuItem* ItemView::insertItem( const QString& icon, const QString& text, const QString& description, const
+                                 QString& path, int nId, int nIndex, KMenuItem *parent)
+{
+    KMenuItem* newItem = findItem(nId);
+
+    if(!newItem && parent)
+        newItem = new KMenuItem(nId, parent );
+    else if ( !newItem )
+	newItem = new KMenuItem(nId, this );
+
+    newItem->setIcon(icon, m_iconSize);
+    newItem->setTitle(text);
+    newItem->setDescription(description);
+    newItem->setPath(path);
+
+    if (nIndex==-1)
+      nIndex=childCount();
+
+    moveItemToIndex(newItem, nIndex);
+
+    return newItem;
+}
+
+KMenuItem* ItemView::insertItem( const QString& icon, const QString& text, const QString& description,
+                                 int nId, int nIndex, KMenuItem *parent)
+{
+   return insertItem( icon, text, description, QString::null, nId, nIndex, parent);
+}
+
+int ItemView::setItemEnabled(int id, bool enabled)
+{
+    KMenuItem* item = findItem(id);
+
+    if(item)
+	item->setEnabled(enabled);
+
+    return 0;
+}
+
+KMenuItemSeparator *ItemView::insertSeparator(int nId, const QString& text, int nIndex)
+{
+    KMenuItemSeparator *newItem = new KMenuItemSeparator(nId, this);
+
+    newItem->setText(0, text);
+
+    if (nIndex==-1)
+      nIndex=childCount();
+
+    moveItemToIndex(newItem, nIndex);
+    return newItem;
+}
+
+void ItemView::moveItemToIndex(KMenuItem* item, int nIndex)
+{
+
+    if (nIndex <= 0) {
+          takeItem(item);
+          KListView::insertItem(item);
+    }
+    else {
+        item->moveItem(itemAtIndex(nIndex));
+    }
+}
+
+void ItemView::slotMoveContent()
+{
+    if ( !m_spacer )
+        return;
+
+    int item_height = 0;
+    QListViewItemIterator it( this );
+    while ( it.current() ) {
+        if ( !dynamic_cast<KMenuSpacer*>( it.current() ) && !it.current()->parent() && it.current()->isVisible() )  {
+            it.current()->invalidateHeight();
+            item_height += it.current()->totalHeight();
+        }
+        ++it;
+    }
+
+    if ( height() > item_height )
+        m_spacer->setHeight( height() - item_height );
+    else
+        m_spacer->setHeight( 0 );
+}
+
+KMenuItem *ItemView::insertMenuItem(KService::Ptr& s, int nId, int nIndex, KMenuItem* parentItem,
+                                    const QString& aliasname, const QString & label, const QString & categoryIcon )
+{
+    if (!s)
+	return 0;
+
+    QString serviceName = aliasname.isEmpty() ? s->name() : aliasname;
+
+    kdDebug() << "insertMenuItem " << nId << " " << nIndex << " " << s->name() << endl;
+    KMenuItem* newItem = 0; //findItem(nId);
+    if(!newItem)
+	newItem = parentItem ? new KMenuItem(nId, parentItem) : new KMenuItem(nId, this);
+
+    newItem->setIcon(s->icon()=="unknown" ? categoryIcon : s->icon(), m_iconSize);
+    if ((KickerSettings::DescriptionAndName || KickerSettings::menuEntryFormat()
+            == KickerSettings::DescriptionOnly) && !s->genericName().isEmpty()) {
+      newItem->setTitle(s->genericName());
+      newItem->setDescription(label.isEmpty() ? serviceName : label);
+    }
+    else {
+      newItem->setTitle(label.isEmpty() ? serviceName : label);
+      newItem->setDescription(s->genericName());
+    }
+    newItem->setService(s);
+
+    if (nIndex==-2)
+      return newItem;
+
+    if (nIndex==-1)
+      nIndex=childCount();
+
+    moveItemToIndex(newItem, nIndex);
+
+    return newItem;
+}
+
+KMenuItem* ItemView::insertDocumentItem(const QString& s, int nId, int nIndex, const QStringList* /*suppressGenericNames*/,
+                                        const QString& /*aliasname*/)
+{
+    KMenuItem* newItem = findItem(nId);
+
+    if(!newItem)
+	newItem = new KMenuItem(nId, this);
+
+    KMimeType::Ptr mt = KMimeType::findByURL( s );
+    newItem->setIcon(KMimeType::iconForURL( s ), m_iconSize);
+    newItem->setTitle(s);
+    newItem->setDescription(mt->comment());
+    newItem->setPath(s);
+
+    if (nIndex==-1)
+      nIndex=childCount();
+
+    moveItemToIndex(newItem, nIndex);
+
+    return newItem;
+}
+
+KMenuItem* ItemView::insertRecentlyItem(const QString& s, int nId, int nIndex)
+{
+    KDesktopFile f(s, true /* read only */);
+
+    KMenuItem* newItem = findItem(nId);
+
+    if(!newItem)
+	newItem = new KMenuItem(nId, this);
+
+    newItem->setIcon(f.readIcon(), m_iconSize);
+
+    // work around upstream fixed bug
+    QString name=f.readName();
+    if (name.isEmpty())
+      name=f.readURL();
+
+    newItem->setTitle(name);
+
+    QString comment = f.readComment();
+    if (comment.isEmpty()) {
+      KURL url(f.readURL());
+      if (!url.host().isEmpty())
+        comment = i18n("Host: %1").arg(url.host());
+    }
+
+    newItem->setDescription(comment);
+    newItem->setPath(s);
+
+    if (nIndex==-1)
+      nIndex=childCount();
+
+    moveItemToIndex(newItem, nIndex);
+
+    return newItem;
+}
+
+int ItemView::insertItem(PopupMenuTitle*, int, int)
+{
+    return 0;
+}
+
+KMenuItem* ItemView::insertSubItem(const QString& icon, const QString& caption, const QString& description, const QString& path, KMenuItem* parentItem)
+{
+#warning FIXME
+    KMenuItem* newItem = parentItem ? new KMenuItem(-1, parentItem) : new KMenuItem(-1, this);
+    newItem->setTitle(caption);
+    newItem->setDescription(description);
+    newItem->setIcon(icon, m_iconSize);
+    newItem->setPath(path);
+
+    return newItem;
+}
+
+
+
+void ItemView::slotItemClicked(int button, QListViewItem * item, const QPoint & /*pos*/, int /*c*/ )
+{
+    if (button==1)
+      slotItemClicked(item);
+}
+
+void ItemView::slotItemClicked(QListViewItem* item)
+{
+    KMenuItem* kitem = dynamic_cast<KMenuItem*>(item);
+    if ( !kitem )
+        return;
+
+    if(kitem->service()) {
+        emit startService(kitem->service());
+    }
+    else if(!kitem->path().isEmpty()) {
+        emit startURL(kitem->path());
+    }
+}
+
+void ItemView::contentsMousePressEvent ( QMouseEvent * e )
+{
+    KListView::contentsMousePressEvent( e );
+
+    QPoint vp = contentsToViewport(e->pos());
+    KMenuItemSeparator *si = dynamic_cast<KMenuItemSeparator*>( itemAt( vp ) );
+    if ( si )
+    {
+        if ( si->hitsLink( vp - itemRect(si).topLeft() ) )
+            emit startURL( si->linkUrl() );
+    }
+}
+
+void ItemView::contentsMouseMoveEvent(QMouseEvent *e)
+{
+    QPoint vp = contentsToViewport(e->pos());
+    QListViewItem * i = itemAt( vp );
+
+    bool link_cursor = false;
+    KMenuItemSeparator *si = dynamic_cast<KMenuItemSeparator*>( i );
+    if ( si )
+        link_cursor = si->hitsLink( vp - itemRect(si).topLeft() );
+
+    if (i && !i->isSelectable() && !link_cursor) {
+      unsetCursor();
+      viewport()->unsetCursor();
+      return;
+    }
+
+    KListView::contentsMouseMoveEvent(e);
+
+    if (m_mouseMoveSelects) {
+      if(i && i->isEnabled() && !i->isSelected() &&
+         // FIXME: This is wrong if you drag over the items.
+         (e->state() & (LeftButton|MidButton|RightButton)) == 0)
+          KListView::setSelected(i, true);
+      else if (!i && selectedItem())
+          KListView::setSelected(selectedItem(), false);
+    }
+
+    if ( link_cursor )
+        setCursor( Qt::PointingHandCursor );
+    else
+        unsetCursor();
+
+}
+
+void ItemView::leaveEvent(QEvent* e)
+{
+    KListView::leaveEvent(e);
+
+    clearSelection();
+}
+
+void ItemView::resizeEvent ( QResizeEvent * e )
+{
+    KListView::resizeEvent( e );
+//    if ( m_lastOne )
+//        int diff = itemRect( m_lastOne ).bottom() - viewport()->height();
+}
+
+void ItemView::viewportPaintEvent ( QPaintEvent * pe )
+{
+    //kdDebug() << "viewportPaintEvent " << pe->rect() << " " << contentsY () << " " << m_old_contentY << endl;
+    KListView::viewportPaintEvent( pe );
+
+    if ( m_lastOne && m_old_contentY != contentsY() ) {
+        m_old_contentY = contentsY();
+        m_lastOne->repaint();
+    }
+}
+
+void ItemView::clear()
+{
+    KListView::clear();
+    m_lastOne = 0;
+    m_old_contentY = -1;
+    m_back_url = QString::null;
+}
+
+void ItemView::contentsWheelEvent(QWheelEvent *e)
+{
+    KListView::contentsWheelEvent(e);
+
+    QPoint vp = contentsToViewport(e->pos());
+    QListViewItem * i = itemAt( vp );
+
+    if(i && i->isEnabled() && !i->isSelected() &&
+       // FIXME: This is wrong if you drag over the items.
+       (e->state() & (LeftButton|MidButton|RightButton)) == 0)
+        KListView::setSelected(i, true);
+    else if (!i && selectedItem())
+        KListView::setSelected(selectedItem(), false);
+}
+
+QDragObject * ItemView::dragObject()
+{
+    KMultipleDrag* o = 0;
+    QListViewItem *item = itemAt( viewport()->mapFromGlobal(QCursor::pos()) );
+    if ( item ) {
+      KMenuItem* kitem = static_cast<KMenuItem*>(item);
+
+      if (dynamic_cast<KMenuItemHeader*>(item))
+        return 0;
+
+      o = new KMultipleDrag(viewport());
+      QPixmap pix = KGlobal::iconLoader()->loadIcon( kitem->icon(), KIcon::Panel, m_iconSize);
+      QPixmap add = KGlobal::iconLoader()->loadIcon( "add", KIcon::Small );
+
+      QPainter p( &pix );
+      p.drawPixmap(pix.height()-add.height(), pix.width()-add.width(), add);
+      p.end();
+
+      QBitmap mask;
+
+      if (pix.mask())
+          mask = *pix.mask();
+      else {
+	  mask.resize(pix.size());
+	  mask.fill(Qt::color1);
+      }
+
+      bitBlt( &mask, pix.width()-add.width(), pix.height()-add.height(), add.mask(), 0, 0, add.width(), add.height(), OrROP );
+      pix.setMask( mask );
+      o->setPixmap(pix);
+
+      if(kitem->service()) {
+        // If the path to the desktop file is relative, try to get the full
+        // path from KStdDirs.
+        QString path = kitem->service()->desktopEntryPath();
+        path = locate("apps", path);
+        o->addDragObject(new KURLDrag(KURL::List(KURL(path)), 0));
+      }
+      else if (kitem->path().startsWith("kicker:/new") || kitem->path().startsWith("system:/")
+        || kitem->path().startsWith("kicker:/switchuser_") || kitem->path().startsWith("kicker:/restart_")) {
+        delete o;
+        return 0;
+      }
+      else if (kitem->hasChildren()) {
+         o->addDragObject(new KURLDrag(KURL::List(KURL("programs:/"+kitem->menuPath())), 0));
+         return o;
+      }
+      else if(!kitem->path().isEmpty() && !kitem->path().startsWith("kicker:/") && !kitem->path().startsWith("kaddressbook:/")) {
+         QString uri = kitem->path();
+
+         if (uri.startsWith(locateLocal("data", QString::fromLatin1("RecentDocuments/")))) {
+             KDesktopFile df(uri,true);
+             uri=df.readURL();
+         }
+
+         o->addDragObject(new KURLDrag(KURL::List(KURL(uri)), 0));
+      }
+
+      o->addDragObject(new KMenuItemDrag(*kitem,this));
+    }
+    return o;
+}
+
+int ItemView::goodHeight()
+{
+    int item_height = 0;
+    QListViewItemIterator it( this );
+    while ( it.current() ) {
+        if ( !dynamic_cast<KMenuSpacer*>( it.current() ) && !it.current()->parent() && it.current()->isVisible() )  {
+            item_height += it.current()->height();
+        }
+        ++it;
+    }
+
+    return item_height;
+}
+
+
+KMenuItemDrag::KMenuItemDrag(KMenuItem& item, QWidget *dragSource)
+    : QDragObject(dragSource, 0)
+{
+    QBuffer buff(a);
+    buff.open(IO_WriteOnly);
+    QDataStream s(&buff);
+
+    s << item.id() << (item.service() ? item.service()->storageId() : QString::null)
+      << item.title() << item.description() << item.icon() << item.path();
+}
+
+KMenuItemDrag::~KMenuItemDrag()
+{
+}
+
+const char * KMenuItemDrag::format(int i) const
+{
+    if (i == 0)
+        return "application/kmenuitem";
+
+    return 0;
+}
+
+QByteArray KMenuItemDrag::encodedData(const char* mimeType) const
+{
+    if (QString("application/kmenuitem") == mimeType)
+        return a;
+
+    return QByteArray();
+}
+
+bool KMenuItemDrag::canDecode(const QMimeSource * e)
+{
+    if (e->provides( "application/kmenuitem" ) )
+        return true;
+
+    return false;
+}
+
+bool ItemView::acceptDrag (QDropEvent* event) const
+{
+    if ( !acceptDrops() )
+        return false;
+
+    if (KMenuItemDrag::canDecode(event))
+        return true;
+
+    if (QTextDrag::canDecode(event)) {
+        QString text;
+        QTextDrag::decode(event,text);
+        return !text.startsWith("programs:/");
+    }
+
+    return itemsMovable();
+}
+
+bool KMenuItemDrag::decode(const QMimeSource* e, KMenuItemInfo& item)
+{
+    QByteArray a = e->encodedData("application/kmenuitem");
+
+    if (a.isEmpty()) {
+        QStringList l;
+        bool ret = QUriDrag::decodeToUnicodeUris( e, l );
+        if ( ret )
+        {
+            for ( QStringList::ConstIterator it = l.begin(); it != l.end(); ++it )
+            {
+                QString url = *it;
+                kdDebug () << "Url " << url << endl;
+                item.m_path = KURL( url ).path();
+                if ( KDesktopFile::isDesktopFile( item.m_path ) )
+                {
+                    KDesktopFile df( item.m_path, true );
+                    item.m_description = df.readGenericName();
+                    item.m_icon = df.readIcon();
+                    item.m_title = df.readName();
+                }
+                else
+                {
+                    item.m_title = item.m_path;
+                    item.m_icon = KMimeType::iconForURL( url );
+                    item.m_title = item.m_path.section( '/', -1, -1 );
+                    int last_slash = url.findRev ('/', -1);
+                    if (last_slash == 0)
+                        item.m_description = i18n("Directory: /)");
+                    else
+                        item.m_description = i18n("Directory: ") + url.section ('/', -2, -2);
+                }
+
+                return true;
+            }
+        }
+        return false;
+    }
+
+    QBuffer buff(a);
+    buff.open(IO_ReadOnly);
+    QDataStream s(&buff);
+
+    KMenuItemInfo i;
+    QString storageId;
+    s >> i.m_id >> storageId >> i.m_title >> i.m_description >> i.m_icon >> i.m_path;
+
+    i.m_s = storageId.isEmpty() ? 0 : KService::serviceByStorageId(storageId);
+    item = i;
+
+    return true;
+}
+
+FavoritesItemView::FavoritesItemView(QWidget* parent, const char* name)
+    : ItemView(parent, name)
+{
+}
+
+bool FavoritesItemView::acceptDrag (QDropEvent* event) const
+{
+    if (event->source()==this->viewport())
+        return true;
+
+    if (KMenuItemDrag::canDecode(event)) {
+        KMenuItemInfo item;
+        KMenuItemDrag::decode(event,item);
+        QStringList favs = KickerSettings::favorites();
+
+        if (item.m_s)
+            return favs.find(item.m_s->storageId())==favs.end();
+        else {
+            QStringList::Iterator it;
+
+            QString uri = item.m_path;
+
+            if (uri.startsWith(locateLocal("data", QString::fromLatin1("RecentDocuments/")))) {
+               KDesktopFile df(uri,true);
+               uri=df.readURL();
+            }
+
+            for (it = favs.begin(); it != favs.end(); ++it) {
+                if ((*it)[0]=='/') {
+                    KDesktopFile df((*it),true);
+                    if (df.readURL().replace("file://",QString::null)==uri)
+                        break;
+                }
+            }
+            return it==favs.end();
+        }
+    }
+
+    if (QTextDrag::canDecode(event)) {
+        QString text;
+        QTextDrag::decode(event,text);
+        QStringList favs = KickerSettings::favorites();
+
+        if (text.endsWith(".desktop")) {
+            KService::Ptr p = KService::serviceByDesktopPath(text.replace("file://",QString::null));
+            return (p && favs.find(p->storageId())==favs.end());
+        }
+        else {
+            QStringList::Iterator it;
+            for (it = favs.begin(); it != favs.end(); ++it) {
+                if ((*it)[0]=='/') {
+                    KDesktopFile df((*it),true);
+                    if (df.readURL().replace("file://",QString::null)==text)
+                        break;
+                }
+            }
+            return it==favs.end();
+        }
+    }
+
+    return itemsMovable();
+}
+
+#include "itemview.moc"
+
+// vim:cindent:sw=4:
diff -Nurp kicker.orig/kicker/ui/itemview.h kicker/kicker/ui/itemview.h
--- kicker.orig/kicker/ui/itemview.h	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/ui/itemview.h	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,260 @@
+/*****************************************************************
+
+Copyright (c) 1996-2000 the kicker authors. See file AUTHORS.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#ifndef __itemview_h__
+#define __itemview_h__
+
+#include <dcopobject.h>
+#include <qintdict.h>
+#include <qpixmap.h>
+#include <qframe.h>
+#include <qtoolbutton.h>
+#include <klistview.h>
+#include <qdragobject.h>
+
+#include "kmenubase.h"
+#include "kmenuitembase.h"
+#include "service_mnu.h"
+
+class KickerClientMenu;
+class KBookmarkMenu;
+class KActionCollection;
+class KBookmarkOwner;
+class Panel;
+class QWidgetStack;
+class KHistoryCombo;
+class QScrollView;
+class PopupMenuTitle;
+class QWidget;
+class QVBoxLayout;
+class QTimer;
+class KPixmap;
+
+class KMenuItem : public QListViewItem
+{
+public:
+    KMenuItem(int nId, QListView* parent) : QListViewItem(parent), m_id(nId) { init(); }
+    KMenuItem(int nId, QListViewItem* parent) : QListViewItem(parent), m_id(nId) { init(); }
+    ~KMenuItem();
+
+    void setIcon(const QString& icon, int size);
+    QString icon() const { return m_icon; }
+    void setTitle( const QString& text );
+    QString title() const { return m_title; }
+    void setToolTip( const QString& text );
+    QString toolTip() const { return m_tooltip; }
+    void setDescription(const QString& text);
+    QString description() const { return m_description; }
+    void setService(KService::Ptr& s) { m_s = s; }
+    KService::Ptr service() { return m_s; }
+    void setPath(const QString& u) { m_path = u; }
+    QString path() const { return m_path; }
+    void setMenuPath(const QString& u) { m_menuPath = u; }
+    QString menuPath() const { return m_menuPath; }
+    int id() const { return m_id; }
+    void setHasChildren(bool flag);
+    bool hasChildren() const { return m_has_children; }
+    void makeGradient(KPixmap &off, const QColor& c);
+
+protected:
+    virtual void paintCell(QPainter* p, const QColorGroup & cg, int column, int width, int align);
+    virtual void paintCellInter(QPainter* p, const QColorGroup & cg, int column, int width, int align);
+    virtual void setup();
+
+private:
+    void init();
+
+    int m_id;
+    KService::Ptr m_s;
+    QString m_title;
+    QString m_description;
+    QString m_path;
+    QString m_icon;
+    QString m_tooltip;
+    QString m_menuPath;
+    float title_font_size;
+    float description_font_size;
+    bool m_has_children;
+    int m_old_width;
+    QPixmap right_triangle;
+};
+
+class KMenuItemSeparator : public KMenuItem
+{
+public:
+    KMenuItemSeparator(int nId, QListView* parent);
+    virtual void setup();
+
+    virtual void paintCell(QPainter* p, const QColorGroup & cg, int column, int width, int align);
+    void setLink(const QString &text, const QString &link = QString::null );
+
+    QString linkUrl() const { return m_link_url; }
+
+    /// returns true if the cursor has to change
+    bool hitsLink(const QPoint &pos);
+
+protected:
+    void preparePixmap(int width);
+    QPixmap pixmap;
+    int left_margin;
+
+private:
+    QListView* lv;
+    int cached_width;
+    QString m_link_text, m_link_url;
+    QRect m_link_rect;
+
+};
+
+class KMenuItemHeader : public KMenuItemSeparator
+{
+public:
+    KMenuItemHeader( int nId, const QString &relpath, QListView* parent);
+    virtual void setup();
+
+    virtual void paintCell(QPainter* p, const QColorGroup & cg, int column, int width, int align);
+
+private:
+    QListView* lv;
+    QStringList paths;
+    QStringList texts;
+    QStringList icons;
+    QPixmap left_triangle;
+};
+
+class KMenuSpacer : public KMenuItem
+{
+public:
+    KMenuSpacer(int nId, QListView* parent);
+    virtual void paintCell(QPainter* p, const QColorGroup & cg, int column, int width, int align);
+    virtual void setup();
+
+    void setHeight(int);
+};
+
+class ItemView : public KListView
+{
+    friend class KMenuItem;
+
+    Q_OBJECT
+public:
+    ItemView(QWidget* parent, const char* name = 0);
+
+    KMenuItem* insertItem( const QString& icon, const QString& text, const QString& description, int nId, int nIndex, KMenuItem* parentItem = 0 );
+    KMenuItem* insertItem( const QString& icon, const QString& text, const QString& description, const QString& path, int nId, int nIndex, KMenuItem* parentItem = 0 );
+    int insertItem( PopupMenuTitle*, int, int);
+    int setItemEnabled(int id, bool enabled);
+    KMenuItemSeparator *insertSeparator(int id, const QString& text, int nIndex);
+    KMenuItemHeader *insertHeader(int id, const QString &relpath);
+    KMenuItem* insertMenuItem(KService::Ptr & s, int nId, int nIndex = -1, KMenuItem* parentItem = 0,
+                        const QString &aliasname = QString::null, const QString &label = QString::null,
+                        const QString &categoryIcon = QString::null);
+    KMenuItem* insertRecentlyItem(const QString& s, int nId, int nIndex = -1);
+    KMenuItem* insertDocumentItem(const QString& s, int nId, int nIndex = -1 , const QStringList* suppressGenericNames = 0,
+                        const QString& aliasname = QString::null);
+    KMenuItem* insertSubItem(const QString& icon, const QString& caption, const QString& description, const QString& path, KMenuItem* parentItem);
+    KMenuItem* findItem(int nId);
+
+    void setIconSize(int size) { m_iconSize = size; }
+    void setMouseMoveSelects(bool select) { m_mouseMoveSelects = select; }
+    void clear();
+    int goodHeight();
+    QString path;
+    void setBackPath( const QString &str ) { m_back_url = str; }
+    QString backPath() const { return m_back_url; }
+
+public slots:
+    void slotItemClicked(QListViewItem*);
+    void slotMoveContent();
+
+signals:
+    void startService(KService::Ptr kservice);
+    void startURL(const QString& u);
+
+protected:
+    void contentsMouseMoveEvent(QMouseEvent *e);
+    void contentsMousePressEvent ( QMouseEvent * e );
+    void contentsWheelEvent(QWheelEvent *e);
+    void leaveEvent(QEvent *e);
+    virtual void resizeEvent ( QResizeEvent * e );
+    virtual void viewportPaintEvent ( QPaintEvent * pe );
+    virtual QDragObject* dragObject ();
+    virtual bool acceptDrag (QDropEvent* event) const;
+    virtual bool focusNextPrevChild(bool next);
+
+private slots:
+    void slotItemClicked(int button, QListViewItem * item, const QPoint & pos, int c );
+
+private:
+    KMenuItem* itemAtIndex(int nIndex);
+    void moveItemToIndex(KMenuItem*, int);
+
+    QWidget* m_itemBox;
+    QVBoxLayout* m_itemLayout;
+    KMenuItem *m_lastOne;
+    KMenuSpacer *m_spacer;
+
+    QString m_back_url;
+
+    bool m_mouseMoveSelects;
+    int m_iconSize;
+    int m_old_contentY;
+};
+
+class FavoritesItemView : public ItemView
+{
+public:
+    FavoritesItemView(QWidget* parent, const char* name = 0);
+
+protected:
+    virtual bool acceptDrag (QDropEvent* event) const;
+};
+
+class KMenuItemInfo
+{
+public:
+    int m_id;
+    KService::Ptr m_s;
+    QString m_title;
+    QString m_description;
+    QString m_path;
+    QString m_icon;
+};
+
+class KMenuItemDrag : public QDragObject
+{
+    public:
+        KMenuItemDrag(KMenuItem& item, QWidget *dragSource);
+        ~KMenuItemDrag();
+
+        virtual const char * format(int i = 0) const;
+        virtual QByteArray encodedData(const char *) const;
+
+        static bool canDecode(const QMimeSource * e);
+        static bool decode(const QMimeSource* e, KMenuItemInfo& item);
+
+    private:
+        QByteArray a;
+};
+
+#endif
diff -Nurp kicker.orig/kicker/ui/kickoff_bar.cpp kicker/kicker/ui/kickoff_bar.cpp
--- kicker.orig/kicker/ui/kickoff_bar.cpp	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/ui/kickoff_bar.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,200 @@
+/*****************************************************************
+
+   Copyright (c) 1996-2000 the kicker authors. See file AUTHORS.
+   Copyright (c) 2006 Dirk Mueller <mueller@kde.org>
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+
+******************************************************************/
+
+#include "kickoff_bar.h"
+#include "itemview.h"
+
+#include <qiconset.h>
+#include <qpainter.h>
+#include <qcursor.h>
+#include <qstyle.h>
+#include <qapplication.h>
+
+#include <kdebug.h>
+#include "kickerSettings.h"
+
+KickoffTabBar::KickoffTabBar(QWidget* parent, const char* name)
+        : QTabBar(parent, name), m_tabsActivated(true)
+{
+    setAcceptDrops(true);
+}
+
+void KickoffTabBar::deactivateTabs(bool b)
+{
+    m_tabsActivated = !b;
+
+    update();
+}
+
+void KickoffTabBar::paint(QPainter* p, QTab* t, bool selected) const
+{
+    QStyle::SFlags flags = QStyle::Style_Default;
+
+    if (isEnabled() && t->isEnabled())
+        flags |= QStyle::Style_Enabled;
+    if ( m_tabsActivated && selected )
+        flags |= QStyle::Style_Selected;
+//    else if(t == d->pressed)
+//        flags |= QStyle::Style_Sunken;
+    //selection flags
+    if(t->rect().contains(mapFromGlobal(QCursor::pos())))
+        flags |= QStyle::Style_MouseOver;
+    style().drawControl( QStyle::CE_TabBarTab, p, this, t->rect(),
+            colorGroup(), flags, QStyleOption(t) );
+
+    paintLabel( p, t->rect(), t, t->identifier() == keyboardFocusTab() );
+}
+
+
+void KickoffTabBar::paintLabel(QPainter* p, const QRect& br, QTab* t, bool has_focus) const
+{
+    QRect r = br;
+
+    bool selected = m_tabsActivated && (currentTab() == t->identifier());
+    int vframe = style().pixelMetric( QStyle::PM_TabBarTabVSpace, this );
+
+    p->setFont( font() );
+    QFontMetrics fm = p->fontMetrics();
+    int fw = fm.size( Qt::SingleLine|Qt::ShowPrefix, t->text() ).width();
+
+    QRect rt(r);
+    rt.setWidth(fw);
+
+    if ( t->iconSet()) 
+    {
+        // the tab has an iconset, draw it in the right mode
+        QIconSet::Mode mode = (t->isEnabled() && isEnabled())
+            ? QIconSet::Normal : QIconSet::Disabled;
+        if ( mode == QIconSet::Normal && has_focus )
+            mode = QIconSet::Active;
+        QPixmap pixmap = t->iconSet()->pixmap( QIconSet::Large, mode );
+        int pixw = pixmap.width();
+        int pixh = pixmap.height();
+        int xoff = br.x() + (br.width() - pixw)/2;
+        int yoff = br.y() + (br.height() - 4 - pixh - ((KickerSettings::kickoffTabBarFormat() != KickerSettings::IconOnly) ? fm.height() : 0) - vframe)/2;
+
+        p->drawPixmap( xoff, 4 + yoff, pixmap );
+
+        r.setTop(vframe/2 + yoff + pixh - 8);
+        rt.setTop(vframe/2 + yoff + pixh - 8);
+        rt.setHeight(((KickerSettings::kickoffTabBarFormat() != KickerSettings::IconOnly) ? fm.height() : 0) + vframe/2);
+    }
+    else
+        rt.setHeight(vframe/2 + fm.height());
+
+    rt.setWidth(fw+8);
+    rt.moveCenter(r.center());
+
+    QStyle::SFlags flags = QStyle::Style_Default;
+
+    if (isEnabled() && t->isEnabled())
+        flags |= QStyle::Style_Enabled;
+    if (has_focus)
+        flags |= QStyle::Style_HasFocus;
+    if ( selected )
+        flags |= QStyle::Style_Selected;
+ //   else if(t == d->pressed)
+ //       flags |= QStyle::Style_Sunken;
+    if(t->rect().contains(mapFromGlobal(QCursor::pos())))
+        flags |= QStyle::Style_MouseOver;
+    style().drawControl( QStyle::CE_TabBarLabel, p, this, rt,
+            t->isEnabled() ? colorGroup(): palette().disabled(),
+            flags, QStyleOption(t) );
+}
+
+QSize KickoffTabBar::sizeHint() const
+{
+    QSize s = QTabBar::sizeHint();
+
+    return s;
+}
+
+void KickoffTabBar::layoutTabs()
+{
+    QTabBar::layoutTabs();
+
+    QFontMetrics fm = fontMetrics();
+    int fh = ((KickerSettings::kickoffTabBarFormat() != KickerSettings::IconOnly) ? fm.height() : 0) + 4;
+
+    int hframe = style().pixelMetric( QStyle::PM_TabBarTabHSpace, this );
+    int vframe = style().pixelMetric( QStyle::PM_TabBarTabVSpace, this );
+    int overlap = style().pixelMetric( QStyle::PM_TabBarTabOverlap, this );
+
+    QSize s;
+    for (int t = 0; t < count(); ++t)
+    {
+        QTab* tab = tabAt(t);
+        if (tab->iconSet())
+            s = s.expandedTo(tab->iconSet()->pixmap(QIconSet::Large, QIconSet::Normal).size());
+    }
+
+    int x = 0;
+    for (int t = 0; t < count(); ++t) {
+        QTab* tab = tabAt(QApplication::reverseLayout() ? count() - t - 1 : t);
+        int h = fh;
+        if (tab->iconSet())
+            h += 4 + s.height() + 4;
+        QRect r = tab->rect();
+
+        int fw = fm.size( Qt::SingleLine|Qt::ShowPrefix, tab->text() ).width();
+        int iw = 0;
+        if ( tab->iconSet() != 0 )
+            iw = tab->iconSet()->pixmap( QIconSet::Large, QIconSet::Normal ).width();
+        int w = QMAX(iw, fw + 6 + 6 ) + hframe;
+        h += ((KickerSettings::kickoffTabBarFormat() != KickerSettings::IconOnly) ? fm.height() : 0) + vframe;
+        tab->setRect(QRect(QPoint(x, 0), style().sizeFromContents(QStyle::CT_TabBarTab, this,
+                    QSize(w, h), QStyleOption(tab))));
+        x += tab->rect().width() - overlap;
+    }
+}
+
+void KickoffTabBar::dragEnterEvent(QDragEnterEvent* event)
+{
+    event->accept(KMenuItemDrag::canDecode(event));
+}
+
+void KickoffTabBar::dragMoveEvent(QDragMoveEvent* event)
+{
+    QTab* t = selectTab(event->pos());
+
+    // ### uhhh, look away
+    if (t && t->identifier() == 0)
+    {
+        setCurrentTab(t);
+    }
+}
+
+void KickoffTabBar::mousePressEvent( QMouseEvent * e )
+{
+    if ( e->button() != LeftButton ) {
+	e->ignore();
+	return;
+    }
+    QTab *t = selectTab( e->pos() );
+    if ( t && t->isEnabled() ) {
+	emit tabClicked(t);
+    }
+    QTabBar::mousePressEvent(e);
+}
+
+#include "kickoff_bar.moc"
+// vim:cindent:sw=4:
diff -Nurp kicker.orig/kicker/ui/kickoff_bar.h kicker/kicker/ui/kickoff_bar.h
--- kicker.orig/kicker/ui/kickoff_bar.h	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/ui/kickoff_bar.h	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,53 @@
+/*****************************************************************
+
+   Copyright (c) 1996-2000 the kicker authors. See file AUTHORS.
+   Copyright (c) 2006 Dirk Mueller <mueller@kde.org>
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+
+******************************************************************/
+
+#ifndef __kickoff_bar_h__
+#define __kickoff_bar_h__
+
+#include <qtabbar.h>
+
+class KickoffTabBar : public QTabBar
+{
+    Q_OBJECT
+public:
+    KickoffTabBar(QWidget* parent, const char* name);
+
+    void deactivateTabs(bool b);
+    virtual QSize sizeHint() const;
+
+protected:
+    virtual void paint(QPainter*, QTab*, bool) const;
+    virtual void paintLabel(QPainter* p, const QRect& br, QTab* t, bool has_focus) const;
+    virtual void layoutTabs();
+    virtual void dragEnterEvent(QDragEnterEvent*);
+    virtual void dragMoveEvent(QDragMoveEvent*);
+    virtual void mousePressEvent ( QMouseEvent * );
+
+signals:
+    void tabClicked(QTab*);
+
+private:
+    bool m_tabsActivated;
+};
+
+
+#endif
diff -Nurp kicker.orig/kicker/ui/kmenubase.ui kicker/kicker/ui/kmenubase.ui
--- kicker.orig/kicker/ui/kmenubase.ui	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/ui/kmenubase.ui	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,300 @@
+<!DOCTYPE UI><UI version="3.3" stdsetdef="1">
+<class>KMenuBase</class>
+<widget class="QDialog">
+    <property name="name">
+        <cstring>KMenu</cstring>
+    </property>
+    <property name="geometry">
+        <rect>
+            <x>0</x>
+            <y>0</y>
+            <width>723</width>
+            <height>580</height>
+        </rect>
+    </property>
+    <property name="caption">
+        <string>KMenu</string>
+    </property>
+    <property name="frameShadow" stdset="0">
+        <string>MShadow</string>
+    </property>
+    <property name="frameShape" stdset="0">
+        <string>MShape</string>
+    </property>
+    <widget class="QLayoutWidget">
+        <property name="name">
+            <cstring>m_search</cstring>
+        </property>
+        <property name="geometry">
+            <rect>
+                <x>20</x>
+                <y>40</y>
+                <width>190</width>
+                <height>54</height>
+            </rect>
+        </property>
+        <hbox>
+            <property name="name">
+                <cstring>unnamed</cstring>
+            </property>
+            <property name="margin">
+                <number>0</number>
+            </property>
+            <property name="spacing">
+                <number>0</number>
+            </property>
+            <widget class="QFrame">
+                <property name="name">
+                    <cstring>m_searchFrame</cstring>
+                </property>
+                <property name="sizePolicy">
+                    <sizepolicy>
+                        <hsizetype>5</hsizetype>
+                        <vsizetype>0</vsizetype>
+                        <horstretch>0</horstretch>
+                        <verstretch>0</verstretch>
+                    </sizepolicy>
+                </property>
+                <property name="minimumSize">
+                    <size>
+                        <width>0</width>
+                        <height>52</height>
+                    </size>
+                </property>
+                <property name="maximumSize">
+                    <size>
+                        <width>32767</width>
+                        <height>52</height>
+                    </size>
+                </property>
+                <property name="frameShape">
+                    <enum>StyledPanel</enum>
+                </property>
+                <property name="frameShadow">
+                    <enum>Raised</enum>
+                </property>
+                <property name="lineWidth">
+                    <number>0</number>
+                </property>
+                <hbox>
+                    <property name="name">
+                        <cstring>unnamed</cstring>
+                    </property>
+                    <widget class="QLayoutWidget">
+                        <property name="name">
+                            <cstring>layout18</cstring>
+                        </property>
+                        <hbox>
+                            <property name="name">
+                                <cstring>unnamed</cstring>
+                            </property>
+                            <widget class="QLabel">
+                                <property name="name">
+                                    <cstring>m_searchLabel</cstring>
+                                </property>
+                                <property name="backgroundOrigin">
+                                    <enum>ParentOrigin</enum>
+                                </property>
+                                <property name="font">
+                                    <font>
+                                        <pointsize>14</pointsize>
+                                    </font>
+                                </property>
+                                <property name="text">
+                                    <string>Search:</string>
+                                </property>
+                            </widget>
+                            <widget class="KHistoryCombo">
+                                <property name="name">
+                                    <cstring>m_kcommand</cstring>
+                                </property>
+                                <property name="sizePolicy">
+                                    <sizepolicy>
+                                        <hsizetype>7</hsizetype>
+                                        <vsizetype>0</vsizetype>
+                                        <horstretch>0</horstretch>
+                                        <verstretch>0</verstretch>
+                                    </sizepolicy>
+                                </property>
+                            </widget>
+                            <widget class="QLabel">
+                                <property name="name">
+                                    <cstring>m_searchPixmap</cstring>
+                                </property>
+                                <property name="sizePolicy">
+                                    <sizepolicy>
+                                        <hsizetype>1</hsizetype>
+                                        <vsizetype>1</vsizetype>
+                                        <horstretch>0</horstretch>
+                                        <verstretch>0</verstretch>
+                                    </sizepolicy>
+                                </property>
+                                <property name="minimumSize">
+                                    <size>
+                                        <width>32</width>
+                                        <height>32</height>
+                                    </size>
+                                </property>
+                                <property name="maximumSize">
+                                    <size>
+                                        <width>32</width>
+                                        <height>32</height>
+                                    </size>
+                                </property>
+                                <property name="backgroundMode">
+                                    <enum>PaletteBackground</enum>
+                                </property>
+                                <property name="backgroundOrigin">
+                                    <enum>ParentOrigin</enum>
+                                </property>
+                                <property name="scaledContents">
+                                    <bool>true</bool>
+                                </property>
+                            </widget>
+                        </hbox>
+                    </widget>
+                </hbox>
+            </widget>
+            <spacer>
+                <property name="name">
+                    <cstring>spacer5_2</cstring>
+                </property>
+                <property name="orientation">
+                    <enum>Horizontal</enum>
+                </property>
+                <property name="sizeType">
+                    <enum>Preferred</enum>
+                </property>
+                <property name="sizeHint">
+                    <size>
+                        <width>16</width>
+                        <height>20</height>
+                    </size>
+                </property>
+            </spacer>
+        </hbox>
+    </widget>
+    <widget class="QLayoutWidget">
+        <property name="name">
+            <cstring>m_footer</cstring>
+        </property>
+        <property name="geometry">
+            <rect>
+                <x>20</x>
+                <y>110</y>
+                <width>407</width>
+                <height>34</height>
+            </rect>
+        </property>
+        <hbox>
+            <property name="name">
+                <cstring>unnamed</cstring>
+            </property>
+            <property name="margin">
+                <number>4</number>
+            </property>
+            <property name="spacing">
+                <number>4</number>
+            </property>
+            <widget class="QLabel">
+                <property name="name">
+                    <cstring>m_userInfo</cstring>
+                </property>
+                <property name="sizePolicy">
+                    <sizepolicy>
+                        <hsizetype>3</hsizetype>
+                        <vsizetype>0</vsizetype>
+                        <horstretch>0</horstretch>
+                        <verstretch>0</verstretch>
+                    </sizepolicy>
+                </property>
+                <property name="text">
+                    <string>User&amp;nbsp;&lt;b&gt;user&lt;/b&gt;&amp;nbsp;on&amp;nbsp;&lt;b&gt;host&lt;/b&gt;</string>
+                </property>
+            </widget>
+            <spacer>
+                <property name="name">
+                    <cstring>spacer13_2</cstring>
+                </property>
+                <property name="orientation">
+                    <enum>Horizontal</enum>
+                </property>
+                <property name="sizeType">
+                    <enum>MinimumExpanding</enum>
+                </property>
+                <property name="sizeHint">
+                    <size>
+                        <width>10</width>
+                        <height>20</height>
+                    </size>
+                </property>
+            </spacer>
+            <widget class="QToolButton">
+                <property name="name">
+                    <cstring>m_branding</cstring>
+                </property>
+                <property name="sizePolicy">
+                    <sizepolicy>
+                        <hsizetype>4</hsizetype>
+                        <vsizetype>4</vsizetype>
+                        <horstretch>0</horstretch>
+                        <verstretch>0</verstretch>
+                    </sizepolicy>
+                </property>
+                <property name="maximumSize">
+                    <size>
+                        <width>90</width>
+                        <height>24</height>
+                    </size>
+                </property>
+                <property name="text">
+                    <string></string>
+                </property>
+                <property name="iconSet">
+                    <iconset>image0</iconset>
+                </property>
+                <property name="usesBigPixmap">
+                    <bool>true</bool>
+                </property>
+                <property name="autoRaise">
+                    <bool>true</bool>
+                </property>
+            </widget>
+            <spacer>
+                <property name="name">
+                    <cstring>spacer13</cstring>
+                </property>
+                <property name="orientation">
+                    <enum>Horizontal</enum>
+                </property>
+                <property name="sizeType">
+                    <enum>Fixed</enum>
+                </property>
+                <property name="sizeHint">
+                    <size>
+                        <width>14</width>
+                        <height>20</height>
+                    </size>
+                </property>
+            </spacer>
+        </hbox>
+    </widget>
+</widget>
+<customwidgets>
+</customwidgets>
+<images>
+    <image name="image0">
+        <data format="XPM.GZ" length="2522">789cdd933d6fdb30104077ff0a21de8c82b12d5bb2507448f6021d0b141dc82369d9116d7d50b1ada2ffbdbca3c4444950244032b4b790efce7cd29de8eb59f4fddbd768763d692cb73b8820e7753493ad31971f3fbffc9a5c6d36d17219c5f36871f56972e57e104dd7324be325a2464cd24cc60a5120a6731eaf046241c879b64e113bc44dcc751223da802bc41de16ac092508a753a4754885922440a8892301332a5e79e10f91c169b0cf1963083345b231a423ee0bec78dc71c51c420393578249432e664be2354d2bd17628d0889cc0447bc20cab9d490205601a9df29e142cd3d9e0933b59234ba0321576b49d3d8f69878bc41544b952a6abf218c9590f41a9c70a5c0e33d21e885a2e1b4883ad1a9de2032420ac20f8affde3df5415bdea7f8b8c0fbed507fa59b0bf02119739f9172b46e755fc819dbf55bd07ba15fef0ec7f6b41f728c0dcf84bbc76ebedfbfde0d2042eb8fdd5b801de5b794281e06f716f7ee710f619d5227a1b01b1d0aeedc18e366660ec7b2ac18ab1d1a9745acd1ad3161f28631dbbb716d86c29112c2f86363770ec20a383a89b51a9a06b4b5503a2c10dd771b46d98cdcac180a052528cc13b781b6bd7759506d5b435541ddb6161cba16c0f5a174383872b3729057c19dbfe06ed16ddab642b7324638b77b870add3eaae76e1fb577db17e7fdcc5d586bcd5fddc59bdda7deed7d83db580a81ee93bb906eefd4ee0fa24201ddda53f9d4ad4ce92605fae466713843614ceddd17b83008d1b06618bd2b5e42de3da70b7019dfc1b2eb3af7e140a9ae7342d3d152babb75ee1a76ea7c9478ea5c92bd3bf6c7a870f6677cdc8cdd7d840bf40ef1cc7dfb716efd81eef78c7fd6fdfbf3e40f51236246</data>
+    </image>
+</images>
+<includes>
+    <include location="local" impldecl="in implementation">kmenubase.ui.h</include>
+</includes>
+<functions>
+    <function access="private" specifier="non virtual">init()</function>
+</functions>
+<layoutdefaults spacing="6" margin="11"/>
+<includehints>
+    <includehint>kcombobox.h</includehint>
+</includehints>
+</UI>
diff -Nurp kicker.orig/kicker/ui/kmenubase.ui.h kicker/kicker/ui/kmenubase.ui.h
--- kicker.orig/kicker/ui/kmenubase.ui.h	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/ui/kmenubase.ui.h	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,9 @@
+#include <X11/Xlib.h>
+
+void KMenuBase::init()
+{
+    XSetWindowAttributes attrs;
+    attrs.override_redirect = True;
+    XChangeWindowAttributes( qt_xdisplay(), winId(), CWOverrideRedirect, &attrs );
+    setWFlags( Qt::WType_Popup );
+}
diff -Nurp kicker.orig/kicker/ui/kmenuitembase.ui kicker/kicker/ui/kmenuitembase.ui
--- kicker.orig/kicker/ui/kmenuitembase.ui	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/ui/kmenuitembase.ui	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,141 @@
+<!DOCTYPE UI><UI version="3.3" stdsetdef="1">
+<class>KMenuItemBase</class>
+<widget class="QWidget">
+    <property name="name">
+        <cstring>KMenuItemBase</cstring>
+    </property>
+    <property name="geometry">
+        <rect>
+            <x>0</x>
+            <y>0</y>
+            <width>514</width>
+            <height>80</height>
+        </rect>
+    </property>
+    <property name="sizePolicy">
+        <sizepolicy>
+            <hsizetype>7</hsizetype>
+            <vsizetype>5</vsizetype>
+            <horstretch>0</horstretch>
+            <verstretch>0</verstretch>
+        </sizepolicy>
+    </property>
+    <property name="minimumSize">
+        <size>
+            <width>0</width>
+            <height>0</height>
+        </size>
+    </property>
+    <property name="maximumSize">
+        <size>
+            <width>32767</width>
+            <height>80</height>
+        </size>
+    </property>
+    <property name="caption">
+        <string>KMenuItemBase</string>
+    </property>
+    <grid>
+        <property name="name">
+            <cstring>unnamed</cstring>
+        </property>
+        <property name="margin">
+            <number>2</number>
+        </property>
+        <widget class="QLayoutWidget" row="0" column="1">
+            <property name="name">
+                <cstring>layout11</cstring>
+            </property>
+            <vbox>
+                <property name="name">
+                    <cstring>unnamed</cstring>
+                </property>
+                <widget class="QLabel">
+                    <property name="name">
+                        <cstring>itemTitle</cstring>
+                    </property>
+                    <property name="sizePolicy">
+                        <sizepolicy>
+                            <hsizetype>7</hsizetype>
+                            <vsizetype>1</vsizetype>
+                            <horstretch>1</horstretch>
+                            <verstretch>0</verstretch>
+                        </sizepolicy>
+                    </property>
+                    <property name="font">
+                        <font>
+                            <pointsize>14</pointsize>
+                        </font>
+                    </property>
+                    <property name="text">
+                        <string></string>
+                    </property>
+                    <property name="textFormat">
+                        <enum>RichText</enum>
+                    </property>
+                    <property name="alignment">
+                        <set>WordBreak|AlignTop</set>
+                    </property>
+                </widget>
+                <widget class="QLabel">
+                    <property name="name">
+                        <cstring>itemDescription</cstring>
+                    </property>
+                    <property name="sizePolicy">
+                        <sizepolicy>
+                            <hsizetype>7</hsizetype>
+                            <vsizetype>7</vsizetype>
+                            <horstretch>0</horstretch>
+                            <verstretch>1</verstretch>
+                        </sizepolicy>
+                    </property>
+                    <property name="paletteForegroundColor">
+                        <color>
+                            <red>188</red>
+                            <green>188</green>
+                            <blue>188</blue>
+                        </color>
+                    </property>
+                    <property name="text">
+                        <string></string>
+                    </property>
+                    <property name="textFormat">
+                        <enum>RichText</enum>
+                    </property>
+                    <property name="alignment">
+                        <set>WordBreak|AlignTop</set>
+                    </property>
+                </widget>
+            </vbox>
+        </widget>
+        <widget class="QLayoutWidget" row="0" column="0">
+            <property name="name">
+                <cstring>layout4</cstring>
+            </property>
+            <vbox>
+                <property name="name">
+                    <cstring>unnamed</cstring>
+                </property>
+                <widget class="QLabel">
+                    <property name="name">
+                        <cstring>itemPixmap</cstring>
+                    </property>
+                    <property name="minimumSize">
+                        <size>
+                            <width>64</width>
+                            <height>64</height>
+                        </size>
+                    </property>
+                    <property name="text">
+                        <string></string>
+                    </property>
+                    <property name="alignment">
+                        <set>AlignTop|AlignHCenter</set>
+                    </property>
+                </widget>
+            </vbox>
+        </widget>
+    </grid>
+</widget>
+<layoutdefaults spacing="6" margin="11"/>
+</UI>
diff -Nurp kicker.orig/kicker/ui/k_mnu_stub.cpp kicker/kicker/ui/k_mnu_stub.cpp
--- kicker.orig/kicker/ui/k_mnu_stub.cpp	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/ui/k_mnu_stub.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,141 @@
+/*****************************************************************
+
+Copyright (c) 2006 Dirk Mueller <mueller@kde.org>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#include "k_mnu_stub.h"
+#include "k_new_mnu.h"
+#include "k_mnu.h"
+
+void KMenuStub::removeClientMenu(int id)
+{
+    if(m_type == t_KMenu)
+	return m_w.kmenu->removeClientMenu(id);
+    return m_w.panelkmenu->removeClientMenu(id);
+}
+
+int KMenuStub::insertClientMenu(KickerClientMenu *p)
+{
+    if(m_type == t_KMenu)
+	return m_w.kmenu->insertClientMenu(p);
+    return m_w.panelkmenu->insertClientMenu(p);
+}
+
+void KMenuStub::adjustSize()
+{ 
+    if(m_type == t_KMenu)
+	return m_w.kmenu->adjustSize();
+    return m_w.panelkmenu->adjustSize();
+}
+
+void KMenuStub::hide()
+{   
+    if(m_type == t_KMenu)
+	return m_w.kmenu->hide();
+    return m_w.panelkmenu->hide();
+}
+
+void KMenuStub::show()
+{   
+    if(m_type == t_KMenu)
+	return m_w.kmenu->show();
+    return m_w.panelkmenu->show();
+}
+
+void KMenuStub::showMenu()
+{   
+    if(m_type == t_KMenu)
+	return m_w.kmenu->showMenu();
+    return m_w.panelkmenu->showMenu();
+}
+
+#if 0
+void KMenuStub::resize()
+{   
+    if(m_type == t_KMenu)
+	return m_w.kmenu->resize();
+    return m_w.panelkmenu->resize();
+}
+#endif
+
+void KMenuStub::popup(const QPoint &pos, int indexAtPoint)
+{   
+    return m_type == t_KMenu ?
+	m_w.kmenu->popup(pos, indexAtPoint)
+       : m_w.panelkmenu->popup(pos, indexAtPoint);
+}
+
+void KMenuStub::selectFirstItem()
+{   
+    if(m_type == t_KMenu)
+	return m_w.kmenu->selectFirstItem();
+    return m_w.panelkmenu->selectFirstItem();
+}
+
+void KMenuStub::resize(int w, int h)
+{   
+    if(m_type == t_KMenu)
+	return m_w.kmenu->resize(w, h);
+    return m_w.panelkmenu->resize(w, h);
+}
+
+QSize KMenuStub::sizeHint() const
+{
+    if(m_type == t_KMenu)
+	return m_w.kmenu->sizeHint();
+    return m_w.panelkmenu->sizeHint();
+}
+
+bool KMenuStub::highlightMenuItem( const QString &menuId )
+{
+    if(m_type == t_KMenu)
+	return m_w.kmenu->highlightMenuItem(menuId);
+    return m_w.panelkmenu->highlightMenuItem(menuId);
+}
+
+void KMenuStub::clearRecentMenuItems()
+{
+    if(m_type == t_KMenu)
+	return m_w.kmenu->clearRecentAppsItems();
+    return m_w.panelkmenu->clearRecentMenuItems();
+}
+
+void KMenuStub::initialize()
+{
+    if(m_type == t_KMenu)
+	return m_w.kmenu->initialize();
+    return m_w.panelkmenu->initialize();
+}
+
+bool KMenuStub::isVisible() const
+{
+    if(m_type == t_KMenu)
+	return m_w.kmenu->isVisible();
+    return m_w.panelkmenu->isVisible();
+}
+
+QWidget* KMenuStub::widget()
+{ 
+    if(m_type == t_KMenu)
+	return m_w.kmenu;
+    return m_w.panelkmenu;
+}
+
diff -Nurp kicker.orig/kicker/ui/k_mnu_stub.h kicker/kicker/ui/k_mnu_stub.h
--- kicker.orig/kicker/ui/k_mnu_stub.h	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/ui/k_mnu_stub.h	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,72 @@
+/*****************************************************************
+
+Copyright (c) 2006 Dirk Mueller <mueller@kde.org>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#ifndef __k_mnu_stub_h__
+#define __k_mnu_stub_h__
+
+#include <qstring.h>
+#include <qpoint.h>
+
+class KickerClientMenu;
+class KMenu;
+class PanelKMenu;
+
+
+
+
+class KMenuStub
+{
+public:
+    KMenuStub(KMenu* _kmenu) 
+      : m_type(t_KMenu)  { m_w.kmenu = _kmenu; }
+    KMenuStub(PanelKMenu* _panelkmenu) 
+      : m_type(t_PanelKMenu) { m_w.panelkmenu = _panelkmenu; }
+    ~KMenuStub() {} 
+
+    void removeClientMenu(int id);
+    int insertClientMenu(KickerClientMenu *p);
+    void adjustSize();
+    void hide();
+    void show();
+    void showMenu();
+    void resize();
+    void popup(const QPoint &pos, int indexAtPoint = -1);
+    void selectFirstItem();
+    void resize(int, int);
+    QSize sizeHint() const;
+    bool highlightMenuItem( const QString &menuId );
+    void clearRecentMenuItems();
+    void initialize();
+
+    QWidget* widget();
+
+    bool isVisible() const;
+private:
+     enum {t_PanelKMenu, t_KMenu} m_type;
+     union {
+        KMenu* kmenu;
+        PanelKMenu* panelkmenu;
+     } m_w;
+};
+
+#endif
diff -Nurp kicker.orig/kicker/ui/k_new_mnu.cpp kicker/kicker/ui/k_new_mnu.cpp
--- kicker.orig/kicker/ui/k_new_mnu.cpp	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/ui/k_new_mnu.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,3779 @@
+/*****************************************************************
+
+   Copyright (c) 1996-2000 the kicker authors. See file AUTHORS.
+   Copyright (c) 2006 Debajyoti Bera <dbera.web@gmail.com>
+   Copyright (c) 2006 Dirk Mueller <mueller@kde.org>
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+
+******************************************************************/
+
+#include <stdlib.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <dmctl.h>
+#include <inttypes.h>
+
+#include <qimage.h>
+#include <qpainter.h>
+#include <qstyle.h>
+#include <qwidgetstack.h>
+#include <qlayout.h>
+#include <qlabel.h>
+#include <qregexp.h>
+#include <qfile.h>
+#include <qstylesheet.h>
+#include <qaccel.h>
+#include <qcursor.h>
+#include <qdir.h>
+#include <qsimplerichtext.h>
+#include <qtooltip.h>
+#include <qtabbar.h>
+
+#include <dcopclient.h>
+#include <kapplication.h>
+#include <kaboutkde.h>
+#include <kaction.h>
+#include <kbookmarkmenu.h>
+#include <kconfig.h>
+#include <kdebug.h>
+#include <kglobal.h>
+#include <kglobalsettings.h>
+#include <kiconloader.h>
+#include <klineedit.h>
+#include <klocale.h>
+#include <kmessagebox.h>
+#include <kstandarddirs.h>
+#include <kcombobox.h>
+#include <kwin.h>
+#include <kdebug.h>
+#include <kuser.h>
+#include <kurllabel.h>
+#include <krun.h>
+#include <kmimetype.h>
+#include <krecentdocument.h>
+#include <kcompletionbox.h>
+#include <kurifilter.h>
+#include <kbookmarkmanager.h>
+#include <kbookmark.h>
+#include <kprocess.h>
+#include <kio/jobclasses.h>
+#include <kio/job.h>
+#include <dcopref.h>
+#include <konq_popupmenu.h>
+#include <konqbookmarkmanager.h>
+#include <kparts/componentfactory.h>
+
+#include "client_mnu.h"
+#include "container_base.h"
+#include "global.h"
+#include "knewbutton.h"
+#include "kicker.h"
+#include "kickerSettings.h"
+#include "konqbookmarkmanager.h"
+#include "menuinfo.h"
+#include "menumanager.h"
+#include "popupmenutitle.h"
+#include "quickbrowser_mnu.h"
+#include "recentapps.h"
+#include "flipscrollview.h"
+#include "itemview.h"
+#include <dmctl.h>
+#include <sys/vfs.h>
+#include <mykickoffsearchinterface.h>
+
+#include "media_watcher.h"
+#include "k_mnu.h"
+#include "k_new_mnu.h"
+#include "k_new_mnu.moc"
+#include "kickoff_bar.h"
+
+#define WAIT_BEFORE_QUERYING 700
+
+#define IDS_PER_CATEGORY 20
+#define ACTIONS_ID_BASE 10
+#define APP_ID_BASE 10 + IDS_PER_CATEGORY
+#define BOOKMARKS_ID_BASE 10 + (IDS_PER_CATEGORY * 2)
+#define NOTES_ID_BASE 10 + (IDS_PER_CATEGORY * 3)
+#define MAIL_ID_BASE 10 + (IDS_PER_CATEGORY * 4)
+#define FILE_ID_BASE 10 + (IDS_PER_CATEGORY * 5)
+#define MUSIC_ID_BASE 10 + (IDS_PER_CATEGORY * 6)
+#define WEBHIST_ID_BASE 10 + (IDS_PER_CATEGORY * 7)
+#define CHAT_ID_BASE 10 + (IDS_PER_CATEGORY * 8)
+#define FEED_ID_BASE 10 + (IDS_PER_CATEGORY * 9)
+#define PIC_ID_BASE 10 + (IDS_PER_CATEGORY * 10)
+#define VIDEO_ID_BASE 10 + (IDS_PER_CATEGORY * 11)
+#define DOC_ID_BASE 10 + (IDS_PER_CATEGORY * 12)
+#define OTHER_ID_BASE 10 + (IDS_PER_CATEGORY * 13)
+
+static QString calculate(const QString &exp)
+{
+   QString result, cmd;
+   const QString bc = KStandardDirs::findExe("bc");
+   if ( !bc.isEmpty() )
+      cmd = QString("echo %1 | %2").arg(KProcess::quote(exp), KProcess::quote(bc));
+   else
+      cmd = QString("echo $((%1))").arg(exp);
+   FILE *fs = popen(QFile::encodeName(cmd).data(), "r");
+   if (fs)
+   {
+      QTextStream ts(fs, IO_ReadOnly);
+      result = ts.read().stripWhiteSpace();
+      pclose(fs);
+   }
+   return result;
+}
+
+static QString workaroundStringFreeze(const QString& str)
+{
+    QString s = str;
+
+    s.replace("<u>","&");
+    QRegExp re("<[^>]+>");
+    re.setMinimal(true);
+    re.setCaseSensitive(false);
+
+    s.replace(re, "");
+    s = s.simplifyWhiteSpace();
+
+    return s;
+}
+
+int base_category_id[] = {ACTIONS_ID_BASE, APP_ID_BASE, BOOKMARKS_ID_BASE, NOTES_ID_BASE, MAIL_ID_BASE,
+                          FILE_ID_BASE, MUSIC_ID_BASE, WEBHIST_ID_BASE, CHAT_ID_BASE, FEED_ID_BASE,
+                          PIC_ID_BASE, VIDEO_ID_BASE, DOC_ID_BASE, OTHER_ID_BASE};
+
+#include <assert.h>
+
+static int used_size( QLabel *label, int oldsize )
+{
+    QSimpleRichText st( label->text(), KGlobalSettings::toolBarFont() );
+    st.setWidth( oldsize );
+    return QMAX( st.widthUsed(), oldsize );
+}
+
+KMenu::KMenu()
+  : KMenuBase(0, "SUSE::Kickoff::KMenu")
+  , m_sloppyTimer(0, "KNewMenu::sloppyTimer"), m_mediaFreeTimer(0, "KNewMenu::mediaFreeTimer"),
+    m_iconName(QString::null),  m_orientation(UnDetermined), m_search_plugin( 0 )
+{
+    setMouseTracking(true);
+    connect(&m_sloppyTimer, SIGNAL(timeout()), SLOT(slotSloppyTimeout()));
+
+    // set the first client id to some arbitrarily large value.
+    client_id = 10000;
+    // Don't automatically clear the main menu.
+    actionCollection = new KActionCollection(this);
+
+    connect(Kicker::the(), SIGNAL(configurationChanged()),
+            this, SLOT(configChanged()));
+
+    KUser * user = new KUser();
+
+    char hostname[256];
+    hostname[0] = '\0';
+    if (!gethostname( hostname, sizeof(hostname) ))
+      hostname[sizeof(hostname)-1] = '\0';
+
+    m_userInfo->setText( i18n( "User&nbsp;<b>%1</b>&nbsp;on&nbsp;<b>%2</b>" )
+                         .arg( user->loginName() ).arg( hostname ) );
+    setupUi();
+
+    m_userInfo->setBackgroundMode( PaletteBase );
+    QColor userInfoColor = QApplication::palette().color( QPalette::Normal, QColorGroup::Mid );
+    if ( qGray( userInfoColor.rgb() ) > 120 )
+        userInfoColor = userInfoColor.dark( 200 );
+    else
+        userInfoColor = userInfoColor.light( 200 );
+    m_userInfo->setPaletteForegroundColor( userInfoColor );
+
+    m_tabBar = new KickoffTabBar(this, "m_tabBar");
+    connect(m_tabBar, SIGNAL(tabClicked(QTab*)), SLOT(tabClicked(QTab*)));
+
+    const int tab_icon_size = 32;
+
+    m_tabs[FavoriteTab] = new QTab;
+    m_tabBar->addTab(m_tabs[FavoriteTab]);
+    m_tabBar->setToolTip(FavoriteTab, "<qt>" + i18n( "Most commonly used applications and documents" )  + "</qt>" );
+    m_tabs[ApplicationsTab] = new QTab;
+    m_tabBar->addTab(m_tabs[ApplicationsTab]);
+    m_tabBar->setToolTip(ApplicationsTab, "<qt>" + i18n( "List of installed applications" ) +
+            "</qt>" );
+
+   m_tabs[ComputerTab] = new QTab;
+    m_tabBar->addTab(m_tabs[ComputerTab]);
+    m_tabBar->setToolTip(ComputerTab, "<qt>" + i18n( "Information and configuration of your "
+                "system, access to personal files, network resources and connected disk drives")
+            + "</qt>");
+#if 0
+    m_tabs[SearchTab] = new QTab;
+    m_tabBar->addTab(m_tabs[SearchTab]);
+#endif
+    m_tabs[HistoryTab] = new QTab;
+    m_tabBar->addTab(m_tabs[HistoryTab]);
+    m_tabBar->setToolTip(HistoryTab, "<qt>" + i18n( "Recently used applications and documents" ) +
+            "</qt>" );
+    m_tabs[LeaveTab] = new QTab;
+    m_tabBar->addTab(m_tabs[LeaveTab]);
+    m_tabBar->setToolTip(LeaveTab, i18n("<qt>Logout, switch user, switch off or reset,"
+               " suspend of the system" ) + "</qt>" );
+
+    if (KickerSettings::kickoffTabBarFormat() != KickerSettings::IconOnly) {
+	m_tabs[FavoriteTab]->setText(workaroundStringFreeze(i18n("<p align=\"center\"> <u>F</u>avorites</p>")));
+	m_tabs[HistoryTab]->setText(workaroundStringFreeze(i18n("<p align=\"center\"><u>H</u>istory</p>")));
+	m_tabs[ComputerTab]->setText(
+        workaroundStringFreeze(i18n("<p align=\"center\"> <u>C</u>omputer</p>")));
+	m_tabs[ApplicationsTab]->setText(workaroundStringFreeze(i18n("<p align=\"center\"><u>A</u>pplications</p>")));
+	m_tabs[LeaveTab]->setText(
+        workaroundStringFreeze(i18n("<p align=\"center\"><u>L</u>eave</p>")));
+    }
+
+    if (KickerSettings::kickoffTabBarFormat() != KickerSettings::LabelOnly) {
+	m_tabs[FavoriteTab]->setIconSet(BarIcon("bookmark", tab_icon_size));
+	m_tabs[HistoryTab]->setIconSet(BarIcon("recently_used", tab_icon_size));
+	m_tabs[ComputerTab]->setIconSet(BarIcon("system", tab_icon_size));
+	m_tabs[ApplicationsTab]->setIconSet(BarIcon("player_playlist", tab_icon_size));
+	m_tabs[LeaveTab]->setIconSet(BarIcon("leave", tab_icon_size));
+    }
+
+    connect(m_tabBar, SIGNAL(selected(int)), m_stacker, SLOT(raiseWidget(int)));
+    connect(m_stacker, SIGNAL(aboutToShow(int)), m_tabBar, SLOT(setCurrentTab(int)));
+
+    m_favoriteView = new FavoritesItemView (m_stacker, "m_favoriteView");
+    m_favoriteView->setAcceptDrops(true);
+    m_favoriteView->setItemsMovable(true);
+    m_stacker->addWidget(m_favoriteView, FavoriteTab);
+
+    m_recentlyView = new ItemView (m_stacker, "m_recentlyView");
+    m_stacker->addWidget(m_recentlyView, HistoryTab);
+
+    m_systemView = new ItemView(m_stacker, "m_systemView");
+    m_stacker->addWidget(m_systemView, ComputerTab );
+
+    m_browserView = new FlipScrollView(m_stacker, "m_browserView");
+    m_stacker->addWidget(m_browserView, ApplicationsTab);
+    connect( m_browserView, SIGNAL( backButtonClicked() ), SLOT( slotGoBack() ) );
+
+    m_exitView = new FlipScrollView(m_stacker, "m_exitView");
+    m_stacker->addWidget(m_exitView, LeaveTab);
+    connect( m_exitView, SIGNAL( backButtonClicked() ), SLOT( slotGoExitMainMenu() ) );
+
+    m_searchWidget = new QVBox (m_stacker, "m_searchWidget");
+    m_searchWidget->setSpacing(0);
+    m_stacker->addWidget(m_searchWidget, 5);
+
+    // search provider icon
+    QPixmap icon;
+    KURIFilterData data;
+    QStringList list;
+    data.setData( QString("some keyword") );
+    list << "kurisearchfilter" << "kuriikwsfilter";
+
+    if ( KURIFilter::self()->filterURI(data, list) ) {
+      QString iconPath = locate("cache", KMimeType::favIconForURL(data.uri()) + ".png");
+      if ( iconPath.isEmpty() )
+        icon = SmallIcon("enhanced_browsing");
+      else
+        icon = QPixmap( iconPath );
+    }
+    else
+      icon = SmallIcon("enhanced_browsing");
+
+    m_searchResultsWidget = new ItemView (m_searchWidget, "m_searchResultsWidget");
+    m_searchResultsWidget->setItemMargin(4);
+    m_searchResultsWidget->setIconSize(16);
+    m_searchActions = new ItemView (m_searchWidget, "m_searchActions");
+    m_searchActions->setFocusPolicy(QWidget::NoFocus);
+    m_searchActions->setItemMargin(4);
+    m_searchInternet = new QListViewItem(m_searchActions, i18n("Search Internet"));
+    m_searchInternet->setPixmap(0,icon);
+    setTabOrder(m_kcommand, m_searchResultsWidget);
+
+    m_kerryInstalled = !KStandardDirs::findExe(QString::fromLatin1("kerry")).isEmpty();
+    m_isShowing = false;
+
+    if (!m_kerryInstalled) {
+       m_searchIndex = 0;
+       m_searchActions->setMaximumHeight(5+m_searchInternet->height());
+    }
+    else {
+       m_searchIndex = new QListViewItem(m_searchActions, i18n("Search Index"));
+       m_searchIndex->setPixmap(0,SmallIcon("kerry"));
+       m_searchActions->setMaximumHeight(5+m_searchIndex->height()*2);
+    }
+    connect(m_searchActions, SIGNAL(clicked(QListViewItem*)), SLOT(searchActionClicked(QListViewItem*)));
+    connect(m_searchActions, SIGNAL(returnPressed(QListViewItem*)), SLOT(searchActionClicked(QListViewItem*)));
+    connect(m_searchActions, SIGNAL(spacePressed(QListViewItem*)), SLOT(searchActionClicked(QListViewItem*)));
+
+    connect(m_searchResultsWidget, SIGNAL(startService(KService::Ptr)), SLOT(slotStartService(KService::Ptr)));
+    connect(m_searchResultsWidget, SIGNAL(startURL(const QString&)), SLOT(slotStartURL(const QString&)));
+    connect(m_searchResultsWidget, SIGNAL(rightButtonPressed( QListViewItem*, const QPoint &, int )), SLOT(slotContextMenuRequested( QListViewItem*, const QPoint &, int )));
+
+    connect(m_recentlyView, SIGNAL(startService(KService::Ptr)), SLOT(slotStartService(KService::Ptr)));
+    connect(m_recentlyView, SIGNAL(startURL(const QString&)), SLOT(slotStartURL(const QString&)));
+    connect(m_recentlyView, SIGNAL(rightButtonPressed( QListViewItem*, const QPoint &, int  )), SLOT(slotContextMenuRequested( QListViewItem*, const QPoint &, int )));
+
+    connect(m_favoriteView, SIGNAL(startService(KService::Ptr)), SLOT(slotStartService(KService::Ptr)));
+    connect(m_favoriteView, SIGNAL(startURL(const QString&)), SLOT(slotStartURL(const QString&)));
+    connect(m_favoriteView, SIGNAL(rightButtonPressed( QListViewItem*, const QPoint &, int  )), SLOT(slotContextMenuRequested( QListViewItem*, const QPoint &, int )));
+    connect(m_favoriteView, SIGNAL(moved(QListViewItem*, QListViewItem*, QListViewItem*)), SLOT(slotFavoritesMoved( QListViewItem*, QListViewItem*, QListViewItem* )));
+
+    connect(m_systemView, SIGNAL(startURL(const QString&)), SLOT(slotStartURL(const QString&)));
+    connect(m_systemView, SIGNAL(startService(KService::Ptr)), SLOT(slotStartService(KService::Ptr)));
+    connect(m_systemView, SIGNAL(rightButtonPressed( QListViewItem*, const QPoint &, int )), SLOT(slotContextMenuRequested( QListViewItem*, const QPoint &, int )));
+
+    connect(m_browserView, SIGNAL(startURL(const QString&)), SLOT(slotGoSubMenu(const QString&)));
+    connect(m_browserView, SIGNAL(startService(KService::Ptr)), SLOT(slotStartService(KService::Ptr)));
+    connect(m_browserView, SIGNAL(rightButtonPressed( QListViewItem*, const QPoint &, int )), SLOT(slotContextMenuRequested( QListViewItem*, const QPoint &, int )));
+
+    connect(m_exitView, SIGNAL(startURL(const QString&)), SLOT(slotStartURL(const QString&)));
+    connect(m_exitView, SIGNAL(rightButtonPressed( QListViewItem*, const QPoint &, int )), SLOT(slotContextMenuRequested( QListViewItem*, const QPoint &, int )));
+
+    m_kcommand->setDuplicatesEnabled( false );
+    m_kcommand->setLineEdit(new KLineEdit(m_kcommand, "m_kcommand-lineedit"));
+    m_kcommand->setCompletionMode( KGlobalSettings::CompletionAuto );
+    connect(m_kcommand, SIGNAL(cleared()), SLOT(clearedHistory()));
+    connect(m_kcommand->lineEdit(), SIGNAL(returnPressed()), SLOT(searchAccept()));
+    connect(m_kcommand->lineEdit(), SIGNAL(textChanged(const QString &)), SLOT(searchChanged(const QString &)));
+
+    // URI Filter meta object...
+    m_filterData = new KURIFilterData();
+
+    max_category_id = new int [num_categories];
+    categorised_hit_total = new int [num_categories];
+
+    input_timer = new QTimer (this, "input_timer");
+    connect( input_timer, SIGNAL(timeout()), this, SLOT(doQuery()) );
+
+    init_search_timer = new QTimer (this, "init_search_timer");
+    connect( init_search_timer, SIGNAL(timeout()), this, SLOT(initSearch()) );
+    init_search_timer->start(2000, true);
+
+    connect( m_favoriteView, SIGNAL( dropped (QDropEvent *, QListViewItem * ) ),
+             SLOT( slotFavDropped( QDropEvent *, QListViewItem * ) ) );
+
+    this->installEventFilter(this);
+    m_tabBar->installEventFilter(this);
+    m_favoriteView->installEventFilter(this);
+    m_recentlyView->installEventFilter(this);
+    m_browserView->leftView()->installEventFilter(this);
+    m_browserView->rightView()->installEventFilter(this);
+    m_systemView->installEventFilter(this);
+    m_exitView->leftView()->installEventFilter(this);
+    m_exitView->rightView()->installEventFilter(this);
+    m_kcommand->lineEdit()->installEventFilter(this);
+    m_searchLabel->installEventFilter(this);
+    m_searchPixmap->installEventFilter(this);
+    m_stacker->installEventFilter(this);
+
+    emailRegExp = QRegExp("^([\\w\\-]+\\.)*[\\w\\-]+@([\\w\\-]+\\.)*[\\w\\-]+$");
+    authRegExp = QRegExp("^[a-zA-Z]+://\\w+(:\\w+)?@([\\w\\-]+\\.)*[\\w\\-]+(:\\d+)?(/.*)?$");
+    uriRegExp = QRegExp("^[a-zA-Z]+://([\\w\\-]+\\.)*[\\w\\-]+(:\\d+)?(/.*)?$");
+    uri2RegExp = QRegExp("^([\\w\\-]+\\.)+[\\w\\-]+(:\\d+)?(/.*)?$");
+
+    m_resizeHandle = new QLabel(this);
+    m_resizeHandle->setBackgroundOrigin( QLabel::ParentOrigin );
+    m_resizeHandle->setScaledContents(true);
+    m_resizeHandle->setFixedSize( 16, 16 );
+    m_searchFrame->stackUnder( m_resizeHandle );
+    m_isresizing = false;
+
+    m_searchPixmap->setPixmap( BarIcon( "find", 32 ) );
+
+    QFont f = font();
+    f.setPointSize( kMax( 7, (f.pointSize() * 4 / 5 ) + KickerSettings::kickoffFontPointSizeOffset() ) );
+    m_tabBar->setFont ( f );
+    f.setPointSize( kMax( 7, (f.pointSize() * 3 / 2 ) + KickerSettings::kickoffFontPointSizeOffset() ) );
+    m_searchLabel->setFont( f );
+
+    static_cast<KLineEdit*>(m_kcommand->lineEdit())->setClickMessage(i18n( "Applications, Contacts and Documents" ) );
+
+    bookmarkManager = 0;
+    m_addressBook = 0;
+    m_popupMenu = 0;
+
+    main_border_tl.load( locate("data", "kicker/pics/main_corner_tl.png" ) );
+    main_border_tr.load( locate("data", "kicker/pics/main_corner_tr.png" ) );
+
+    search_tab_left.load( locate("data", "kicker/pics/search-tab-left.png" ) );
+    search_tab_right.load( locate("data", "kicker/pics/search-tab-right.png" ) );
+    search_tab_center.load( locate("data", "kicker/pics/search-tab-center.png" ) );
+
+    search_tab_top_left.load( locate("data", "kicker/pics/search-tab-top-left.png" ) );
+    search_tab_top_right.load( locate("data", "kicker/pics/search-tab-top-right.png" ) );
+    search_tab_top_center.load( locate("data", "kicker/pics/search-tab-top-center.png" ) );
+}
+
+void KMenu::setupUi()
+{
+    m_stacker = new QWidgetStack( this, "m_stacker" );
+    m_stacker->setGeometry( QRect( 90, 260, 320, 220 ) );
+    m_stacker->setSizePolicy( QSizePolicy( (QSizePolicy::SizeType)3, (QSizePolicy::SizeType)3, 1, 1, m_stacker->sizePolicy().hasHeightForWidth() ) );
+    m_stacker->setPaletteBackgroundColor( QColor( 255, 255, 255 ) );
+   // m_stacker->setFocusPolicy( QWidget::StrongFocus );
+    m_stacker->setLineWidth( 0 );
+    m_stacker->setFocusPolicy(QWidget::NoFocus);
+    connect(m_stacker, SIGNAL(aboutToShow(QWidget*)), SLOT(stackWidgetRaised(QWidget*)));
+
+    m_kcommand->setName("m_kcommand");
+}
+
+KMenu::~KMenu()
+{
+    saveConfig();
+
+    clearSubmenus();
+    delete m_filterData;
+}
+
+bool KMenu::eventFilter ( QObject * receiver, QEvent* e)
+{
+//kdDebug() << "eventFilter receiver=" << receiver->name() << "  type=" << e->type() << endl;
+    QWidget* raiseWidget = 0;
+    QRect raiseRect;
+
+    if (e->type() ==  QEvent::KeyPress ||
+        e->type() == QEvent::MouseButtonPress ||
+        e->type() == QEvent::MouseMove
+        || e->type() == QEvent::FocusIn
+        || e->type() == QEvent::Wheel) {
+        QPoint p;
+
+        if (e->type() == QEvent::MouseMove || e->type() == QEvent::MouseButtonPress) {
+            QMouseEvent* me = static_cast<QMouseEvent*>(e);
+            p = me->globalPos();
+        }
+        else if (e->type() == QEvent::Wheel) {
+            QWheelEvent* we = static_cast<QWheelEvent*>(e);
+            p = we->globalPos();
+        }
+
+        while (receiver) {
+            if (receiver == m_tabBar && (e->type()!=QEvent::MouseMove || KickerSettings::kickoffSwitchTabsOnHover() ) ) {
+                QTab* s = m_tabBar->selectTab(m_tabBar->mapFromGlobal(p));
+                if (s && s->identifier() == ApplicationsTab)
+                    raiseWidget = m_browserView;
+                if (s && s->identifier() == FavoriteTab)
+                    raiseWidget = m_favoriteView;
+                if (s && s->identifier() == HistoryTab)
+                    raiseWidget = m_recentlyView;
+                if (s && s->identifier() == ComputerTab)
+                    raiseWidget = m_systemView;
+                if (s && s->identifier() == LeaveTab)
+                    raiseWidget = m_exitView;
+
+                if (raiseWidget)
+                    raiseRect = QRect( m_tabBar->mapToGlobal(s->rect().topLeft()),
+                                s->rect().size());
+            }
+
+            /* we do not want hover activation for the search line edit as this can be
+             * pretty disturbing */
+            if ( (receiver == m_searchPixmap ||
+                 ( ( receiver == m_searchLabel || receiver==m_kcommand->lineEdit() ) &&
+                 ( e->type() == QEvent::KeyPress || e->type() == QEvent::Wheel
+                   || e->type() == QEvent::MouseButtonPress ) ) ) &&
+                    !m_isShowing) {
+                raiseWidget = m_searchWidget;
+                raiseRect = QRect( m_searchFrame->mapToGlobal(m_searchFrame->rect().topLeft()),
+                        m_searchFrame->size());
+            }
+
+            if(raiseWidget)
+                break;
+            if(receiver->isWidgetType())
+                receiver = static_cast<QWidget*>(receiver)->parentWidget(true);
+            else
+                break;
+        }
+
+        if (e->type() == QEvent::FocusIn && receiver && raiseWidget) {
+            m_searchResultsWidget->setFocusPolicy(QWidget::StrongFocus);
+            m_searchActions->setFocusPolicy(raiseWidget == m_searchWidget ?
+                    QWidget::StrongFocus : QWidget::NoFocus);
+            setTabOrder(raiseWidget, m_searchResultsWidget);
+            if (raiseWidget != m_stacker->visibleWidget()
+                && static_cast<QWidget*>(receiver)->focusPolicy() == QWidget::NoFocus
+                && m_stacker->id(raiseWidget) >= 0) {
+
+                m_stacker->raiseWidget(raiseWidget);
+                return true;
+            }
+
+            if (raiseWidget->focusPolicy() != QWidget::NoFocus)
+                return false;
+        }
+
+	if (m_sloppyRegion.contains(p)) {
+            if (e->type() ==  QEvent::MouseButtonPress /*&& m_sloppyTimer.isActive()*/)
+                m_sloppySourceClicked = true;
+
+            if (!m_sloppyTimer.isActive() || m_sloppySource != raiseRect) {
+                int timeout= style().styleHint(QStyle::SH_PopupMenu_SubMenuPopupDelay);
+                if (m_sloppySourceClicked)
+                    timeout = 3000;
+                m_sloppyTimer.start(timeout);
+            }
+
+	    m_sloppyWidget = raiseWidget;
+	    m_sloppySource = raiseRect;
+	    return false;
+	}
+    }
+
+    if(e->type() == QEvent::Enter && receiver->isWidgetType()) {
+	static_cast<QWidget*>(receiver)->setMouseTracking(true);
+        QToolTip::hide();
+    }
+
+    if ( ( e->type() == QEvent::DragEnter || e->type() == QEvent::DragMove ) &&
+         raiseWidget == m_favoriteView )
+    {
+        m_stacker->raiseWidget(m_favoriteView);
+
+	return false;
+    }
+
+    // This is a nightmare of a hack, look away. Logic needs
+    // to be moved to the stacker and all widgets in the stacker
+    // must have focusNextPrevChild() overwritten to do nothing
+    if (e->type() == QEvent::KeyPress && !raiseRect.isNull()) {
+        ItemView* view;
+        if (m_browserView==m_stacker->visibleWidget())
+            view = m_browserView->currentView();
+        else if (m_exitView==m_stacker->visibleWidget())
+            view = m_exitView->currentView();
+        else
+            view = dynamic_cast<ItemView*>(m_stacker->visibleWidget());
+
+        if (view)
+        {
+            bool handled = true;
+            switch (static_cast<QKeyEvent*>(e)->key()) {
+                case Key_Up:
+                    if (view->selectedItem()) {
+                        view->setSelected(view->selectedItem()->itemAbove(),true);
+                    }
+                    else {
+                        view->setSelected(view->lastItem(),true);
+                    }
+                    break;
+                case Key_Down:
+                    if (view->selectedItem()) {
+                        view->setSelected(view->selectedItem()->itemBelow(),true);
+                    }
+                    else {
+                        if (view->firstChild() && view->firstChild()->isSelectable())
+                           view->setSelected(view->firstChild(),true);
+                        else if (view->childCount()>2)
+                           view->setSelected(view->firstChild()->itemBelow(),true);
+                    }
+                    break;
+                case Key_Right:
+                    if (view->selectedItem() && !static_cast<KMenuItem*>(view->selectedItem())->hasChildren())
+                        break;
+                    // nobreak
+                case Key_Enter:
+                case Key_Return:
+                    if (view->selectedItem())
+                        view->slotItemClicked(view->selectedItem());
+
+                    break;
+                case Key_Left:
+                    if (m_browserView == m_stacker->visibleWidget() || m_exitView == m_stacker->visibleWidget()) {
+                       FlipScrollView* flip = dynamic_cast<FlipScrollView*>(m_stacker->visibleWidget());
+                       if (flip->showsBackButton()) {
+                          if (m_browserView == m_stacker->visibleWidget())
+                             goSubMenu( m_browserView->currentView()->backPath(), true );
+                          else
+                             view->slotItemClicked(view->firstChild());
+                       }
+                       break;
+                    }
+                    // nobreak
+                case Key_Backspace:
+                    if (m_browserView == m_stacker->visibleWidget() || m_exitView == m_stacker->visibleWidget()) {
+                       FlipScrollView* flip = dynamic_cast<FlipScrollView*>(m_stacker->visibleWidget());
+                       if (flip->showsBackButton()) {
+                          if (m_browserView == m_stacker->visibleWidget())
+                             goSubMenu( m_browserView->currentView()->backPath(), true );
+                          else
+                             view->slotItemClicked(view->firstChild());
+                       }
+                    }
+
+                    break;
+                default:
+                    handled = false;
+            }
+
+            if (handled)
+                view->ensureItemVisible(view->selectedItem());
+
+            return handled;
+        }
+    }
+
+    bool r = KMenuBase::eventFilter(receiver, e);
+
+    if (!r && raiseWidget)
+        m_stacker->raiseWidget(raiseWidget);
+
+    if (e->type() == QEvent::Wheel && raiseWidget )
+    {
+        // due to an ugly Qt bug we have to kill wheel events
+        // that cause focus switches
+        r = true;
+    }
+
+    if (e->type() == QEvent::Enter && receiver == m_stacker)
+    {
+        QRect r(m_stacker->mapToGlobal(QPoint(-8,-32)), m_stacker->size());
+        r.setSize(r.size()+QSize(16,128));
+
+        m_sloppyRegion = QRegion(r);
+    }
+
+    // redo the sloppy region
+    if (e->type() == QEvent::MouseMove && !r && raiseWidget)
+    {
+        QPointArray points(4);
+
+        // hmm, eventually this should be mouse position + 10px, not
+        // just worst case. but worst case seems to work fine enough.
+        QPoint edge(raiseRect.topLeft());
+        edge.setX(edge.x()+raiseRect.center().x());
+
+        if (m_orientation == BottomUp)
+        {
+            points.setPoint(0, m_stacker->mapToGlobal(m_stacker->rect().bottomLeft()));
+            points.setPoint(1, m_stacker->mapToGlobal(m_stacker->rect().bottomRight()));
+
+            edge.setY(edge.y()+raiseRect.height());
+            points.setPoint(2, edge+QPoint(+raiseRect.width()/4,0));
+            points.setPoint(3, edge+QPoint(-raiseRect.width()/4,0));
+        }
+        else
+        {
+            points.setPoint(0, m_stacker->mapToGlobal(m_stacker->rect().topLeft()));
+            points.setPoint(1, m_stacker->mapToGlobal(m_stacker->rect().topRight()));
+            points.setPoint(2, edge+QPoint(-raiseRect.width()/4,0));
+            points.setPoint(3, edge+QPoint(+raiseRect.width()/4,0));
+        }
+
+        m_sloppyRegion = QRegion(points);
+    }
+
+    return r;
+}
+
+void KMenu::slotSloppyTimeout()
+{
+    if (m_sloppyRegion.contains(QCursor::pos()) && !m_sloppySource.isNull())
+    {
+        if ( m_sloppySource.contains(QCursor::pos()))
+        {
+            m_stacker->raiseWidget(m_sloppyWidget);
+
+            m_sloppyWidget = 0;
+            m_sloppySource = QRect();
+            m_sloppyRegion = QRegion();
+            m_sloppySourceClicked = false;
+        }
+    }
+    m_sloppyTimer.stop();
+}
+
+void KMenu::paintSearchTab( bool active )
+{
+    QPixmap canvas( m_searchFrame->size() );
+    QPainter p( &canvas );
+
+    QPixmap pix;
+
+    if ( m_orientation == BottomUp )
+        pix.load( locate("data", "kicker/pics/search-gradient.png" ) );
+    else
+        pix.load( locate("data", "kicker/pics/search-gradient-topdown.png" ) );
+
+    pix.convertFromImage( pix.convertToImage().scale(pix.width(), m_searchFrame->height()));
+    p.drawTiledPixmap( 0, 0, m_searchFrame->width(), m_searchFrame->height(), pix );
+
+    if ( active ) {
+
+        m_tabBar->deactivateTabs(true);
+
+        p.setBrush( Qt::white );
+        p.setPen( Qt::NoPen );
+
+        if ( m_orientation == BottomUp ) {
+            search_tab_center.convertFromImage( search_tab_center.convertToImage().scale(search_tab_center.width(), m_searchFrame->height()));
+            p.drawTiledPixmap( search_tab_left.width(), 0, m_searchFrame->width()-search_tab_left.width()-search_tab_right.width(), m_searchFrame->height(), search_tab_center );
+
+            search_tab_left.convertFromImage( search_tab_left.convertToImage().scale(search_tab_left.width(), m_searchFrame->height()));
+            p.drawPixmap( 0, 0, search_tab_left );
+
+            search_tab_right.convertFromImage( search_tab_right.convertToImage().scale(search_tab_right.width(), m_searchFrame->height()));
+            p.drawPixmap( m_searchFrame->width()-search_tab_right.width(), 0, search_tab_right );
+        }
+        else {
+            search_tab_top_center.convertFromImage( search_tab_top_center.convertToImage().scale(search_tab_top_center.width(), m_searchFrame->height()));
+            p.drawTiledPixmap( search_tab_top_left.width(), 0, m_searchFrame->width()-search_tab_top_left.width()-search_tab_top_right.width(), m_searchFrame->height(), search_tab_top_center );
+
+            search_tab_top_left.convertFromImage( search_tab_top_left.convertToImage().scale(search_tab_top_left.width(), m_searchFrame->height()));
+            p.drawPixmap( 0, 0, search_tab_top_left );
+
+            search_tab_top_right.convertFromImage( search_tab_top_right.convertToImage().scale(search_tab_top_right.width(), m_searchFrame->height()));
+            p.drawPixmap( m_searchFrame->width()-search_tab_top_right.width(), 0, search_tab_top_right );
+         }
+    }
+    else
+        m_tabBar->deactivateTabs(false);
+
+    p.end();
+    m_searchFrame->setPaletteBackgroundPixmap( canvas );
+}
+
+void KMenu::stackWidgetRaised(QWidget* raiseWidget)
+{
+    paintSearchTab(raiseWidget == m_searchWidget);
+
+    if (raiseWidget == m_browserView) {
+        if ( m_tabBar->currentTab() == ApplicationsTab)
+            slotGoSubMenu(QString::null);
+        if (m_browserDirty ) {
+          createNewProgramList();
+          m_browserView->prepareRightMove();
+          m_browserView->currentView()->clear();
+          fillSubMenu(QString::null, m_browserView->currentView());
+          m_browserDirty = false;
+        }
+    }
+    else if (raiseWidget == m_recentlyView) {
+        if (m_recentDirty)
+            updateRecent();
+    }
+    else if (raiseWidget == m_exitView) {
+        if (m_tabBar->currentTab() == LeaveTab)
+            slotGoExitMainMenu();
+    }
+
+
+#warning Qtab fixme
+#if 0
+    else if (raiseWidget == m_systemView)
+	frame = m_system;
+    else if (raiseWidget == m_favoriteView)
+	frame = m_btnFavorites;
+    if (!frame)
+      return;
+
+    if ( m_activeTab == frame )
+        return;
+
+    paintTab( m_activeTab, false );
+    paintTab( frame, true );
+
+   // if (dynamic_cast<QScrollView*>(raiseWidget))
+   //     m_activeTab->setFocusProxy(static_cast<QScrollView*>(raiseWidget)->viewport());
+
+    if (0 && /*raiseWidget == m_stacker->visibleWidget() &&*/ !raiseWidget->hasFocus()) {
+
+        if (dynamic_cast<QScrollView*>(raiseWidget))
+            static_cast<QScrollView*>(raiseWidget)->viewport()->setFocus();
+        else
+            raiseWidget->setFocus();
+    }
+
+    m_activeTab = frame;
+
+    m_sloppyRegion = QRegion();
+    m_sloppyTimer.stop();
+
+    ItemView* view;
+    if (raiseWidget == m_browserView)
+        view = m_browserView->currentView();
+    else if (raiseWidget == m_exitView)
+        view = m_exitView->currentView();
+    else
+        view = dynamic_cast<ItemView*>(m_stacker->visibleWidget());
+    if (view && !view->selectedItem()) {
+	if (view->firstChild() && view->firstChild()->isSelectable()) {
+     	    view->setSelected(view->firstChild(),true);
+        }
+        else if (view->childCount()>1) {
+       	    view->setSelected(view->firstChild()->itemBelow(),true);
+        }
+    }
+#endif
+}
+
+void KMenu::paletteChanged()
+{
+}
+
+void KMenu::tabClicked(QTab* t)
+{
+    if (t==m_tabs[ApplicationsTab])
+	slotGoSubMenu(QString::null);
+    else if (t==m_tabs[LeaveTab])
+	slotGoExitMainMenu();
+}
+
+void KMenu::slotGoBack()
+{
+    goSubMenu( m_browserView->currentView()->backPath() );
+}
+
+void KMenu::slotGoExitMainMenu()
+{
+    if (m_exitView->currentView()==m_exitView->rightView()) {
+      m_exitView->prepareLeftMove(false);
+      m_exitView->showBackButton(false);
+      m_exitView->flipScroll(QString::null);
+    }
+}
+
+void KMenu::slotGoExitSubMenu(const QString& url)
+{
+    m_exitView->prepareRightMove();
+    m_exitView->showBackButton(true);
+
+    int nId = serviceMenuEndId() + 1;
+    int index = 1;
+
+    if (url=="kicker:/restart/") {
+      QStringList rebootOptions;
+      int def, cur;
+      if ( DM().bootOptions( rebootOptions, def, cur ) )
+      {
+        if ( cur == -1 )
+            cur = def;
+
+        int boot_index = 0;
+        QStringList::ConstIterator it = rebootOptions.begin();
+        for (; it != rebootOptions.end(); ++it, ++boot_index)
+        {
+
+            QString option = i18n( "Start '%1'" ).arg( *it );
+            if (boot_index == cur)
+                option = i18n("Start '%1' (current)").arg( *it );
+            m_exitView->rightView()->insertItem( "reload", option,
+                    i18n( "Restart and boot directly into '%1'").arg( *it ),
+                    QString( "kicker:/restart_%1" ).arg( boot_index ), nId++, index++ );
+        }
+        m_exitView->rightView()->insertHeader( nId++, "kicker:/restart/" );
+      }
+    }
+    else /*if (url=="kicker:/switchuser/") */{
+        m_exitView->rightView()->insertItem( "switchuser", i18n( "Start New Session" ),
+                     i18n( "Start a parallel session" ), "kicker:/switchuser", nId++, index++ );
+
+        m_exitView->rightView()->insertItem( "lock", i18n( "Lock Current && Start New Session").replace("&&","&"),
+                     i18n( "Lock screen and start a parallel session" ), "kicker:/switchuserafterlock", nId++, index++ );
+
+       SessList sess;
+       if (DM().localSessions( sess )) {
+          if (sess.count()>1)
+              m_exitView->rightView()->insertSeparator( nId++, QString::null, index++ );
+          for (SessList::ConstIterator it = sess.begin(); it != sess.end(); ++it) {
+              if ((*it).vt && !(*it).self) {
+                  QString user, loc;
+                  DM().sess2Str2( *it, user, loc );
+                  QStringList list = QStringList::split(":", user);
+                  m_exitView->rightView()->insertItem( "switchuser", i18n( "Switch to Session of User '%1'").arg(list[0]),
+                     i18n("Session: %1").arg(list[1].mid(1)+", "+loc) , QString("kicker:/switchuser_%1").arg((*it).vt), nId++, index++ );
+              }
+          }
+        }
+
+        m_exitView->rightView()->insertHeader( nId++, "kicker:/switchuser/" );
+    }
+    m_exitView->flipScroll(QString::null);
+}
+
+void KMenu::slotGoSubMenu(const QString& relPath)
+{
+     goSubMenu(relPath);
+}
+
+void KMenu::goSubMenu(const QString& relPath, bool keyboard)
+{
+    if ( relPath.startsWith( "kicker:/goup/" ) )
+    {
+        QString rel = relPath.mid( strlen( "kicker:/goup/" ) );
+        int index = rel.length() - 1;
+        if ( rel.endsWith( "/" ) )
+            index--;
+        index = rel.findRev( '/', index );
+        kdDebug() << "goup, rel '" << rel << "' " << index << endl;
+        QString currel = rel;
+        rel = rel.left( index + 1 );
+        if ( rel == "/" )
+            rel = QString::null;
+
+        kdDebug() << "goup, rel '" << rel << "' " << rel.isEmpty() << endl;
+        fillSubMenu( rel, m_browserView->prepareLeftMove() );
+        m_browserView->flipScroll(keyboard ? currel : QString::null);
+        return;
+    } else if (relPath.isEmpty())
+    {
+	if (m_browserView->currentView()->path.isEmpty())
+	    return;
+	fillSubMenu( relPath, m_browserView->prepareLeftMove() );
+    } else if ( relPath.startsWith( "kicker:/new/" ) )
+    {
+        ItemView* view = m_browserView->prepareRightMove();
+        m_browserView->showBackButton( true );
+
+        int nId = serviceMenuEndId() + 1;
+        view->insertHeader( nId++, "new/" );
+        int index = 2;
+        for (QStringList::ConstIterator it = m_newInstalledPrograms.begin();
+            it != m_newInstalledPrograms.end(); ++it) {
+            KService::Ptr p = KService::serviceByStorageId((*it));
+            view->insertMenuItem(p, nId++, index++);
+         }
+    } else
+    {
+        //m_browserView->clear();
+        fillSubMenu(relPath, m_browserView->prepareRightMove());
+    }
+    m_browserView->flipScroll(keyboard ? "kicker:/goup/": QString::null);
+}
+
+void KMenu::fillSubMenu(const QString& relPath, ItemView *view)
+{
+    kdDebug() << "fillSubMenu() " << relPath << endl;
+    KServiceGroup::Ptr root = KServiceGroup::group(relPath);
+    Q_ASSERT( root );
+
+    KServiceGroup::List list = root->entries(true, true, true, KickerSettings::
+            menuEntryFormat() == KickerSettings::DescriptionAndName || KickerSettings::menuEntryFormat()
+            == KickerSettings::DescriptionOnly);
+
+    int nId = serviceMenuStartId();
+    m_browserView->showBackButton( !relPath.isEmpty() );
+    if ( !relPath.isEmpty() )
+    {
+        view->insertHeader( nId++, relPath );
+    }
+    else if ( m_newInstalledPrograms.count() ) {
+        KMenuItem *item = view->insertItem( "clock", i18n( "New Applications" ),
+                              QString::null, "kicker:/new/", nId++, -1 );
+        item->setHasChildren( true );
+        view->insertSeparator( nId++, QString::null, -1 );
+    }
+
+    view->path = relPath;
+
+    fillMenu (root, list, relPath, view, nId);
+}
+
+void KMenu::fillMenu(KServiceGroup::Ptr&
+#ifdef KDELIBS_SUSE
+    _root
+#endif
+                     , KServiceGroup::List& _list,
+                     const QString& _relPath,
+                     ItemView* view,
+                     int& id)
+{
+    bool separatorNeeded = false;
+    KServiceGroup::List::ConstIterator it = _list.begin();
+#ifdef KDELIBS_SUSE
+    KSortableValueList<KSharedPtr<KSycocaEntry>,QCString> slist;
+    KSortableValueList<KSharedPtr<KSycocaEntry>,QCString> glist;
+    QMap<QString,QString> specialTitle;
+    QMap<QString,QString> categoryIcon;
+    QMap<QString,QString> shortenedMenuPath;
+#endif
+
+    for (; it != _list.end(); ++it)
+    {
+        KSycocaEntry * e = *it;
+
+        if (e->isType(KST_KServiceGroup))
+        {
+           KServiceGroup::Ptr g(static_cast<KServiceGroup *>(e));
+#ifdef KDELIBS_SUSE
+           if ( true /*KickerSettings::reduceMenuDepth()*/ && g->SuSEshortMenu() ){
+              KServiceGroup::List l = g->entries(true, true /*excludeNoDisplay_*/ );
+              if ( l.count() == 1 ) {
+                 // the special case, we want to short the menu.
+                 // TOFIX? : this works only for one level
+                 KServiceGroup::List::ConstIterator _it=l.begin();
+                 KSycocaEntry *_e = *_it;
+                 if (_e->isType(KST_KService)) {
+                     KService::Ptr s(static_cast<KService *>(_e));
+		     QString key;
+                     if ( g->SuSEgeneralDescription() ) {
+			// we use the application name
+                        key = s->name();
+                     }
+		     else {
+			// we use the normal menu description
+			key = s->name();
+                        if( !s->genericName().isEmpty() && g->caption()!=s->genericName()) {
+                           if (KickerSettings::menuEntryFormat() == KickerSettings::NameAndDescription)
+                               key = s->name() + " (" + g->caption() + ")";
+			   else if (KickerSettings::menuEntryFormat() == KickerSettings::DescriptionAndName)
+                               key = g->caption() + " (" + s->name() + ")";
+			   else if (KickerSettings::menuEntryFormat() == KickerSettings::DescriptionOnly)
+                             key = g->caption();
+                        }
+		     }
+		     specialTitle.insert( _e->name(), key );
+		     categoryIcon.insert( _e->name(), g->icon() );
+                     slist.insert( key.local8Bit(), _e );
+		     shortenedMenuPath.insert( _e->name(), g->relPath() );
+                     // and escape from here
+                     continue;
+                  }
+               }
+            }
+            glist.insert( g->caption().local8Bit(), e );
+        }else if( e->isType(KST_KService)) {
+            KService::Ptr s(static_cast<KService *>(e));
+            slist.insert( s->name().local8Bit(), e );
+        } else
+            slist.insert( e->name().local8Bit(), e );
+    }
+
+    _list = _root->SuSEsortEntries( slist, glist, true /*excludeNoDisplay_*/, true );
+    it = _list.begin();
+
+    for (; it != _list.end(); ++it) {
+
+        KSycocaEntry * e = *it;
+
+        if (e->isType(KST_KServiceGroup)) {
+
+           KServiceGroup::Ptr g(static_cast<KServiceGroup *>(e));
+           if ( true /*KickerSettings::reduceMenuDepth()*/ && g->SuSEshortMenu() ){
+              KServiceGroup::List l = g->entries(true, true /*excludeNoDisplay_*/ );
+              if ( l.count() == 1 ) {
+                    continue;
+              }
+           }
+           // standard sub menu
+#endif
+            QString groupCaption = g->caption();
+
+           // Avoid adding empty groups.
+            KServiceGroup::Ptr subMenuRoot = KServiceGroup::group(g->relPath());
+
+            int nbChildCount = subMenuRoot->childCount();
+            if (nbChildCount == 0 && !g->showEmptyMenu())
+            {
+                continue;
+            }
+
+            bool is_description = KickerSettings::menuEntryFormat() == KickerSettings::DescriptionAndName ||
+                                  KickerSettings::menuEntryFormat() == KickerSettings::DescriptionOnly;
+
+            QString inlineHeaderName = g->showInlineHeader() ? groupCaption : "";
+
+            if ( nbChildCount == 1 && g->allowInline() && g->inlineAlias())
+            {
+                KServiceGroup::Ptr element = KServiceGroup::group(g->relPath());
+                if ( element )
+                {
+                    //just one element
+
+                    KServiceGroup::List listElement = element->entries(true, true, true, is_description );
+                    KSycocaEntry * e1 = *( listElement.begin() );
+                    if ( e1->isType( KST_KService ) )
+                    {
+                        KService::Ptr s(static_cast<KService *>(e1));
+                        view->insertMenuItem(s, id++, -1, 0);
+                        continue;
+                    }
+                }
+            }
+
+            if (g->allowInline() && ((nbChildCount <= g->inlineValue() ) ||   (g->inlineValue() == 0)))
+            {
+                //inline all entries
+                KServiceGroup::Ptr rootElement = KServiceGroup::group(g->relPath());
+
+                if (!rootElement || !rootElement->isValid())
+                {
+                    break;
+                }
+
+
+                KServiceGroup::List listElement = rootElement->entries(true, true, true, is_description );
+
+#if 0
+                if ( !g->inlineAlias() && !inlineHeaderName.isEmpty() )
+                {
+                    int mid = view->insertItem(new PopupMenuTitle(inlineHeaderName, font()), id++, id, 0);
+                    m_browserView->setItemEnabled( mid, false );
+                }
+#endif
+
+                fillMenu( rootElement, listElement, g->relPath(), 0, id );
+                continue;
+            }
+
+            // Ignore dotfiles.
+            if ((g->name().at(0) == '.'))
+            {
+                continue;
+            }
+
+            KMenuItem *item = view->insertItem(g->icon(), groupCaption, QString::null, g->relPath(), id++, -1);
+	    item->setMenuPath(g->relPath());
+            item->setHasChildren( true );
+
+#warning FIXME
+#if 0
+            PanelServiceMenu * m =
+                newSubMenu(g->name(), g->relPath(), this, g->name().utf8(), inlineHeaderName);
+            m->setCaption(groupCaption);
+
+            QIconSet iconset = KickerLib::menuIconSet(g->icon());
+
+            if (separatorNeeded)
+            {
+                insertSeparator();
+                separatorNeeded = false;
+            }
+
+            int newId = insertItem(iconset, groupCaption, m, id++);
+            entryMap_.insert(newId, static_cast<KSycocaEntry*>(g));
+            // We have to delete the sub menu our selves! (See Qt docs.)
+            subMenus.append(m);
+#endif
+        }
+        if (e->isType(KST_KService))
+        {
+            KService::Ptr s(static_cast<KService *>(e));
+            if (_relPath.isEmpty()) {
+                QStringList favs = KickerSettings::favorites();
+                if (favs.find(s->storageId())!=favs.end())
+                  continue;
+            }
+#ifdef KDELIBS_SUSE
+            KMenuItem *item = view->insertMenuItem(s, id++, -1, 0, QString::null, specialTitle[s->name()], categoryIcon[s->name()] );
+            if (shortenedMenuPath[s->name()].isEmpty())
+	       item->setMenuPath(_relPath+s->menuId());
+            else
+	       item->setMenuPath(shortenedMenuPath[s->name()]+s->menuId());
+#else
+            KMenuItem *item = view->insertMenuItem(s, id++, -1);
+	    item->setMenuPath(_relPath+s->menuId());
+#endif
+        }
+        else if (e->isType(KST_KServiceSeparator))
+        {
+            separatorNeeded = true;
+        }
+    }
+
+    view->slotMoveContent();
+}
+
+void KMenu::initialize()
+{
+    static bool m_initialized=false;
+    if (m_initialized)
+        return;
+    m_initialized = true;
+
+    kdDebug(1210) << "KMenu::initialize()" << endl;
+
+    // in case we've been through here before, let's disconnect
+    disconnect(kapp, SIGNAL(kdisplayPaletteChanged()),
+            this, SLOT(paletteChanged()));
+    connect(kapp, SIGNAL(kdisplayPaletteChanged()),
+            this, SLOT(paletteChanged()));
+
+   /*
+       If  the user configured ksmserver to
+     */
+    KConfig ksmserver("ksmserverrc", false, false);
+    ksmserver.setGroup("General");
+    connect( m_branding, SIGNAL(clicked()), SLOT(slotOpenHomepage()));
+    m_tabBar->setTabEnabled(LeaveTab, kapp->authorize("logout"));
+
+    // load search field history
+    QStringList histList = KickerSettings::history();
+    int maxHistory = KickerSettings::historyLength();
+
+    bool block = m_kcommand->signalsBlocked();
+    m_kcommand->blockSignals( true );
+    m_kcommand->setMaxCount( maxHistory );
+    m_kcommand->setHistoryItems( histList );
+    m_kcommand->blockSignals( block );
+
+    QStringList compList = KickerSettings::completionItems();
+    if( compList.isEmpty() )
+        m_kcommand->completionObject()->setItems( histList );
+    else
+        m_kcommand->completionObject()->setItems( compList );
+
+    KCompletionBox* box = m_kcommand->completionBox();
+    if (box)
+        box->setActivateOnSelect( false );
+
+    m_finalFilters = KURIFilter::self()->pluginNames();
+    m_finalFilters.remove("kuriikwsfilter");
+
+    m_middleFilters = m_finalFilters;
+    m_middleFilters.remove("localdomainurifilter");
+
+    QStringList favs = KickerSettings::favorites();
+    if (favs.isEmpty()) {
+      QFile f(locate("data", "kicker/default-favs"));
+      if (f.open(IO_ReadOnly)) {
+        QTextStream is(&f);
+
+        while (!is.eof())
+            favs << is.readLine();
+
+        f.close();
+      }
+      KickerSettings::setFavorites(favs);
+      KickerSettings::writeConfig();
+    }
+
+    int nId = serviceMenuEndId() + 1;
+    int index = 1;
+    for (QStringList::ConstIterator it = favs.begin(); it != favs.end(); ++it)
+    {
+       if ((*it)[0]=='/') {
+          KDesktopFile df((*it),true);
+          QString url = df.readURL();
+          if (!KURL(url).isLocalFile() || QFile::exists(url.replace("file://",QString::null)))
+            m_favoriteView->insertItem(df.readIcon(),df.readName(),df.readGenericName(), url, nId++, index++);
+       }
+       else {
+          KService::Ptr p = KService::serviceByStorageId((*it));
+          m_favoriteView->insertMenuItem(p, nId++, index++);
+       }
+    }
+
+    //nId = m_favoriteView->insertSeparator( nId, QString::null, index++ );
+//    m_favoriteView->insertDocument(KURL("help:/khelpcenter/userguide/index.html"), nId++);
+
+    insertStaticItems();
+
+    m_stacker->raiseWidget (m_favoriteView);
+}
+
+void KMenu::insertStaticExitItems()
+{
+    int nId = serviceMenuEndId() + 1;
+    int index = 1;
+
+    m_exitView->leftView()->insertSeparator( nId++, i18n("Session"), index++ );
+    if (kapp->authorize("logout"))
+       m_exitView->leftView()->insertItem( "undo", i18n( "Logout" ),
+                                   i18n( "End session" ), "kicker:/logout", nId++, index++ );
+    if (kapp->authorize("lock_screen"))
+       m_exitView->leftView()->insertItem( "lock", i18n( "Lock" ),
+                                   i18n( "Lock screen" ), "kicker:/lock", nId++, index++ );
+
+    KConfig ksmserver("ksmserverrc", false, false);
+    ksmserver.setGroup("General");
+    if (ksmserver.readEntry( "loginMode" ) == "restoreSavedSession")
+    {
+        m_exitView->leftView()->insertItem("filesave", i18n("Save Session"),
+                               i18n("Save current Session for next login"),
+                               "kicker:/savesession", nId++, index++ );
+    }
+    if (DM().isSwitchable() && kapp->authorize("switch_user"))
+    {
+        KMenuItem *switchuser = m_exitView->leftView()->insertItem( "switchuser", i18n( "Switch User" ),
+                                                                    i18n( "Manage parallel sessions" ), "kicker:/switchuser/", nId++, index++ );
+        switchuser->setHasChildren(true);
+    }
+
+    bool maysd = false;
+    if (ksmserver.readBoolEntry( "offerShutdown", true ) && DM().canShutdown())
+        maysd = true;
+
+    if ( maysd )
+    {
+        m_exitView->leftView()->insertSeparator( nId++, i18n("System"), index++ );
+        m_exitView->leftView()->insertItem( "exit", i18n( "Shutdown Computer" ),
+                                   i18n( "Turn off computer" ), "kicker:/shutdown", nId++, index++ );
+
+        m_exitView->leftView()->insertItem( "reload", i18n( "&Restart Computer" ).replace("&",""),
+                                            i18n( "Restart and boot the default system" ),
+                                            "kicker:/restart", nId++, index++ );
+
+        insertSuspendOption(nId, index);
+
+        int def, cur;
+        QStringList dummy_opts;
+        if ( DM().bootOptions( dummy_opts, def, cur ) )
+        {
+
+            KMenuItem *restart = m_exitView->leftView()->insertItem( "reload", i18n( "Start Operating System" ),
+                                                                     i18n( "Restart and boot another operating system" ),
+                                                                     "kicker:/restart/", nId++, index++ );
+            restart->setHasChildren(true);
+        }
+    }
+}
+
+void KMenu::insertStaticItems()
+{
+    insertStaticExitItems();
+
+    int nId = serviceMenuEndId() + 10;
+    int index = 1;
+
+    m_systemView->insertSeparator( nId++, i18n("Applications"), index++);
+
+    KService::Ptr p = KService::serviceByStorageId("/usr/share/applications/YaST.desktop");
+    m_systemView->insertMenuItem(p, nId++, index++);
+
+    m_systemView->insertItem( "info", i18n( "System Information" ),
+                              "sysinfo:/",  "sysinfo:/", nId++, index++ );
+
+    m_systemView->insertSeparator( nId++, i18n("System Folders"), index++ );
+
+    m_systemView->insertItem( "folder_home", i18n( "Home Folder" ),
+                              QDir::homeDirPath(), "file://"+QDir::homeDirPath(), nId++, index++ );
+
+    if ( KStandardDirs::exists( KGlobalSettings::documentPath() + "/" ) )
+    {
+        QString documentPath = KGlobalSettings::documentPath();
+        if ( documentPath.endsWith( "/" ) )
+            documentPath = documentPath.left( documentPath.length() - 1 );
+        if (documentPath!=QDir::homeDirPath())
+           m_systemView->insertItem( "folder_man", i18n( "My Documents" ), documentPath, documentPath, nId++, index++ );
+    }
+
+    m_systemView->insertItem( "network", i18n( "Network Folders" ),
+                              "remote:/", "remote:/", nId++, index++ );
+
+    m_mediaWatcher = new MediaWatcher( this );
+    connect( m_mediaWatcher, SIGNAL( mediumChanged() ), SLOT( updateMedia() ) );
+    m_media_id = 0;
+
+    connect(&m_mediaFreeTimer, SIGNAL(timeout()), SLOT( updateMedia()));
+}
+
+int KMenu::insertClientMenu(KickerClientMenu *)
+{
+#if 0
+    int id = client_id;
+    clients.insert(id, p);
+    return id;
+#endif
+    return 0;
+}
+
+void KMenu::removeClientMenu(int)
+{
+#if 0
+    clients.remove(id);
+    slotClear();
+#endif
+}
+
+extern int kicker_screen_number;
+
+void KMenu::slotLock()
+{
+    kdDebug() << "slotLock " << endl;
+    accept();
+    QCString appname( "kdesktop" );
+    if ( kicker_screen_number )
+        appname.sprintf("kdesktop-screen-%d", kicker_screen_number);
+    kapp->dcopClient()->send(appname, "KScreensaverIface", "lock()", "");
+}
+
+void KMenu::slotOpenHomepage()
+{
+    accept();
+    kapp->invokeBrowser("http://opensuse.org");
+}
+
+void KMenu::slotLogout()
+{
+    kapp->requestShutDown();
+}
+
+void KMenu::slotPopulateSessions()
+{
+    int p = 0;
+    DM dm;
+
+    sessionsMenu->clear();
+    if (kapp->authorize("start_new_session") && (p = dm.numReserve()) >= 0)
+    {
+        if (kapp->authorize("lock_screen"))
+	  sessionsMenu->insertItem(/*SmallIconSet("lockfork"),*/ i18n("Lock Current && Start New Session"), 100 );
+        sessionsMenu->insertItem(SmallIconSet("fork"), i18n("Start New Session"), 101 );
+        if (!p) {
+            sessionsMenu->setItemEnabled( 100, false );
+            sessionsMenu->setItemEnabled( 101, false );
+        }
+        sessionsMenu->insertSeparator();
+    }
+    SessList sess;
+    if (dm.localSessions( sess ))
+        for (SessList::ConstIterator it = sess.begin(); it != sess.end(); ++it) {
+            int id = sessionsMenu->insertItem( DM::sess2Str( *it ), (*it).vt );
+            if (!(*it).vt)
+                sessionsMenu->setItemEnabled( id, false );
+            if ((*it).self)
+                sessionsMenu->setItemChecked( id, true );
+        }
+}
+
+void KMenu::slotSessionActivated( int ent )
+{
+    if (ent == 100)
+        doNewSession( true );
+    else if (ent == 101)
+        doNewSession( false );
+    else if (!sessionsMenu->isItemChecked( ent ))
+        DM().lockSwitchVT( ent );
+}
+
+void KMenu::doNewSession( bool lock )
+{
+    int result = KMessageBox::warningContinueCancel(
+        kapp->desktop()->screen(kapp->desktop()->screenNumber(this)),
+        i18n("<p>You have chosen to open another desktop session.<br>"
+               "The current session will be hidden "
+               "and a new login screen will be displayed.<br>"
+               "An F-key is assigned to each session; "
+               "F%1 is usually assigned to the first session, "
+               "F%2 to the second session and so on. "
+               "You can switch between sessions by pressing "
+               "Ctrl, Alt and the appropriate F-key at the same time. "
+               "Additionally, the KDE Panel and Desktop menus have "
+               "actions for switching between sessions.</p>")
+                           .arg(7).arg(8),
+        i18n("Warning - New Session"),
+        KGuiItem(i18n("&Start New Session"), "fork"),
+        ":confirmNewSession",
+        KMessageBox::PlainCaption | KMessageBox::Notify);
+
+    if (result==KMessageBox::Cancel)
+        return;
+
+    if (lock)
+        slotLock();
+
+    DM().startReserve();
+}
+
+void KMenu::searchAccept()
+{
+    QString cmd = m_kcommand->currentText().stripWhiteSpace();
+
+    bool logout = (cmd == "logout");
+    bool lock = (cmd == "lock");
+
+    addToHistory();
+
+    if ( !logout && !lock )
+    {
+        // first try if we have any search action
+        if (m_searchResultsWidget->currentItem()) {
+            m_searchResultsWidget->slotItemClicked(m_searchResultsWidget->currentItem());
+            return;
+        }
+    }
+
+    accept();
+    saveConfig();
+
+    if ( logout )
+    {
+        kapp->propagateSessionManager();
+        kapp->requestShutDown();
+    }
+    if ( lock )
+    {
+        QCString appname( "kdesktop" );
+        int kicker_screen_number = qt_xscreen();
+        if ( kicker_screen_number )
+            appname.sprintf("kdesktop-screen-%d", kicker_screen_number);
+        kapp->dcopClient()->send(appname, "KScreensaverIface", "lock()", "");
+    }
+}
+
+bool KMenu::runCommand()
+{
+    kdDebug() << "runCommand() " << m_kcommand->lineEdit()->text() << endl;
+    // Ignore empty commands...
+    if ( m_kcommand->lineEdit()->text().isEmpty() )
+      return true;
+
+    accept();
+
+    if (input_timer->isActive ())
+        input_timer->stop ();
+
+    // Make sure we have an updated data
+    parseLine( true );
+
+    bool block = m_kcommand->signalsBlocked();
+    m_kcommand->blockSignals( true );
+    m_kcommand->clearEdit();
+    m_kcommand->setFocus();
+    m_kcommand->reset();
+    m_kcommand->blockSignals( block );
+
+
+    QString cmd;
+    KURL uri = m_filterData->uri();
+    if ( uri.isLocalFile() && !uri.hasRef() && uri.query().isEmpty() )
+      cmd = uri.path();
+    else
+      cmd = uri.url();
+
+    QString exec;
+
+    switch( m_filterData->uriType() )
+    {
+      case KURIFilterData::LOCAL_FILE:
+      case KURIFilterData::LOCAL_DIR:
+      case KURIFilterData::NET_PROTOCOL:
+      case KURIFilterData::HELP:
+      {
+        // No need for kfmclient, KRun does it all (David)
+        (void) new KRun( m_filterData->uri(), parentWidget());
+        return false;
+      }
+      case KURIFilterData::EXECUTABLE:
+      {
+        if( !m_filterData->hasArgsAndOptions() )
+        {
+          // Look for desktop file
+          KService::Ptr service = KService::serviceByDesktopName(cmd);
+          if (service && service->isValid() && service->type() == "Application")
+          {
+            notifyServiceStarted(service);
+            KRun::run(*service, KURL::List());
+            return false;
+          }
+        }
+      }
+      // fall-through to shell case
+      case KURIFilterData::SHELL:
+      {
+        if (kapp->authorize("shell_access"))
+        {
+          exec = cmd;
+
+          if( m_filterData->hasArgsAndOptions() )
+            cmd += m_filterData->argsAndOptions();
+
+          break;
+        }
+        else
+        {
+          KMessageBox::sorry( this, i18n("<center><b>%1</b></center>\n"
+                                    "You do not have permission to execute "
+                                    "this command.")
+                                    .arg( QStyleSheet::convertFromPlainText(cmd) ));
+          return true;
+        }
+      }
+      case KURIFilterData::UNKNOWN:
+      case KURIFilterData::ERROR:
+      default:
+      {
+        // Look for desktop file
+        KService::Ptr service = KService::serviceByDesktopName(cmd);
+        if (service && service->isValid() && service->type() == "Application")
+        {
+          notifyServiceStarted(service);
+          KRun::run(*service, KURL::List(), this);
+          return false;
+        }
+
+        service = KService::serviceByName(cmd);
+        if (service && service->isValid() && service->type() == "Application")
+        {
+          notifyServiceStarted(service);
+          KRun::run(*service, KURL::List(), this);
+          return false;
+      }
+
+        KMessageBox::sorry( this, i18n("<center><b>%1</b></center>\n"
+                                  "Could not run the specified command.")
+                                  .arg( QStyleSheet::convertFromPlainText(cmd) ));
+        return true;
+      }
+    }
+
+    if ( KRun::runCommand( cmd, exec, m_iconName ) )
+      return false;
+
+    KMessageBox::sorry( this, i18n("<center><b>%1</b></center>\n"
+                                "The specified command does not exist.").arg(cmd) );
+    return true; // Let the user try again...
+}
+
+void KMenu::show()
+{
+    m_isShowing = true;
+    emit aboutToShow();
+
+    initialize();
+
+    PanelPopupButton *kButton = MenuManager::the()->findKButtonFor( this );
+    if (kButton)
+    {
+        QPoint center = kButton->center();
+        QRect screen = QApplication::desktop()->screenGeometry( center );
+        setOrientation((center.y()-screen.y()<screen.height()/2)
+                ? TopDown : BottomUp);
+    }
+
+    m_browserDirty=true;
+    m_recentDirty=true;
+
+    updateMedia();
+    m_mediaFreeTimer.start(10 * 1000); // refresh all 10s
+
+    m_stacker->raiseWidget(FavoriteTab);
+    m_kcommand->clear();
+    current_query.clear();
+    m_kcommand->setFocus();
+
+    // we need to reenable it
+    m_toolTipsEnabled = QToolTip::isGloballyEnabled();
+    QToolTip::setGloballyEnabled(KickerSettings::showToolTips());
+
+    KMenuBase::show();
+    m_isShowing = false;
+}
+
+void KMenu::setOrientation(MenuOrientation orientation)
+{
+    if (m_orientation == orientation)
+        return;
+
+    m_orientation=orientation;
+
+    m_resizeHandle->setCursor(m_orientation == BottomUp ? Qt::sizeBDiagCursor : Qt::sizeFDiagCursor);
+
+    QPixmap pix;
+    if ( m_orientation == BottomUp )
+        pix.load( locate("data", "kicker/pics/search-gradient.png" ) );
+    else
+        pix.load( locate("data", "kicker/pics/search-gradient-topdown.png" ) );
+
+    pix.convertFromImage( pix.convertToImage().scale(pix.width(), m_searchFrame->height()));
+    m_search->mainWidget()->setPaletteBackgroundPixmap( pix );
+    m_resizeHandle->setPaletteBackgroundPixmap( pix );
+
+    m_tabBar->setShape( m_orientation == BottomUp
+            ? QTabBar::RoundedBelow : QTabBar::RoundedAbove);
+
+    QPixmap respix = QPixmap( locate("data", "kicker/pics/resize_handle.png" ) );
+    if ( m_orientation == TopDown ) {
+      QWMatrix m;
+      m.rotate( 90.0 );
+      respix=respix.xForm(m);
+    }
+    m_resizeHandle->setPixmap(respix);
+
+    {
+        QWidget *footer = m_footer->mainWidget();
+        QPixmap pix( 64, footer->height() );
+        QPainter p( &pix );
+        p.fillRect( 0, 0, 64, footer->height(), m_branding->colorGroup().brush( QColorGroup::Base ) );
+        p.fillRect( 0, m_orientation == BottomUp ? footer->height() - 2 : 0,
+                64, 3, KNewButton::self()->borderColor() );
+        p.end();
+        footer->setPaletteBackgroundPixmap( pix );
+    }
+
+    resizeEvent(new QResizeEvent(sizeHint(), sizeHint()));
+}
+
+void KMenu::showMenu()
+{
+    kdDebug() << "KMenu::showMenu()" << endl;
+    PanelPopupButton *kButton = MenuManager::the()->findKButtonFor(this);
+    if (kButton)
+    {
+	adjustSize();
+        kButton->showMenu();
+    }
+    else
+    {
+        show();
+    }
+    kdDebug() << "end KMenu::showMenu()" << endl;
+}
+
+void KMenu::hide()
+{
+    //kdDebug() << "KMenu::hide() from " << kdBacktrace() << endl;
+
+    // TODO: hide popups
+
+    emit aboutToHide();
+
+    if (m_popupMenu) {
+        m_popupMenu->deleteLater();
+        m_popupMenu=0;
+    }
+    m_mediaFreeTimer.stop();
+
+    m_isresizing = false;
+
+    KickerSettings::setKMenuWidth(width());
+    KickerSettings::setKMenuHeight(height());
+    KickerSettings::writeConfig();
+
+    QToolTip::setGloballyEnabled(m_toolTipsEnabled);
+
+    // remove focus from lineedit again, otherwise it doesn't kill its timers
+    m_stacker->raiseWidget(FavoriteTab);
+
+    QWidget::hide();
+}
+
+void KMenu::paintEvent(QPaintEvent * e)
+{
+    KMenuBase::paintEvent(e);
+
+    QPainter p(this);
+    p.setClipRegion(e->region());
+
+    const BackgroundMode bgmode = backgroundMode();
+    const QColorGroup::ColorRole crole = QPalette::backgroundRoleFromMode( bgmode );
+    p.setBrush( colorGroup().brush( crole ) );
+
+    p.drawRect( 0, 0, width(), height() );
+    int ypos = m_search->mainWidget()->geometry().bottom();
+
+    p.drawPixmap( 0, ypos, main_border_tl );
+    p.drawPixmap( width() - main_border_tr.width(), ypos, main_border_tr );
+ //   p.drawPixmap( 0, ->y(), button_box_left );
+}
+
+
+void KMenu::configChanged()
+{
+    RecentlyLaunchedApps::the().m_bNeedToUpdate = false;
+    RecentlyLaunchedApps::the().configChanged();
+
+    m_exitView->leftView()->clear();
+    insertStaticExitItems();
+}
+
+// create and fill "recent" section at first
+void KMenu::createRecentMenuItems()
+{
+    RecentlyLaunchedApps::the().init();
+
+    if (!KickerSettings::numVisibleEntries())
+      KickerSettings::setNumVisibleEntries(5);
+
+    int nId = serviceMenuEndId() + 1;
+    m_recentlyView->insertSeparator( nId++, i18n( "Applications" ), -1 );
+
+    QStringList RecentApps;
+
+    if (!KickerSettings::recentVsOften()) {
+        KickerSettings::setRecentVsOften(true);
+        RecentlyLaunchedApps::the().configChanged();
+        RecentlyLaunchedApps::the().getRecentApps(RecentApps);
+        KickerSettings::setRecentVsOften(false);
+        RecentlyLaunchedApps::the().configChanged();
+    }
+    else
+        RecentlyLaunchedApps::the().getRecentApps(RecentApps);
+
+
+    if (RecentApps.count() > 0)
+    {
+//        bool bSeparator = KickerSettings::showMenuTitles();
+        int nIndex = 0;
+
+        for (QValueList<QString>::ConstIterator it =
+             RecentApps.begin(); it!=RecentApps.end(); ++it)
+        {
+            KService::Ptr s = KService::serviceByStorageId(*it);
+            if (!s)
+            {
+                RecentlyLaunchedApps::the().removeItem(*it);
+            }
+            else
+                m_recentlyView->insertMenuItem(s, nIndex++);
+        }
+
+    }
+
+    m_recentlyView->insertSeparator( nId++, i18n( "Documents" ), -1 );
+
+    QStringList fileList = KRecentDocument::recentDocuments();
+    kdDebug() << "createRecentMenuItems=" << fileList << endl;
+    for (QStringList::ConstIterator it = fileList.begin();
+         it != fileList.end();
+         ++it)
+        m_recentlyView->insertRecentlyItem(*it, nId++);
+
+}
+
+void KMenu::clearSubmenus()
+{
+    // we don't need to delete these on the way out since the libloader
+    // handles them for us
+    if (QApplication::closingDown())
+    {
+        return;
+    }
+
+    for (PopupMenuList::const_iterator it = dynamicSubMenus.constBegin();
+            it != dynamicSubMenus.constEnd();
+            ++it)
+    {
+        delete *it;
+    }
+    dynamicSubMenus.clear();
+}
+
+void KMenu::updateRecent()
+{
+    m_recentlyView->clear();
+
+    createRecentMenuItems();
+
+    m_recentDirty = false;
+}
+
+void KMenu::popup(const QPoint&, int)
+{
+   showMenu();
+}
+
+void KMenu::clearRecentAppsItems()
+{
+    RecentlyLaunchedApps::the().clearRecentApps();
+    RecentlyLaunchedApps::the().save();
+    RecentlyLaunchedApps::the().m_bNeedToUpdate = true;
+    updateRecent();
+}
+
+void KMenu::clearRecentDocsItems()
+{
+    KRecentDocument::clear();
+    updateRecent();
+}
+
+void KMenu::searchChanged(const QString & text)
+{
+  if (!text.isEmpty()) {
+    const QColor on = QColor( 244, 244, 244 );
+    const QColor off = QColor( 181, 181, 181 );
+    m_stacker->raiseWidget(m_searchWidget);
+    paintSearchTab(true);
+  }
+
+  m_searchActions->clearSelection();
+  m_searchResultsWidget->clearSelection();
+
+  if (input_timer->isActive ())
+    input_timer->stop ();
+  input_timer->start (WAIT_BEFORE_QUERYING, TRUE);
+}
+
+bool KMenu::dontQueryNow (const QString& str)
+{
+    if (str.isEmpty ())
+        return true;
+    if (str == current_query.get())
+	return true;
+    int length = str.length ();
+    int last_whitespace = str.findRev (' ', -1);
+    if (last_whitespace == length-1)
+        return false; // if the user typed a space, search
+    if (last_whitespace >= length-2)
+        return true; // dont search if the user only typed one character
+    QChar lastchar = str[length-1];
+    if (lastchar == ":" || lastchar == "=")
+        return true;
+    return false;
+}
+
+void KMenu::createNewProgramList()
+{
+    m_seenProgramsChanged = false;
+    m_seenPrograms = KickerSettings::firstSeenApps();
+    m_newInstalledPrograms.clear();
+
+    m_currentDate = QDate::currentDate().toString(Qt::ISODate);
+
+    bool initialize = (m_seenPrograms.count() == 0);
+
+    createNewProgramList(QString::null);
+
+    if (initialize) {
+       for (QStringList::Iterator it = m_seenPrograms.begin(); it != m_seenPrograms.end(); ++it)
+           *(++it)="-";
+
+        m_newInstalledPrograms.clear();
+    }
+
+    if (m_seenProgramsChanged) {
+      KickerSettings::setFirstSeenApps(m_seenPrograms);
+      KickerSettings::writeConfig();
+    }
+}
+
+void KMenu::createNewProgramList(QString relPath)
+{
+    KServiceGroup::Ptr group = KServiceGroup::group(relPath);
+    if (!group || !group->isValid())
+      return;
+
+    KServiceGroup::List list = group->entries();
+    if (list.isEmpty())
+      return;
+
+    KServiceGroup::List::ConstIterator it = list.begin();
+    for(; it != list.end(); ++it) {
+	KSycocaEntry *e = *it;
+
+	if(e != 0) {
+		if(e->isType(KST_KServiceGroup)) {
+			KServiceGroup::Ptr g(static_cast<KServiceGroup *>(e));
+			if(!g->noDisplay())
+				createNewProgramList(g->relPath());
+		} else if(e->isType(KST_KService)) {
+			KService::Ptr s(static_cast<KService *>(e));
+			if(s->type() == "Application" && !s->noDisplay() ) {
+                            QString shortStorageId = s->storageId().replace(".desktop",QString::null);
+                            QStringList::Iterator it_find = m_seenPrograms.begin();
+                            QStringList::Iterator it_end = m_seenPrograms.end();
+ 			    bool found = false;
+			    for (; it_find != it_end; ++it_find) {
+				if (*(it_find)==shortStorageId) {
+				   found = true;
+				   break;
+                                }
+                                ++it_find;
+                            }
+                            if (!found) {
+                                m_seenProgramsChanged=true;
+                                m_seenPrograms+=shortStorageId;
+                                m_seenPrograms+=m_currentDate;
+                                if (m_newInstalledPrograms.find(s->storageId())==m_newInstalledPrograms.end())
+                                  m_newInstalledPrograms+=s->storageId();
+                            }
+                            else {
+                                ++it_find;
+                                if (*(it_find)!="-") {
+                                   QDate date = QDate::fromString(*(it_find),Qt::ISODate);
+                                   if (date.daysTo(QDate::currentDate())<3) {
+                                      if (m_newInstalledPrograms.find(s->storageId())==m_newInstalledPrograms.end())
+                                         m_newInstalledPrograms+=s->storageId();
+                                   }
+                                   else {
+                                      m_seenProgramsChanged=true;
+                                      (*it_find)="-";
+                                   }
+                                }
+                            }
+                        }
+		}
+	}
+    }
+}
+
+void KMenu::searchProgramList(QString relPath)
+{
+    KServiceGroup::Ptr group = KServiceGroup::group(relPath);
+    if (!group || !group->isValid())
+      return;
+
+    KServiceGroup::List list = group->entries();
+    if (list.isEmpty())
+      return;
+
+    KServiceGroup::List::ConstIterator it = list.begin();
+    for(; it != list.end(); ++it) {
+	KSycocaEntry *e = *it;
+
+	if(e != 0) {
+		if(e->isType(KST_KServiceGroup)) {
+			KServiceGroup::Ptr g(static_cast<KServiceGroup *>(e));
+			if(!g->noDisplay())
+				searchProgramList(g->relPath());
+		} else if(e->isType(KST_KService)) {
+			KService::Ptr s(static_cast<KService *>(e));
+			if(s->type() == "Application" && !s->noDisplay() && !checkUriInMenu(s->desktopEntryPath())) {
+				if (!current_query.matches(s->name()+' '+s->genericName()+' '+s->exec()+' '+
+				    s->keywords().join(",")+' '+s->comment()+' '+group->caption()+' '+
+				    s->categories().join(",")) || !anotherHitMenuItemAllowed(APPS))
+					continue;
+
+				QString input = current_query.get();
+				int score = 0;
+				if (s->exec()==input)
+					score = 100;
+				else if (s->exec().find(input)==0)
+					score = 50;
+				else if (s->exec().find(input)!=-1)
+					score = 10;
+				else if (s->name().lower()==input)
+					score = 100;
+				else if (s->genericName().lower()==input)
+					score = 100;
+				else if (s->name().lower().find(input)==0)
+					score = 50;
+				else if (s->genericName().lower().find(input)==0)
+					score = 50;
+				else if (s->name().lower().find(input)!=-1)
+					score = 10;
+				else if (s->genericName().lower().find(input)!=-1)
+					score = 10;
+
+				if (s->exec().find(' ')==-1)
+					score+=1;
+
+				if (s->substituteUid())
+					score-=1;
+
+				if (s->noDisplay())
+				    score -= 100;
+				else if (s->terminal())
+				    score -= 50;
+				else
+				    score += kMin(10, s->initialPreference());
+
+				QString firstLine, secondLine;
+				if ((KickerSettings::DescriptionAndName || KickerSettings::menuEntryFormat() == KickerSettings::DescriptionOnly) && !s->genericName().isEmpty()) {
+									firstLine = s->genericName();
+					secondLine = s->name();
+				}
+				else {
+					firstLine = s->name();
+					secondLine = s->genericName();
+				}
+
+        			HitMenuItem *hit_item = new HitMenuItem (firstLine, secondLine,
+                                s->desktopEntryPath(), QString::null, 0, APPS, s->icon(), score);
+        			if (hit_item == NULL)
+					continue;
+
+				hit_item->service = s;
+        			insertSearchResult(hit_item);
+
+                                QString exe = s->exec();
+                                int pos = exe.find(' ');
+                                if (pos>0)
+                                  exe=exe.left(pos);
+				m_programsInMenu+=KGlobal::dirs()->findExe(exe);
+			}
+		}
+	}
+    }
+}
+
+void KMenu::searchBookmarks(KBookmarkGroup group)
+{
+	KBookmark bookmark = group.first();
+	while(!bookmark.isNull()) {
+		if (bookmark.isGroup()) {
+			searchBookmarks(bookmark.toGroup());
+		} else if (!bookmark.isSeparator() && !bookmark.isNull()) {
+				if (!current_query.matches(bookmark.fullText()+' '+bookmark.url().url()) || !anotherHitMenuItemAllowed(BOOKMARKS)) {
+                                        bookmark = group.next(bookmark);
+	    				continue;
+                                }
+
+        			HitMenuItem *hit_item = new HitMenuItem (bookmark.fullText(), bookmark.fullText(),
+                                bookmark.url(), QString::null, 0, BOOKMARKS, bookmark.icon());
+
+        			insertSearchResult(hit_item);
+		}
+		bookmark = group.next(bookmark);
+	}
+}
+
+void KMenu::initSearch()
+{
+    if (!m_addressBook && KickerSettings::kickoffSearchAddressBook())
+       m_addressBook = KABC::StdAddressBook::self( false );
+
+    if (!bookmarkManager)
+      bookmarkManager = KBookmarkManager::userBookmarksManager();
+
+    if (!m_search_plugin) {
+      m_search_plugin_interface = new QObject( this, "m_search_plugin_interface" );
+      new MyKickoffSearchInterface( this, m_search_plugin_interface, "kickoffsearch interface" );
+      KTrader::OfferList offers = KTrader::self()->query("KickoffSearch/Plugin");
+
+      KService::Ptr service = *offers.begin();
+      if (service) {
+        int errCode = 0;
+        m_search_plugin = KParts::ComponentFactory::createInstanceFromService<KickoffSearch::Plugin>
+            ( service, m_search_plugin_interface, 0, QStringList(), &errCode);
+      }
+    }
+}
+
+void KMenu::searchAddressbook()
+{
+    if (!KickerSettings::kickoffSearchAddressBook())
+      return;
+
+    if (!m_addressBook)
+      m_addressBook = KABC::StdAddressBook::self( false );
+
+    KABC::AddressBook::ConstIterator it = m_addressBook->begin();
+    while (it!=m_addressBook->end()) {
+        if (!current_query.matches((*it).assembledName()+' '+(*it).fullEmail())) {
+            it++;
+            continue;
+        }
+
+        HitMenuItem *hit_item;
+        QString realName = (*it).realName();
+        if (realName.isEmpty())
+            realName=(*it).preferredEmail();
+
+        if (!(*it).preferredEmail().isEmpty()) {
+	    if (!anotherHitMenuItemAllowed(ACTIONS)) {
+               it++;
+               continue;
+            }
+
+            hit_item = new HitMenuItem (i18n("Send Email to %1").arg(realName), (*it).preferredEmail(),
+                                "mailto:"+(*it).preferredEmail(), QString::null, 0, ACTIONS, "mail_new");
+
+        			insertSearchResult(hit_item);
+        }
+
+	if (!anotherHitMenuItemAllowed(ACTIONS)) {
+               it++;
+               continue;
+        }
+
+        hit_item = new HitMenuItem (i18n("Open Addressbook at %1").arg(realName), (*it).preferredEmail(),
+                                "kaddressbook:/"+(*it).uid(), QString::null, 0, ACTIONS, "kaddressbook");
+
+        			insertSearchResult(hit_item);
+
+       it++;
+    }
+}
+
+QString KMenu::insertBreaks(const QString& text, QFontMetrics fm, int width, QString leadInsert)
+{
+    QString result, line;
+    QStringList words = QStringList::split(' ', text);
+
+    for(QStringList::Iterator it = words.begin(); it != words.end(); ++it) {
+       if (fm.width(line+' '+*it) >= width) {
+          if (!result.isEmpty())
+             result = result + '\n';
+          result = result + line;
+          line = leadInsert + *it;
+       }
+       else
+          line = line + ' ' + *it;
+    }
+    if (!result.isEmpty())
+       result = result + '\n';
+
+    return result + line;
+}
+
+void KMenu::clearSearchResults(bool showHelp)
+{
+    m_searchResultsWidget->clear();
+    m_searchResultsWidget->setFocusPolicy(showHelp ? QWidget::NoFocus : QWidget::StrongFocus);
+    setTabOrder(m_kcommand, m_searchResultsWidget);
+
+    if (showHelp) {
+        const int width = m_searchResultsWidget->width()-10;
+        QFontMetrics fm = m_searchResultsWidget->fontMetrics();
+
+        QListViewItem* item;
+        item = new QListViewItem( m_searchResultsWidget, insertBreaks(i18n("- Add ext:type to specify a file extension."), fm, width, "   ") );
+        item->setSelectable(false);
+        item->setMultiLinesEnabled(true);
+        item = new QListViewItem( m_searchResultsWidget, insertBreaks(i18n("- When searching for a phrase, add quotes."), fm, width, "   " ) );
+        item->setSelectable(false);
+        item->setMultiLinesEnabled(true);
+        item = new QListViewItem( m_searchResultsWidget, insertBreaks(i18n("- To exclude search terms, use the minus symbol in front."), fm, width, "   " ) );
+        item->setSelectable(false);
+        item->setMultiLinesEnabled(true);
+        item = new QListViewItem( m_searchResultsWidget, insertBreaks(i18n("- To search for optional terms, use OR."), fm, width, "   ")  );
+        item->setSelectable(false);
+        item->setMultiLinesEnabled(true);
+        item = new QListViewItem( m_searchResultsWidget, insertBreaks(i18n("- You can use upper and lower case."), fm, width, "   ")  );
+        item->setSelectable(false);
+        item->setMultiLinesEnabled(true);
+        item = new QListViewItem( m_searchResultsWidget, i18n("Search Quick Tips"));
+        item->setSelectable(false);
+    }
+
+    for (int i=0; i<num_categories; ++i) {
+	categorised_hit_total [i] = 0;
+	max_category_id [i] = base_category_id [i];
+    }
+}
+
+void KMenu::doQuery (bool return_pressed)
+{
+    QString query_str = m_kcommand->lineEdit()->text ().simplifyWhiteSpace ();
+    if (! return_pressed && dontQueryNow (query_str)) {
+        if (query_str.length()<3)
+            clearSearchResults();
+        else {
+            if (m_searchResultsWidget->firstChild() && m_searchResultsWidget->firstChild()->isSelectable()) {
+                m_searchResultsWidget->setSelected(m_searchResultsWidget->firstChild(),true);
+            }
+            else if (m_searchResultsWidget->childCount()>1) {
+                m_searchResultsWidget->setSelected(m_searchResultsWidget->firstChild()->itemBelow(),true);
+            }
+        }
+        return;
+    }
+    kdDebug() << "Querying for [" << query_str << "]" << endl;
+    current_query.set(query_str);
+
+    // reset search results
+    HitMenuItem *hit_item;
+    while ((hit_item = m_current_menu_items.take ()) != NULL) {
+        //kndDebug () << " (" << hit_item->id << "," << hit_item->category << ")" << endl;
+        delete hit_item;
+    }
+
+    clearSearchResults(false);
+    m_searchPixmap->setMovie(QMovie(locate( "data", "kicker/pics/search-running.mng" )));
+
+    resetOverflowCategory();
+
+    initCategoryTitlesUpdate();
+
+    // calculate ?
+    QString cmd = query_str.stripWhiteSpace();
+    if (!cmd.isEmpty() && (cmd[0].isNumber() || (cmd[0] == '(')) &&
+            (QRegExp("[a-zA-Z\\]\\[]").search(cmd) == -1))
+    {
+        QString result = calculate(cmd);
+        if (!result.isEmpty())
+        {
+            categorised_hit_total[ACTIONS] ++;
+            HitMenuItem *hit_item = new HitMenuItem (i18n("%1 = %2").arg(query_str, result), QString::null,
+                    "kcalc", QString::null, (++max_category_id [ACTIONS]), ACTIONS, "kcalc");
+            int index = getHitMenuItemPosition (hit_item);
+            m_searchResultsWidget->insertItem(iconForHitMenuItem(hit_item), hit_item->display_name,
+                    hit_item->display_info, KGlobal::dirs()->findExe("kcalc"), max_category_id [ACTIONS], index);
+        }
+    }
+
+    // detect email address
+    if (emailRegExp.exactMatch(query_str)) {
+      categorised_hit_total[ACTIONS] ++;
+      HitMenuItem *hit_item = new HitMenuItem (i18n("Send Email to %1").arg(query_str), QString::null,
+                                "mailto:"+query_str, QString::null, (++max_category_id [ACTIONS]), ACTIONS, "mail_new");
+      int index = getHitMenuItemPosition (hit_item);
+      m_searchResultsWidget->insertItem(iconForHitMenuItem(hit_item), hit_item->display_name, hit_item->display_info, "mailto:"+query_str, max_category_id [ACTIONS], index);
+    }
+
+    // quick own application search
+    m_programsInMenu.clear();
+    searchProgramList(QString::null);
+
+    KURIFilterData filterData;
+    filterData.setData(query_str);
+    filterData.setCheckForExecutables(true);
+
+    if (KURIFilter::self()->filterURI(filterData)) {
+
+        QString description;
+        QString exe;
+
+        switch (filterData.uriType()) {
+        case KURIFilterData::LOCAL_FILE:
+            description = i18n("Open Local File: %1").arg(filterData.uri().url());
+            break;
+        case KURIFilterData::LOCAL_DIR:
+            description = i18n("Open Local Dir: %1").arg(filterData.uri().url());
+            break;
+        case KURIFilterData::NET_PROTOCOL:
+            description = i18n("Open Remote Location: %1").arg(filterData.uri().url());
+            break;
+        case KURIFilterData::SHELL:
+        case KURIFilterData::EXECUTABLE:
+        {
+            exe = KGlobal::dirs()->findExe(filterData.uri().url());
+#ifdef KDELIBS_SUSE
+            bool gimp_hack = false;
+            if (exe.endsWith("/bin/gimp")) {
+               QStringList::ConstIterator it = m_programsInMenu.begin();
+               for (; it != m_programsInMenu.end(); ++it)
+                  if ((*it).find("bin/gimp-remote-")!=-1) {
+                    gimp_hack = true;
+                    break;
+                  }
+            }
+#endif
+            if (m_programsInMenu.find(exe)!=m_programsInMenu.end()
+#ifdef KDELIBS_SUSE
+                || gimp_hack
+#endif
+                )
+                exe = QString::null;
+            else if (kapp->authorize("shell_access"))
+            {
+                if( filterData.hasArgsAndOptions() )
+                    exe += filterData.argsAndOptions();
+
+                description = i18n("Run '%1'").arg(exe);
+                exe = "kicker:/runcommand";
+            }
+        }
+        default:
+            break;
+        }
+
+        if (!description.isEmpty()) {
+            categorised_hit_total[ACTIONS] ++;
+            HitMenuItem *hit_item = new HitMenuItem (description, QString::null,
+                    exe.isEmpty() ? filterData.uri() : exe, QString::null,
+                    (++max_category_id [ACTIONS]), ACTIONS, exe.isEmpty() ? "fileopen": "run");
+            int index = getHitMenuItemPosition (hit_item);
+            m_searchResultsWidget->insertItem(iconForHitMenuItem(hit_item), hit_item->display_name,
+                    hit_item->display_info,
+                    exe.isEmpty() ? filterData.uri().url() : exe, max_category_id [ACTIONS], index);
+        }
+    }
+
+    // search Konqueror bookmarks;
+    if (!bookmarkManager)
+      bookmarkManager = KBookmarkManager::userBookmarksManager();
+
+    if (query_str.length()>=3)
+      searchBookmarks(bookmarkManager->root());
+
+    // search KDE addressbook
+    if (query_str.length()>=3)
+      searchAddressbook();
+
+    updateCategoryTitles();
+
+    if (m_searchResultsWidget->childCount()>1)
+      m_searchResultsWidget->setSelected(m_searchResultsWidget->firstChild()->itemBelow(),true);
+    m_searchActions->clearSelection();
+
+    if (!m_search_plugin)
+      initSearch();
+
+    // start search plugin only with at least 3 characters
+    if (query_str.length()<3 || !m_search_plugin || (m_search_plugin && !m_search_plugin->daemonRunning()) ) {
+      m_searchPixmap->setPixmap( BarIcon( "find", 32 ) );
+      fillOverflowCategory();
+      if (query_str.length()>2 && m_current_menu_items.isEmpty())
+	  reportError (i18n("No matches found"));
+      return;
+    }
+
+    if (m_search_plugin) {
+      m_search_plugin->query(current_query.get(), KickerSettings::DescriptionAndName || KickerSettings::menuEntryFormat() == KickerSettings::DescriptionOnly);
+    }
+}
+
+bool KMenu::anotherHitMenuItemAllowed(int cat, bool count)
+{
+	// update number of hits in this category
+        if (count)
+	    categorised_hit_total [cat] ++;
+
+	// if number of hits in this category is more than allowed, dont process this
+	if (max_category_id [cat] - base_category_id [cat] < max_items(cat))
+            return true;
+
+        if (m_overflowCategoryState==None || (m_overflowCategoryState==Filling && m_overflowCategory==cat &&
+            max_category_id [cat] + m_overflowList.count() - base_category_id [cat] < max_items(cat) * 2.0))
+            return true;
+
+        return false;
+}
+
+void KMenu::addHitMenuItem(HitMenuItem* item)
+{
+        if (checkUriInMenu(item->uri))
+            return;
+
+	// if number of hits in this category is more than allowed, dont process this
+	if (!anotherHitMenuItemAllowed(item->category, false))
+	    return;
+
+        insertSearchResult(item);
+}
+
+void KMenu::insertSearchResult(HitMenuItem* item)
+{
+        if (m_overflowCategoryState==None) {
+            m_overflowCategoryState = Filling;
+            m_overflowCategory = item->category;
+        }
+        else if (m_overflowCategoryState==Filling && m_overflowCategory!=item->category)
+            m_overflowCategoryState = NotNeeded;
+
+        if (max_category_id [item->category] - base_category_id [item->category] < max_items(item->category)) {
+	    max_category_id [item->category]++;
+            item->id=max_category_id [item->category];
+
+            int index = getHitMenuItemPosition (item);
+
+            kdDebug () << "Adding " << item->uri
+    		    << "(" << item->mimetype << ") with id="
+    		    << max_category_id [item->category] << " at " << index << endl;
+
+            KMenuItem *hit_item = m_searchResultsWidget->insertItem(iconForHitMenuItem(item), item->display_name, item->display_info, item->uri.url(), max_category_id [item->category], index);
+            hit_item->setService(item->service);
+
+            kdDebug () << "Done inserting ... " << endl;
+        }
+        else if (m_overflowCategoryState==Filling && m_overflowCategory==item->category &&
+            max_category_id [item->category] - base_category_id [item->category] < max_items(item->category) * 2)
+               m_overflowList.append(item);
+}
+
+void KMenu::searchOver()
+{
+    m_searchPixmap->setPixmap( BarIcon( "find", 32 ) );
+    fillOverflowCategory();
+    if (m_current_menu_items.isEmpty()) {
+        kdDebug() << "No matches found" << endl;
+	reportError (i18n("No matches found"));
+    }
+    if (!m_searchResultsWidget->selectedItem() && !m_searchActions->selectedItem() && m_searchResultsWidget->childCount()>1) {
+            m_searchResultsWidget->setSelected(m_searchResultsWidget->firstChild()->itemBelow(),true);
+        }
+}
+
+void KMenu::initCategoryTitlesUpdate()
+{
+    // Need to know if each category was updated with hits or had the first hit
+    // That way we know if we need to changetitle or inserttitle
+    already_added = new bool [num_categories];
+    for (int i=0; i<num_categories; ++i)
+	already_added [i] = (max_category_id [i] != base_category_id [i]);
+}
+
+void KMenu::updateCategoryTitles()
+{
+    // update category title
+    for (int i=0; i<num_categories; ++i) {
+	if (i == OTHER)
+	    continue;
+	// nothing is in this category
+	if (max_category_id [i] == base_category_id [i])
+	    continue;
+
+        KMenuItemSeparator *sep = 0;
+
+	// if nothing was in this category before but now there is
+	if (! already_added [i]) {
+	    // insert a new title for this category
+	    int index = getHitMenuItemPosition (new HitMenuItem (
+						    base_category_id[i],
+						    i));
+            QString title = QString ("%1").arg (i18n(categories [i].utf8()));
+            sep = m_searchResultsWidget->insertSeparator(base_category_id [i], title, index);
+	    kdDebug () << "Inserting heading with id=" << base_category_id[i] << " for " << categories[i] << " at " << index << endl;
+	} else {
+	    // something was already displayed in this category
+	    // update the title to reflect the total
+            sep = dynamic_cast<KMenuItemSeparator*>( m_searchResultsWidget->findItem(base_category_id [i]) );
+            if ( !sep )
+                continue;
+            kdDebug () << "Changing heading of id=" << base_category_id[i] << " for " << categories[i] << endl;
+	}
+
+        int max = max_items(i);
+        if (m_overflowCategoryState == Filling && m_overflowCategory == i)
+            max *= 2;
+
+        if ( categorised_hit_total [i] > max ) {
+            if (m_kerryInstalled)
+                sep->setLink( i18n( "top %1 of %2" ).arg( max ).arg( categorised_hit_total [i] ), QString( "kerry:/%1" ).arg( i ) );
+            else
+                sep->setText( 0, i18n( "%1 (top %2 of %3)" ).arg( i18n(categories [i].utf8()) ).arg( max ).arg( categorised_hit_total [i] ) );
+        }
+        else {
+            sep->setLink( QString::null );
+        }
+    }
+    delete[] already_added;
+    already_added = 0;
+}
+
+QString KMenu::iconForHitMenuItem(HitMenuItem *hit_item)
+{
+    // get the icon
+    if (!hit_item->icon.isEmpty())
+        return hit_item->icon;
+
+    if (hit_item->category == WEBHIST) {
+        QString favicon = KMimeType::favIconForURL (hit_item->uri);
+        if (! favicon.isEmpty ())
+	    return favicon;
+    }
+
+    if (mimetype_iconstore.contains (hit_item->mimetype))
+        return (mimetype_iconstore [hit_item->mimetype]);
+    else {
+        KMimeType::Ptr mimetype_ptr = KMimeType::mimeType (hit_item->mimetype);
+        QString mimetype_icon = mimetype_ptr->icon(QString::null, FALSE);
+        mimetype_iconstore [hit_item->mimetype] = mimetype_icon;
+        return mimetype_icon;
+    }
+    return QString::null;
+}
+
+void KMenu::slotStartService(KService::Ptr ptr)
+{
+    accept();
+
+    addToHistory();
+    KApplication::startServiceByDesktopPath(ptr->desktopEntryPath(),
+                                            QStringList(), 0, 0, 0, "", true);
+    updateRecentlyUsedApps(ptr);
+}
+
+
+void KMenu::slotStartURL(const QString& u)
+{
+    if ( u == "kicker:/goup/" ) {
+        // only m_exitView is connected to this slot, not m_browserView
+        slotGoExitMainMenu();
+        return;
+    }
+
+    if ( u == "kicker:/restart/" || u=="kicker:/switchuser/") {
+        slotGoExitSubMenu(u);
+        return;
+    }
+
+    accept();
+
+    if ( u == "kicker:/lock" ) {
+        slotLock();
+    }
+    else if ( u == "kicker:/logout" ) {
+#ifdef KDELIBS_SUSE
+        QByteArray params;
+        QDataStream stream(params, IO_WriteOnly);
+        stream << 0 << -1 << "";
+
+        kapp->dcopClient()->send("ksmserver", "default", "logoutTimed(int,int,QString)", params);
+#else
+        DCOPRef mediamanager("ksmserver", "ksmserver");
+        DCOPReply reply = mediamanager.call( "logoutTimed", (int)KApplication::ShutdownTypeNone, (int)KApplication::ShutdownModeDefault );
+	if (!reply.isValid() && KMessageBox::Continue==KMessageBox::warningContinueCancel(this, i18n("Do you really want to end the session?"),
+                                                                                          i18n("Logout Confirmation"), KGuiItem(i18n("Logout"),"undo")))
+            kapp->requestShutDown( KApplication::ShutdownConfirmNo,
+                                   KApplication::ShutdownTypeNone,
+                                   KApplication::ShutdownModeDefault );
+
+#endif
+    }
+    else if ( u == "kicker:/runcommand" )
+    {
+         runCommand();
+    }
+    else if ( u == "kicker:/shutdown" ) {
+#ifdef KDELIBS_SUSE
+        QByteArray params;
+        QDataStream stream(params, IO_WriteOnly);
+        stream << 2 << -1 << "";
+
+        kapp->dcopClient()->send("ksmserver", "default", "logoutTimed(int,int,QString)", params);
+#else
+        if (KMessageBox::Continue==KMessageBox::warningContinueCancel(this, i18n("Do you really want to turn off the computer?"),
+                                                                      i18n("Shutdown Confirmation"), KGuiItem(i18n("Shutdown"),"exit")))
+            kapp->requestShutDown( KApplication::ShutdownConfirmNo,
+                                   KApplication::ShutdownTypeHalt,
+                                   KApplication::ShutdownModeDefault );
+#endif
+    }
+    else if ( u == "kicker:/restart" ) {
+#ifdef KDELIBS_SUSE
+        QByteArray params;
+        QDataStream stream(params, IO_WriteOnly);
+        stream << 1 << -1 << QString::null;
+
+        kapp->dcopClient()->send("ksmserver", "default", "logoutTimed(int,int,QString)", params);
+#else
+        if (KMessageBox::Continue==KMessageBox::warningContinueCancel(this, i18n("Do you really want to reset the computer and boot (another operating system)?"),
+                                                                      i18n("Restart Confirmation"), KGuiItem(i18n("Restart"),"reload")))
+            kapp->requestShutDown( KApplication::ShutdownConfirmNo,
+                                   KApplication::ShutdownTypeReboot,
+                                   KApplication::ShutdownModeDefault );
+#endif
+    }
+#ifdef KDELIBS_SUSE
+    else if ( u == "kicker:/suspend_disk" ) {
+        slotSuspend( 1 );
+    }
+    else if ( u == "kicker:/suspend_ram" ) {
+        slotSuspend( 2 );
+    }
+    else if ( u == "kicker:/standby" ) {
+        slotSuspend( 3 );
+    }
+#endif
+    else if ( u == "kicker:/savesession" ) {
+        QByteArray data;
+        kapp->dcopClient()->send( "ksmserver", "default",
+                "saveCurrentSession()", data );
+    }
+    else if ( u == "kicker:/switchuser" ) {
+        DM().startReserve();
+    }
+    else if ( u == "kicker:/switchuserafterlock" ) {
+        slotLock();
+        DM().startReserve();
+    }
+    else if ( u.startsWith("kicker:/switchuser_") )
+        DM().lockSwitchVT( u.mid(19).toInt() );
+    else if ( u.startsWith("kicker:/restart_") ) {
+#ifdef KDELIBS_SUSE
+        QStringList rebootOptions;
+        int def, cur;
+        DM().bootOptions( rebootOptions, def, cur );
+
+        QByteArray params;
+        QDataStream stream(params, IO_WriteOnly);
+        stream << 1 << -1 << rebootOptions[u.mid(16).toInt()];
+
+        kapp->dcopClient()->send("ksmserver", "default", "logoutTimed(int,int,QString)", params);
+#else
+        KMessageBox::error( this, QString( "Sorry, not implemented." ));
+#endif
+    }
+#warning restart entry not supported
+#if 0
+    else if ( u == "kicker:/restart_windows" ) {
+        if (KMessageBox::Continue==KMessageBox::warningContinueCancel(this, i18n("Do you really want to reset the computer and boot Microsoft Windows"), i18n("Start Windows Confirmation"), KGuiItem(i18n("Start Windows"),"reload")))
+            KMessageBox::error( this, QString( "kicker:/restart_windows is not yet implemented " ) );
+    }
+#endif
+    else if ( u.startsWith("kerry:/"))
+    {
+       QByteArray data;
+       QDataStream arg(data, IO_WriteOnly);
+       arg << m_kcommand->currentText() << kerry_categories[u.mid(7).toInt()];
+       if (ensureServiceRunning("kerry"))
+           kapp->dcopClient()->send("kerry","search","search(QString,QString)", data);
+    }
+    else {
+        addToHistory();
+        if (u.startsWith("kaddressbook:/")) {
+            KProcess *proc = new KProcess;
+            *proc << "kaddressbook" << "--uid" << u.mid(14);
+            proc->start();
+            accept();
+            return;
+        } else if (u.startsWith("note:/")) {
+            KProcess *proc = new KProcess;
+            *proc << "tomboy";
+            *proc << "--open-note" << u;
+            if (!proc->start())
+               KMessageBox::error(0,i18n("Could not start Tomboy."));
+            return;
+        }
+        else if (u.startsWith("knotes:/") ) {
+            if (ensureServiceRunning("knotes")) {
+                QByteArray data;
+                QDataStream arg(data, IO_WriteOnly);
+                arg << u.mid(9,22);
+
+                kapp->dcopClient()->send("knotes","KNotesIface","showNote(QString)", data);
+            }
+            return;
+        }
+
+        kapp->propagateSessionManager();
+        (void) new KRun( u, parentWidget());
+    }
+}
+
+void KMenu::slotContextMenuRequested( QListViewItem * item, const QPoint & pos, int /*col*/ )
+{
+    const QObject* source = sender();
+
+    if (!item)
+        return;
+
+    KMenuItem* kitem = dynamic_cast<KMenuItem*>(item);
+    if (!kitem)
+        return;
+
+    KFileItemList _items;
+    _items.setAutoDelete(true);
+
+    if (dynamic_cast<KMenuItemSeparator*>(item))
+        return;
+
+    m_popupService = kitem->service();
+    m_popupPath.menuPath = kitem->menuPath();
+    if (!m_popupService) {
+        m_popupPath.title = kitem->title();
+        m_popupPath.description = kitem->description();
+        m_popupPath.path = kitem->path();
+        m_popupPath.icon = kitem->icon();
+
+        if (m_popupPath.path.startsWith(locateLocal("data", QString::fromLatin1("RecentDocuments/")))) {
+               KDesktopFile df(m_popupPath.path,true);
+               m_popupPath.path=df.readURL();
+        }
+    }
+
+    m_popupMenu = new KPopupMenu(this);
+    connect(m_popupMenu, SIGNAL(activated(int)), SLOT(slotContextMenu(int)));
+    bool hasEntries = false;
+
+    m_popupMenu->insertTitle(SmallIcon(kitem->icon()),kitem->title());
+
+     if (source==m_favoriteView)
+     {
+         hasEntries = true;
+         m_popupMenu->insertItem(SmallIconSet("remove"),
+             i18n("Remove From Favorites"), RemoveFromFavorites);
+     }
+     else if (!kitem->hasChildren() && !m_popupPath.path.startsWith("system:/") &&
+        !m_popupPath.path.startsWith("kicker:/switchuser_") && !m_popupPath.path.startsWith("kicker:/restart_"))
+     {
+         hasEntries = true;
+         int num = m_popupMenu->insertItem(SmallIconSet("bookmark_add"),
+             i18n("Add to Favorites"), AddToFavorites);
+
+         QStringList favs = KickerSettings::favorites();
+         if (m_popupService && favs.find(m_popupService->storageId())!=favs.end())
+            m_popupMenu->setItemEnabled(num, false);
+         else {
+            QStringList::Iterator it;
+            for (it = favs.begin(); it != favs.end(); ++it)
+            {
+                if ((*it)[0]=='/')
+                {
+                    KDesktopFile df((*it),true);
+                    if (df.readURL().replace("file://",QString::null)==m_popupPath.path)
+                        break;
+                }
+            }
+            if (it!=favs.end())
+                m_popupMenu->setItemEnabled(num, false);
+         }
+     }
+
+     if (source!=m_exitView) {
+        if (m_popupService || (!m_popupPath.path.startsWith("kicker:/") && !m_popupPath.path.startsWith("system:/") && !m_popupPath.path.startsWith("kaddressbook:/"))) {
+            if (hasEntries)
+                m_popupMenu->insertSeparator();
+
+            if (kapp->authorize("editable_desktop_icons") )
+            {
+                hasEntries = true;
+                if (m_popupPath.menuPath.endsWith("/"))
+                  m_popupMenu->insertItem(SmallIconSet("desktop"),
+                    i18n("Add Menu to Desktop"), AddMenuToDesktop);
+                else
+                  m_popupMenu->insertItem(SmallIconSet("desktop"),
+                      i18n("Add Item to Desktop"), AddItemToDesktop);
+            }
+            if (kapp->authorizeKAction("kicker_rmb") && !Kicker::the()->isImmutable())
+            {
+                hasEntries = true;
+                if (m_popupPath.menuPath.endsWith("/"))
+                   m_popupMenu->insertItem(SmallIconSet("kicker"),
+                      i18n("Add Menu to Main Panel"), AddMenuToPanel);
+                else
+                   m_popupMenu->insertItem(SmallIconSet("kicker"),
+                      i18n("Add Item to Main Panel"), AddItemToPanel);
+            }
+            if (kapp->authorizeKAction("menuedit") && !kitem->menuPath().isEmpty())
+            {
+                hasEntries = true;
+                if (kitem->menuPath().endsWith("/"))
+                  m_popupMenu->insertItem(SmallIconSet("kmenuedit"), i18n("Edit Menu"), EditMenu);
+                else
+                  m_popupMenu->insertItem(SmallIconSet("kmenuedit"), i18n("Edit Item"), EditItem);
+            }
+            if (kapp->authorize("run_command") && (m_popupService || (!m_popupPath.menuPath.isEmpty() && !m_popupPath.menuPath.endsWith("/"))))
+            {
+               hasEntries = true;
+               m_popupMenu->insertItem(SmallIconSet("run"),
+               i18n("Put Into Run Dialog"), PutIntoRunDialog);
+            }
+        }
+        if (source==m_searchResultsWidget || ((source==m_favoriteView || source==m_recentlyView || source == m_systemView) && !m_popupService && !m_popupPath.path.startsWith("kicker:/")) ) {
+            QString uri;
+            if (m_popupService)
+                uri = locate("apps", m_popupService->desktopEntryPath());
+            else
+                uri = m_popupPath.path;
+
+            QString mimetype = QString::null;
+            if ( m_popupPath.path.startsWith( "system:/media/" ) )
+                mimetype = media_mimetypes[m_popupPath.path];
+
+            KFileItem* item = new KFileItem(uri, mimetype, KFileItem::Unknown);
+            _items.append( item );
+
+            const KURL kurl(uri);
+            KActionCollection act(this);
+
+            KonqPopupMenu * konqPopupMenu = new KonqPopupMenu( KonqBookmarkManager::self(), _items,
+                                                   kurl, act, (KNewMenu*)NULL, this,
+                                                   item->isLocalFile() ? KonqPopupMenu::ShowProperties : KonqPopupMenu::NoFlags,
+                                                   KParts::BrowserExtension::DefaultPopupItems );
+
+            if (konqPopupMenu->count()) {
+                if (hasEntries) {
+                    m_popupMenu->insertSeparator();
+                    m_popupMenu->insertItem(SmallIconSet("add"),i18n("Advanced"), konqPopupMenu);
+                }
+                else {
+                    delete m_popupMenu;
+                    m_popupMenu = (KPopupMenu*)konqPopupMenu;
+                    m_popupMenu->insertTitle(SmallIcon(kitem->icon()),kitem->title(),-1,0);
+                }
+                hasEntries = true;
+            }
+        }
+    }
+
+    if (source==m_recentlyView) {
+       m_popupMenu->insertSeparator();
+       if (m_popupService)
+         m_popupMenu->insertItem(SmallIconSet("history_clear"),
+                 i18n("Clear Recently Used Applications"), ClearRecentlyUsedApps);
+       else
+         m_popupMenu->insertItem(SmallIconSet("history_clear"),
+                 i18n("Clear Recently Used Documents"), ClearRecentlyUsedDocs);
+    }
+
+    if (hasEntries) {
+       m_isShowing = true;
+       m_popupMenu->exec(pos);
+       m_isShowing = false;
+    }
+
+    delete m_popupMenu;
+    m_popupMenu = 0;
+}
+
+void KMenu::slotContextMenu(int selected)
+{
+    KServiceGroup::Ptr g;
+    QByteArray ba;
+    QDataStream ds(ba, IO_WriteOnly);
+
+    KURL src,dest;
+    KIO::CopyJob *job;
+
+    KProcess *proc;
+
+    QStringList favs = KickerSettings::favorites();
+
+    switch (selected) {
+        case AddItemToDesktop:
+            accept();
+	    if (m_popupService) {
+	        src.setPath( KGlobal::dirs()->findResource( "apps", m_popupService->desktopEntryPath() ) );
+	        dest.setPath( KGlobalSettings::desktopPath() );
+	        dest.setFileName( src.fileName() );
+
+                job = KIO::copyAs( src, dest );
+                job->setDefaultPermissions( true );
+ 	    }
+            else {
+		KDesktopFile* df = new KDesktopFile( newDesktopFile(KURL(m_popupPath.path), KGlobalSettings::desktopPath() ) );
+		df->writeEntry("GenericName", m_popupPath.description);
+		df->writeEntry( "Icon", m_popupPath.icon );
+		df->writePathEntry( "URL", m_popupPath.path );
+		df->writeEntry( "Name", m_popupPath.title );
+		df->writeEntry( "Type", "Link" );
+		df->sync();
+		delete df;
+            }
+            accept();
+	    break;
+
+	case AddItemToPanel:
+            accept();
+	    if (m_popupService)
+	    	kapp->dcopClient()->send("kicker", "Panel", "addServiceButton(QString)", m_popupService->desktopEntryPath());
+            else
+#warning FIXME special RecentDocuments/foo.desktop handling
+	    	kapp->dcopClient()->send("kicker", "Panel", "addURLButton(QString)", m_popupPath.path);
+	    accept();
+	    break;
+
+	case EditItem:
+        case EditMenu:
+	    accept();
+            proc = new KProcess(this);
+            *proc << KStandardDirs::findExe(QString::fromLatin1("kmenuedit"));
+            *proc << "/"+m_popupPath.menuPath.section('/',-200,-2) << m_popupPath.menuPath.section('/', -1);
+            proc->start();
+	    break;
+
+	case PutIntoRunDialog:
+	    accept();
+	    if (m_popupService)
+	      kapp->dcopClient()->send("kdesktop", "default", "popupExecuteCommand(QString)", m_popupService->exec());
+	    else
+#warning FIXME special RecentDocuments/foo.desktop handling
+              kapp->dcopClient()->send("kdesktop", "default", "popupExecuteCommand(QString)", m_popupPath.path);
+            accept();
+	    break;
+
+	case AddMenuToDesktop: {
+	    accept();
+	    KDesktopFile *df = new KDesktopFile( newDesktopFile(KURL("programs:/"+m_popupPath.menuPath),KGlobalSettings::desktopPath()));
+            df->writeEntry( "Icon", m_popupPath.icon );
+            df->writePathEntry( "URL", "programs:/"+m_popupPath.menuPath );
+	    df->writeEntry( "Name", m_popupPath.title );
+	    df->writeEntry( "Type", "Link" );
+            df->sync();
+	    delete df;
+
+	    break;
+            }
+	case AddMenuToPanel:
+	    accept();
+            ds << "foo" << m_popupPath.menuPath;
+	    kapp->dcopClient()->send("kicker", "Panel", "addServiceMenuButton(QString,QString)", ba);
+	    break;
+
+        case AddToFavorites:
+	    if (m_popupService) {
+              if (favs.find(m_popupService->storageId())==favs.end()) {
+                KService::Ptr p = KService::serviceByStorageId(m_popupService->storageId());
+                m_favoriteView->insertMenuItem(p, serviceMenuEndId()+favs.count()+1);
+                favs+=m_popupService->storageId();
+              }
+            }
+            else {
+               QStringList::Iterator it;
+               for (it = favs.begin(); it != favs.end(); ++it) {
+                  if ((*it)[0]=='/') {
+                     KDesktopFile df((*it),true);
+                     if (df.readURL().replace("file://",QString::null)==m_popupPath.path)
+                        break;
+                  }
+               }
+               if (it==favs.end()) {
+                 QString file = KickerLib::newDesktopFile(m_popupPath.path);
+                 KDesktopFile df(file);
+                 df.writeEntry("Encoding", "UTF-8");
+                 df.writeEntry("Type","Link");
+                 df.writeEntry("Name", m_popupPath.title);
+                 df.writeEntry("GenericName", m_popupPath.description);
+                 df.writeEntry("Icon", m_popupPath.icon);
+                 df.writeEntry("URL", m_popupPath.path);
+
+                 m_favoriteView->insertItem(m_popupPath.icon, m_popupPath.title, m_popupPath.description,
+                    m_popupPath.path, serviceMenuEndId()+favs.count()+1, -1);
+
+                 favs+=file;
+               }
+            }
+            KickerSettings::setFavorites(favs);
+            KickerSettings::writeConfig();
+            m_browserDirty=true;
+            m_stacker->raiseWidget(FavoriteTab);
+	    break;
+
+        case RemoveFromFavorites:
+	    if (m_popupService) {
+              favs.erase(favs.find(m_popupService->storageId()));
+
+              for (QListViewItemIterator it(m_favoriteView); it.current(); ++it) {
+                 KMenuItem* kitem = static_cast<KMenuItem*>(it.current());
+	         if (kitem->service() && kitem->service()->storageId() == m_popupService->storageId()) {
+                   delete it.current();
+                   break;
+                 }
+              }
+            }
+            else {
+               for (QStringList::Iterator it = favs.begin(); it != favs.end(); ++it) {
+                  if ((*it)[0]=='/') {
+                     KDesktopFile df((*it),true);
+                     if (df.readURL().replace("file://",QString::null)==m_popupPath.path) {
+			QFile::remove((*it));
+                        favs.erase(it);
+                        break;
+                     }
+                  }
+               }
+               for (QListViewItemIterator it(m_favoriteView); it.current(); ++it) {
+                  KMenuItem* kitem = static_cast<KMenuItem*>(it.current());
+	          if (!kitem->service() && kitem->path() == m_popupPath.path) {
+                     delete it.current();
+                     break;
+                  }
+               }
+            }
+	    m_favoriteView->slotMoveContent();
+            KickerSettings::setFavorites(favs);
+            KickerSettings::writeConfig();
+            m_browserDirty=true;
+            m_stacker->raiseWidget(FavoriteTab);
+	    break;
+
+        case ClearRecentlyUsedApps:
+            clearRecentAppsItems();
+	    break;
+
+        case ClearRecentlyUsedDocs:
+            clearRecentDocsItems();
+	    break;
+
+	default:
+	    break;
+	}
+}
+
+void KMenu::resizeEvent ( QResizeEvent * e )
+{
+    //kdDebug() << "resizeEvent " << size() << endl;
+    KMenuBase::resizeEvent(e);
+    int ypos = 0;
+    // this is the height remaining to fill
+    int left_height = height();
+
+    if ( m_orientation == BottomUp )
+    {
+        m_resizeHandle->move( e->size().width() - 19, 3);
+
+        // put the search widget at the top of the menu and give it its desired
+        // height
+        m_search->mainWidget()->setGeometry( 0, ypos, width(),
+                m_search->minimumSize().height() );
+        left_height -= m_search->minimumSize().height();
+        ypos += m_search->minimumSize().height();
+
+        // place the footer widget at the bottom of the menu and give it its desired
+        // height
+        m_footer->mainWidget()->setGeometry( 0, height() - m_footer->minimumSize().height(),
+                width(), m_footer->minimumSize().height() );
+        left_height -= m_footer->minimumSize().height();
+
+        // place the button box above the footer widget, horizontal placement
+        // has the width of the edge graphics subtracted
+        m_tabBar->setGeometry(button_box_left.width(),
+                height() - m_footer->minimumSize().height() -
+                m_tabBar->sizeHint().height(),
+                width() - button_box_left.width(),
+                m_tabBar->sizeHint().height() );
+        left_height -= m_tabBar->sizeHint().height();
+
+        // place the main (stacker) widget below the search widget,
+        // in the remaining vertical space
+        m_stacker->setGeometry(0, ypos,
+                width(),
+                left_height );
+
+    }
+    else // TopDown orientation
+    {
+        // place the 'footer' widget at the top of the menu and give it
+        // its desired height
+        m_footer->mainWidget()->setGeometry( 0,
+                ypos /*height() - m_footer->minimumSize().height()*/,
+                width(),
+                m_footer->minimumSize().height() );
+        ypos += m_footer->minimumSize().height();
+        left_height -= m_footer->minimumSize().height();
+
+        // place the button box next at the top of the menu.
+        // has the width of the edge graphics subtracted
+        m_tabBar->setGeometry(button_box_left.width(), ypos, width() - button_box_left.width(),
+                m_tabBar->sizeHint().height());
+
+        ypos += m_tabBar->sizeHint().height();
+        left_height -= m_tabBar->sizeHint().height();
+
+        // put the search widget above the footer widget
+        // height
+        m_search->mainWidget()->setGeometry( 0,
+                height() - m_search->minimumSize().height(),
+                width(),
+                m_search->minimumSize().height()
+                );
+        left_height -= m_search->minimumSize().height();
+
+        // place the main (stacker) widget below the button box,
+        // in the remaining vertical space
+        m_stacker->setGeometry(0, ypos,
+                width(),
+                left_height );
+        m_resizeHandle->move( e->size().width() - 19, e->size().height() - 19);
+    }
+    paintSearchTab( false );
+}
+
+void KMenu::mousePressEvent ( QMouseEvent * e )
+{
+    if ( m_orientation == BottomUp ) {
+       if (e->x() > width() - m_resizeHandle->width() &&
+          e->y() < m_resizeHandle->height() )
+       {
+            m_isresizing = true;
+       }
+    }
+    else {
+       if (e->x() > width() - m_resizeHandle->width() &&
+          e->y() > height() - m_resizeHandle->height() )
+       {
+            m_isresizing = true;
+       }
+    }
+    KMenuBase::mousePressEvent(e);
+}
+
+void KMenu::mouseReleaseEvent ( QMouseEvent * /*e*/ )
+{
+    m_isresizing = false;
+}
+
+void KMenu::mouseMoveEvent ( QMouseEvent * e )
+{
+    if ( hasMouseTracking() && m_isresizing ) {
+        m_stacker->setMinimumSize( QSize(0, 0) );
+        m_stacker->setMaximumSize( QSize(32000, 32000) );
+        int newWidth = QMAX( e->x() - x(), minimumSizeHint().width() );
+        if ( m_orientation == BottomUp ) {
+          int newHeight = QMAX( height() - e->y(), minimumSizeHint().height() + 10 );
+          int newY = y() + height() - newHeight;
+          setGeometry( x(), newY, newWidth, newHeight);
+        }
+        else {
+          setGeometry( x(), y(), newWidth, QMAX( e->y(), minimumSizeHint().height() + 10 ));
+        }
+    }
+}
+
+void KMenu::clearedHistory()
+{
+    saveConfig();
+}
+
+void KMenu::saveConfig()
+{
+    KickerSettings::setHistory( m_kcommand->historyItems() );
+    KickerSettings::setCompletionItems( m_kcommand->completionObject()->items() );
+    KickerSettings::writeConfig();
+}
+
+void KMenu::notifyServiceStarted(KService::Ptr service)
+{
+    // Inform other applications (like the quickstarter applet)
+    // that an application was started
+    QByteArray params;
+    QDataStream stream(params, IO_WriteOnly);
+    stream << "minicli" << service->storageId();
+    kdDebug() << "minicli appLauncher dcop signal: " << service->storageId() << endl;
+    KApplication::kApplication()->dcopClient()->emitDCOPSignal("appLauncher",
+        "serviceStartedByStorageId(QString,QString)", params);
+}
+
+void KMenu::parseLine( bool final )
+{
+  QString cmd = m_kcommand->currentText().stripWhiteSpace();
+  m_filterData->setData( cmd );
+
+  if( final )
+    KURIFilter::self()->filterURI( *(m_filterData), m_finalFilters );
+  else
+    KURIFilter::self()->filterURI( *(m_filterData), m_middleFilters );
+
+  m_iconName = m_filterData->iconName();
+
+  kdDebug (1207) << "Command: " << m_filterData->uri().url() << endl;
+  kdDebug (1207) << "Arguments: " << m_filterData->argsAndOptions() << endl;
+}
+
+// report error as a title in the menu
+void KMenu::reportError (QString error)
+{
+    int index = 1000; //getHitMenuItemPosition (new HitMenuItem (base_category_id[0], 0));
+    kndDebug () << "Inserting error:" << error << " at position " << index << endl;
+    m_searchResultsWidget->insertSeparator(OTHER_ID_BASE + 120, error, index);
+}
+
+int KMenu::getHitMenuItemPosition ( HitMenuItem *hit_item)
+{
+    QPtrListIterator<HitMenuItem> it (m_current_menu_items);
+    const HitMenuItem *cur_item;
+    int pos = 0;
+    while ((cur_item = it.current ()) != NULL) {
+	++it;
+	if ((cur_item->category!=hit_item->category || !cur_item->display_name.isEmpty()) && (*hit_item) < (*cur_item))
+	    break;
+	pos++;
+    }
+    m_current_menu_items.insert (pos, hit_item);
+
+    return pos + 1;
+}
+
+bool KMenu::checkUriInMenu( const KURL &uri)
+{
+    QPtrListIterator<HitMenuItem> it (m_current_menu_items);
+    const HitMenuItem *cur_item;
+    while ((cur_item = it.current ()) != NULL) {
+	++it;
+	if (cur_item->uri == uri )
+	    return true;
+    }
+
+    return false;
+}
+
+void KMenu::searchActionClicked(QListViewItem* item)
+{
+   accept();
+
+   addToHistory();
+   if (item==m_searchIndex) {
+     QByteArray data;
+     QDataStream arg(data, IO_WriteOnly);
+     arg << m_kcommand->currentText();
+
+     if (ensureServiceRunning("kerry"))
+       kapp->dcopClient()->send("kerry","search","search(QString)", data);
+   }
+   else {
+     KURIFilterData data;
+     QStringList list;
+     data.setData( m_kcommand->currentText() );
+     list << "kurisearchfilter" << "kuriikwsfilter";
+
+     if( !KURIFilter::self()->filterURI(data, list) ) {
+         KDesktopFile file("searchproviders/google.desktop", true, "services");
+         data.setData(file.readEntry("Query").replace("\\{@}", m_kcommand->currentText()));
+     }
+
+     (void) new KRun( data.uri(), parentWidget());
+   }
+}
+
+void KMenu::addToHistory()
+{
+  QString search = m_kcommand->currentText().stripWhiteSpace();
+
+  if (search.length()<4)
+    return;
+
+  m_kcommand->addToHistory( search );
+}
+
+QString KMenu::newDesktopFile(const KURL& url, const QString &directory)
+{
+   QString base = url.fileName();
+   if (base.endsWith(".desktop"))
+      base.truncate(base.length()-8);
+   QRegExp r("(.*)(?=-\\d+)");
+   if (r.search(base) > -1)
+      base = r.cap(1);
+
+   QString file = base + ".desktop";
+
+   for(int n = 1; ++n; )
+   {
+      if (!QFile::exists(directory+file))
+         break;
+
+      file = QString("%2-%1.desktop").arg(n).arg(base);
+   }
+   return directory+file;
+}
+
+void KMenu::updateRecentlyUsedApps(KService::Ptr &service)
+{
+    QString strItem(service->desktopEntryPath());
+
+    // don't add an item from root kmenu level
+    if (!strItem.contains('/'))
+    {
+        return;
+    }
+
+    // add it into recent apps list
+    RecentlyLaunchedApps::the().appLaunched(strItem);
+    RecentlyLaunchedApps::the().save();
+    RecentlyLaunchedApps::the().m_bNeedToUpdate = true;
+}
+
+QSize KMenu::sizeHint() const
+{
+#warning FIXME
+    // this should be only for the inner area so layout changes do not break it
+    const int width = kMin(KickerSettings::kMenuWidth(), QApplication::desktop()->screen()->width()-50);
+
+    const int height = kMin(KickerSettings::kMenuHeight(), QApplication::desktop()->screen()->height()-50);
+    QSize wanted(width, height);
+    kdDebug() << "show " << minimumSizeHint() << " " << m_stacker->minimumSizeHint() << " "
+              << m_searchFrame->minimumSizeHint() << " " << wanted << endl;
+    bool isDefault = wanted.isNull();
+    wanted = wanted.expandedTo(minimumSizeHint());
+    if ( isDefault )
+        wanted.setHeight( wanted.height() + ( m_favoriteView->goodHeight() - m_stacker->minimumSizeHint().height() ) );
+
+    return wanted;
+}
+
+QSize KMenu::minimumSizeHint() const
+{
+    QSize minsize;
+    minsize.setWidth( minsize.width() + m_tabBar->sizeHint().width() );
+    minsize.setWidth( QMAX( minsize.width(),
+                            m_search->minimumSize().width() ) );
+    minsize.setWidth( QMAX( minsize.width(),
+                            m_search->minimumSize().width() ) );
+
+    minsize.setHeight( minsize.height() +
+                       m_search->minimumSize().height() +
+                       m_footer->minimumSize().height() +
+                       180 ); // 180 is a very rough guess for 32 icon size
+    return minsize;
+}
+
+void KMenu::slotFavoritesMoved( QListViewItem* item, QListViewItem* /*afterFirst*/, QListViewItem* afterNow)
+{
+    KMenuItem* kitem = dynamic_cast<KMenuItem*>(item);
+    KMenuItem* kafterNow = dynamic_cast<KMenuItem*>(afterNow);
+
+    QStringList favs = KickerSettings::favorites();
+    QStringList::Iterator it;
+    QString addFav = QString::null;
+
+    // remove at old position
+    if (kitem->service())
+    {
+        favs.erase(favs.find(kitem->service()->storageId()));
+        addFav = kitem->service()->storageId();
+    }
+    else
+    {
+        for (it = favs.begin(); it != favs.end(); ++it)
+        {
+            if ((*it)[0]=='/')
+            {
+                KDesktopFile df((*it),true);
+                if (df.readURL().replace("file://",QString::null)==kitem->path())
+                {
+                    addFav = *it;
+                    favs.erase(it);
+                    break;
+                }
+            }
+        }
+    }
+
+    if (addFav.isEmpty())
+      return;
+
+    if (!kafterNow || dynamic_cast<KMenuSpacer*>(afterNow))
+    {
+        favs.prepend(addFav);
+    }
+    else
+    {
+        // add at new position
+        for (it = favs.begin(); it != favs.end(); ++it)
+        {
+            if ((*it)[0]=='/' && !kafterNow->service())
+            {
+                KDesktopFile df((*it),true);
+                if (df.readURL().replace("file://",QString::null)==kafterNow->path())
+                {
+                    kdDebug() << "insert after " << kafterNow->path() << endl;
+                    favs.insert(++it,addFav);
+                    break;
+                }
+            }
+            else if (kafterNow->service() && *it==kafterNow->service()->storageId())
+            {
+                kdDebug() << "insert after service " << kafterNow->service() << endl;
+                favs.insert(++it,addFav);
+                break;
+            }
+        }
+    }
+    kdDebug() << "favs " << favs << endl;
+
+    KickerSettings::setFavorites(favs);
+    KickerSettings::writeConfig();
+
+    m_favoriteView->slotMoveContent();
+}
+
+void KMenu::updateMedia()
+{
+    QStringList devices = m_mediaWatcher->devices();
+    if ( devices.isEmpty() )
+        return;
+
+    int nId = serviceMenuStartId();
+    if ( m_media_id ) {
+        for ( int i = m_media_id + 1 ;; ++i )
+        {
+            KMenuItem *item = m_systemView->findItem( i );
+            if ( !item )
+                break;
+            if ( !item->path().startsWith( "system:/" ) )
+                break;
+            media_mimetypes.remove(item->path());
+            delete item;
+        }
+        nId = m_media_id + 1;
+    } else {
+        m_media_id = nId;
+        m_systemView->insertSeparator( nId++, i18n("Media"), -1);
+    }
+
+    for ( QStringList::ConstIterator it = devices.constBegin(); it != devices.constEnd(); ++it )
+    {
+        QString id = ( *it );
+        QString name = *++it;
+        QString label = *++it;
+        QString userLabel = ( *++it );
+        bool mountable = ( *++it == "true" ); // bool
+        ( void )mountable;
+        QString deviceNode = ( *++it );
+        QString mountPoint = ( *++it );
+        QString fsType = ( *++it );
+        bool mounted = ( *++it == "true" ); // bool
+        QString baseURL = ( *++it );
+        QString mimeType = ( *++it );
+        QString iconName = ( *++it );
+
+        media_mimetypes["system:/media/"+name] = mimeType;
+
+        if ( iconName.isEmpty() ) // no user icon, query the MIME type
+        {
+            KMimeType::Ptr mime = KMimeType::mimeType( mimeType );
+            iconName = mime->icon( QString::null, false );
+        }
+
+        QString descr = deviceNode;
+        if ( mounted )
+        {
+            descr = mountPoint;
+            // calc the free/total space
+            struct statfs sfs;
+            if ( statfs( QFile::encodeName( mountPoint ), &sfs ) == 0 )
+            {
+                uint64_t total = ( uint64_t )sfs.f_blocks * sfs.f_bsize;
+                uint64_t avail = ( uint64_t )( getuid() ? sfs.f_bavail : sfs.f_bfree ) * sfs.f_bsize;
+                if ( avail < total && avail > 1024 ) {
+                    label += " " + i18n( "(%1 available)" ).arg( KIO::convertSize(avail) );
+                }
+            }
+        }
+        m_systemView->insertItem( iconName, userLabel.isEmpty() ? label : userLabel,
+                                  descr, "system:/media/" + name, nId++, -1 );
+
+        ++it; // skip separator
+    }
+}
+
+bool KMenu::ensureServiceRunning(const QString & service)
+{
+    QStringList URLs;
+    QByteArray data, replyData;
+    QCString replyType;
+    QDataStream arg(data, IO_WriteOnly);
+    arg << service << URLs;
+
+    if ( !kapp->dcopClient()->call( "klauncher", "klauncher", "start_service_by_desktop_name(QString,QStringList)",
+                      data, replyType, replyData) ) {
+        qWarning( "call to klauncher failed.");
+        return false;
+    }
+    QDataStream reply(replyData, IO_ReadOnly);
+
+    if ( replyType != "serviceResult" )
+    {
+        qWarning( "unexpected result '%s' from klauncher.", replyType.data());
+        return false;
+    }
+    int result;
+    QCString dcopName;
+    QString error;
+    reply >> result >> dcopName >> error;
+    if (result != 0)
+    {
+        qWarning("Error starting: %s", error.local8Bit().data());
+        return false;
+    }
+    return true;
+}
+
+void KMenu::slotFavDropped(QDropEvent * ev, QListViewItem *after )
+{
+    QStringList favs = KickerSettings::favorites();
+    KMenuItem *newItem = 0;
+
+    if (KMenuItemDrag::canDecode(ev))
+    {
+        KMenuItemInfo item;
+        KMenuItemDrag::decode(ev,item);
+
+        if (item.m_s)
+        {
+            if (favs.find(item.m_s->storageId())==favs.end())
+            {
+                newItem = m_favoriteView->insertMenuItem(item.m_s, serviceMenuEndId()+favs.count()+1);
+                favs += item.m_s->storageId();
+            }
+        }
+        else
+        {
+            QString uri = item.m_path;
+            if (uri.startsWith(locateLocal("data", QString::fromLatin1("RecentDocuments/")))) {
+               KDesktopFile df(uri,true);
+               uri=df.readURL();
+            }
+
+            QStringList::Iterator it;
+            for (it = favs.begin(); it != favs.end(); ++it)
+            {
+                if ((*it)[0]=='/')
+                {
+                    KDesktopFile df((*it),true);
+                    if (df.readURL().replace("file://",QString::null)==uri)
+                        break;
+                }
+            }
+            if (it==favs.end())
+            {
+                QString file = KickerLib::newDesktopFile(uri);
+                KDesktopFile df(file);
+                df.writeEntry("Encoding", "UTF-8");
+                df.writeEntry("Type","Link");
+                df.writeEntry("Name", item.m_title);
+                df.writeEntry("GenericName", item.m_description);
+                df.writeEntry("Icon", item.m_icon);
+                df.writeEntry("URL", uri);
+
+                newItem = m_favoriteView->insertItem(item.m_icon, item.m_title, item.m_description,
+                                                     uri, serviceMenuEndId()+favs.count()+1, -1);
+                favs += file;
+            }
+        }
+    }
+    else if (QTextDrag::canDecode(ev))
+    {
+        QString text;
+        QTextDrag::decode(ev,text);
+
+        if (text.endsWith(".desktop"))
+        {
+            KService::Ptr p = KService::serviceByDesktopPath(text.replace("file://",QString::null));
+            if (p && favs.find(p->storageId())==favs.end()) {
+                newItem = m_favoriteView->insertMenuItem(p, serviceMenuEndId()+favs.count()+1);
+                favs+=p->storageId();
+            }
+        }
+        else
+        {
+            QStringList::Iterator it;
+            for (it = favs.begin(); it != favs.end(); ++it)
+            {
+                if ((*it)[0]=='/')
+                {
+                    KDesktopFile df((*it),true);
+                    if (df.readURL().replace("file://",QString::null)==text)
+                        break;
+                }
+            }
+            if (it==favs.end())
+            {
+                KFileItem* item = new KFileItem(text, QString::null, KFileItem::Unknown);
+                KURL kurl(text);
+
+                QString file = KickerLib::newDesktopFile(text);
+                KDesktopFile df(file);
+                df.writeEntry("Encoding", "UTF-8");
+                df.writeEntry("Type","Link");
+                df.writeEntry("Name", item->name());
+                df.writeEntry("GenericName", i18n("Directory: %1").arg(kurl.upURL().path()));
+                df.writeEntry("Icon", item->iconName());
+                df.writeEntry("URL", text);
+
+                newItem = m_favoriteView->insertItem(item->iconName(), item->name(), i18n("Directory: %1").arg(kurl.upURL().path()), text, serviceMenuEndId()+favs.count()+1, -1);
+                favs += file;
+            }
+        }
+    }
+
+    if ( newItem ) {
+        if (!after && m_favoriteView->childCount()>0) {
+            newItem->moveItem( m_favoriteView->firstChild() );
+            m_favoriteView->firstChild()->moveItem( newItem );
+        }
+        else
+            newItem->moveItem( after );
+        KickerSettings::setFavorites(favs);
+        slotFavoritesMoved( newItem, 0, after );
+    }
+    m_stacker->raiseWidget(m_favoriteView);
+}
+
+void KMenu::resetOverflowCategory()
+{
+   if (m_overflowCategoryState==NotNeeded)
+      m_overflowList.setAutoDelete( true );
+
+   m_overflowList.clear();
+   m_overflowList.setAutoDelete( false );
+   m_overflowCategoryState = None;
+   m_overflowCategory = num_categories;
+}
+
+void KMenu::fillOverflowCategory()
+{
+   if (m_overflowCategoryState==Filling) {
+      initCategoryTitlesUpdate();
+      for (HitMenuItem * item = m_overflowList.first(); item; item = m_overflowList.next() ) {
+	  max_category_id [item->category]++;
+          item->id=max_category_id [item->category];
+
+          KMenuItem *hit_item = m_searchResultsWidget->insertItem(iconForHitMenuItem(item), item->display_name, item->display_info, item->uri.url(), max_category_id [item->category], getHitMenuItemPosition (item));
+          hit_item->setService(item->service);
+      }
+      updateCategoryTitles();
+  }
+}
+
+int KMenu::max_items(int category) const
+{
+    if (category==ACTIONS)
+      return 10;
+
+    return 5;
+}
+
+#define DBUS_HAL_INTERFACE             "org.freedesktop.Hal"
+#define DBUS_HAL_SYSTEM_POWER_INTERFACE        "org.freedesktop.Hal.Device.SystemPowerManagement"
+#define HAL_UDI_COMPUTER               "/org/freedesktop/Hal/devices/computer"
+
+#ifdef KDELIBS_SUSE
+#include <liblazy.h>
+#endif
+
+void KMenu::insertSuspendOption( int &nId, int &index )
+{
+#ifdef KDELIBS_SUSE
+    int supported = -1;
+    bool suspend_ram, suspend_disk, standby;
+
+    liblazy_hal_get_property_bool(HAL_UDI_COMPUTER, "power_management.can_suspend", &supported);
+    if (supported == 1)
+        suspend_ram = true;
+    else
+        suspend_ram = false;
+	liblazy_hal_get_property_bool(HAL_UDI_COMPUTER, "power_management.can_standby", &supported);
+	if (supported == 1)
+	     standby = true;
+	else
+	     standby = false;
+	liblazy_hal_get_property_bool(HAL_UDI_COMPUTER, "power_management.can_hibernate", &supported);
+	if (supported == 1)
+	     suspend_disk = true;
+	else
+	     suspend_disk = false;
+
+	if (liblazy_hal_is_caller_privileged("hal-power-hibernate") != 1)
+	     suspend_disk = false;
+	if (liblazy_hal_is_caller_privileged("hal-power-suspend") != 1)
+	     suspend_ram = false;
+	if (liblazy_hal_is_caller_privileged("hal-power-standby") != 1)
+	    standby = false;
+
+	if ( ! ( standby + suspend_ram + suspend_disk ) )
+            return;
+
+        i18n("Suspend Computer");
+
+        if ( suspend_disk )
+            m_exitView->leftView()->insertItem( "suspend2disk", i18n( "Suspend to Disk" ),
+                                                i18n( "Pause without logging out" ), "kicker:/suspend_disk", nId++, index++ );
+
+        if ( suspend_ram )
+            m_exitView->leftView()->insertItem( "suspend2ram", i18n( "Suspend to RAM" ),
+                                                i18n( "Pause without logging out" ), "kicker:/suspend_ram", nId++, index++ );
+
+        if ( standby )
+            m_exitView->leftView()->insertItem( "player_pause", i18n( "Standby" ),
+                                                i18n( "Pause without logging out" ), "kicker:/standby", nId++, index++ );
+#endif
+}
+
+void KMenu::slotSuspend(int id)
+{
+#ifdef KDELIBS_SUSE
+    int error = 0;
+    int wake = 0;
+    DBusMessage *reply = 0;
+
+    if (id == 1) {
+        error = liblazy_dbus_system_send_method_call(DBUS_HAL_INTERFACE,
+                                                     HAL_UDI_COMPUTER,
+                                                     DBUS_HAL_SYSTEM_POWER_INTERFACE,
+                                                     "Hibernate",
+                                                     &reply,
+                                                     DBUS_TYPE_INVALID);
+    } else if (id == 2)
+        error = liblazy_dbus_system_send_method_call(DBUS_HAL_INTERFACE,
+                                                     HAL_UDI_COMPUTER,
+                                                     DBUS_HAL_SYSTEM_POWER_INTERFACE,
+                                                     "Suspend",
+                                                     &reply,
+                                                     DBUS_TYPE_INT32,
+                                                     &wake,
+                                                     DBUS_TYPE_INVALID);
+    else if (id == 3)
+        error = liblazy_dbus_system_send_method_call(DBUS_HAL_INTERFACE,
+                                                     HAL_UDI_COMPUTER,
+                                                     DBUS_HAL_SYSTEM_POWER_INTERFACE,
+                                                     "Standby",
+                                                     &reply,
+                                                     DBUS_TYPE_INVALID);
+    else
+        return;
+    if (error)
+#endif
+        KMessageBox::error(this, i18n("Suspend failed"));
+
+}
+
+// vim:cindent:sw=4:
diff -Nurp kicker.orig/kicker/ui/k_new_mnu.h kicker/kicker/ui/k_new_mnu.h
--- kicker.orig/kicker/ui/k_new_mnu.h	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/ui/k_new_mnu.h	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,342 @@
+/*****************************************************************
+
+   Copyright (c) 1996-2000 the kicker authors. See file AUTHORS.
+   Copyright (c) 2006 Debajyoti Bera <dbera.web@gmail.com>
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+
+******************************************************************/
+
+#ifndef __k_new_mnu_h__
+#define __k_new_mnu_h__
+
+#include <dcopobject.h>
+#include <qintdict.h>
+#include <qpixmap.h>
+#include <qframe.h>
+#include <qtoolbutton.h>
+#include <qscrollview.h>
+#include <qtimer.h>
+#include <qbitmap.h>
+#include <qvbox.h>
+#include <qregexp.h>
+
+#include <kabc/addressbook.h>
+#include <kabc/stdaddressbook.h>
+#include "../interfaces/kickoff-search-plugin.h"
+
+#include "kmenubase.h"
+#include "service_mnu.h"
+#include "query.h"
+
+class KickerClientMenu;
+class KickoffTabBar;
+class KBookmarkMenu;
+class KActionCollection;
+class KBookmarkOwner;
+class Panel;
+class QWidgetStack;
+class KHistoryCombo;
+class QScrollView;
+class PopupMenuTitle;
+class MediaWatcher;
+class KURIFilterData;
+class KBookmarkGroup;
+class KBookmarkManager;
+class ItemView;
+class FlipScrollView;
+class QListViewItem;
+class KMenuItem;
+class QListView;
+class QTabBar;
+class QTab;
+
+static QString categories[14] = {I18N_NOOP("Actions"), I18N_NOOP("Applications"), I18N_NOOP("Bookmarks"),
+                                 I18N_NOOP("Notes"), I18N_NOOP("Emails"),  I18N_NOOP("Files"), I18N_NOOP("Music"),
+                                 I18N_NOOP("Browsing History"), I18N_NOOP("Chat Logs"), I18N_NOOP("Feeds"),
+                                 I18N_NOOP("Pictures"), I18N_NOOP("Videos"), I18N_NOOP("Documentation"),
+                                 I18N_NOOP("Others")};
+
+static QString kerry_categories[14] = {"contacts", "applications", "webpages", "everything", "conversations",
+                                       "everything", "media", "webpages", "conversations", "webpages", "images",
+                                       "media", "everything", "everything"};
+
+enum MenuOrientation { BottomUp, TopDown, UnDetermined };
+enum OverflowCategoryState { None, Filling, NotNeeded };
+
+class KMenu : public KMenuBase
+{
+    Q_OBJECT
+    Q_PROPERTY (bool KStyleMenuDropShadow READ useKStyleMenuDropShadow )
+
+public:
+    KMenu();
+    ~KMenu();
+
+    int insertClientMenu(KickerClientMenu *p);
+    void removeClientMenu(int id);
+
+    bool useKStyleMenuDropShadow() const { return true; }
+
+    virtual void showMenu();
+    virtual bool eventFilter(QObject*, QEvent*);
+
+    void clearRecentAppsItems();
+    void clearRecentDocsItems();
+    bool highlightMenuItem(const QString& /*id*/) { return false;}
+
+    void selectFirstItem() {}
+    void popup(const QPoint&, int indexAtPoint);
+
+    enum MaskEffect { Plain, Dissolve };
+
+    virtual QSize sizeHint() const;
+    virtual QSize minimumSizeHint() const;
+
+    void searchOver();
+    void initCategoryTitlesUpdate();
+    bool anotherHitMenuItemAllowed(int cat, bool count=true);
+    void addHitMenuItem(HitMenuItem*);
+    void insertSearchResult(HitMenuItem* item);
+
+    void updateCategoryTitles();
+
+signals:
+    void aboutToHide();
+    void aboutToShow();
+
+public slots:
+    virtual void initialize();
+
+    virtual void hide();
+    virtual void show();
+
+    void stackWidgetRaised(QWidget*);
+
+protected slots:
+    void slotLock();
+    void slotOpenHomepage();
+    void slotLogout();
+    void slotPopulateSessions();
+    void slotSessionActivated( int );
+    void slotGoSubMenu(const QString& relPath);
+    void slotGoBack();
+    void slotGoExitMainMenu();
+    void slotGoExitSubMenu(const QString& url);
+    void tabClicked(QTab*);
+
+    void paletteChanged();
+    virtual void configChanged();
+    void updateRecent();
+
+    void initSearch();
+    void searchAccept();
+    void searchChanged(const QString &);
+    // when timeout happens or doQueryNow calls
+    void doQuery (bool return_pressed = false);
+    void searchActionClicked(QListViewItem*);
+
+    void slotStartService(KService::Ptr);
+    void slotStartURL(const QString&);
+    void slotContextMenuRequested( QListViewItem * item, const QPoint & pos, int col );
+
+    void clearedHistory();
+
+    void slotSloppyTimeout();
+
+    void slotContextMenu(int);
+    void slotFavoritesMoved( QListViewItem*, QListViewItem*, QListViewItem* );
+
+    void updateMedia();
+    void slotFavDropped(QDropEvent * e, QListViewItem *after );
+    void slotSuspend(int id);
+
+protected:
+    virtual void paintEvent(QPaintEvent *);
+    virtual void resizeEvent ( QResizeEvent * );
+    virtual void mousePressEvent ( QMouseEvent * e );
+    virtual void mouseReleaseEvent ( QMouseEvent * e );
+    virtual void mouseMoveEvent ( QMouseEvent * e );
+
+    void doNewSession(bool lock);
+    void createRecentMenuItems();
+    void insertStaticItems();
+    void insertStaticExitItems();
+    void insertSuspendOption( int &id, int &index );
+    virtual void clearSubmenus();
+//    void raiseStackWidget(QWidget *view);
+
+    bool runCommand();
+
+    void setupUi();
+
+    void saveConfig();
+    void searchProgramList(QString relPath);
+    void searchBookmarks(KBookmarkGroup);
+    void searchAddressbook();
+
+    void createNewProgramList();
+    void createNewProgramList(QString relPath);
+
+    void paintSearchTab( bool active );
+
+    void goSubMenu(const QString& relPath, bool keyboard = false);
+    void setOrientation(MenuOrientation orientation);
+
+private:
+    int serviceMenuStartId() { return 5242; }
+    int serviceMenuEndId() { return 5242; }
+
+    void fillMenu( KServiceGroup::Ptr &_root, KServiceGroup::List &_list,
+		   const QString &_relPath, ItemView* view, int & id );
+
+    void fillSubMenu(const QString& relPath, ItemView *view);
+
+    QPopupMenu                 *sessionsMenu;
+    int                         client_id;
+    bool                        delay_init;
+    QIntDict<KickerClientMenu>  clients;
+    KActionCollection          *actionCollection;
+    PopupMenuList               dynamicSubMenus;
+
+    QTimer                       m_sloppyTimer;
+    QTimer                       m_mediaFreeTimer;
+    MediaWatcher               * m_mediaWatcher;
+    QRegion                      m_sloppyRegion;
+    QRect                        m_sloppySource;
+    bool                         m_sloppySourceClicked;
+    QWidget                    * m_sloppyWidget;
+    ItemView                   * m_recentlyView;
+    ItemView                   * m_favoriteView;
+    ItemView                   * m_searchResultsWidget;
+    QListView                  * m_searchActions;
+    FlipScrollView             * m_browserView;
+    ItemView                   * m_systemView;
+    FlipScrollView             * m_exitView;
+    QVBox                      * m_searchWidget;
+    QLabel                     * m_resizeHandle;
+
+    bool                       m_isresizing;
+    // timer for search without pressing enter feature
+    QTimer *input_timer, *init_search_timer;
+
+    Query current_query;
+
+    bool dontQueryNow(const QString &);
+
+    // start timeout timer to call doQuery is enough time has passed since last keypress
+    void checkToDoQuery (const QString &);
+    // when return is pressed
+    void doQueryNow ();
+    void clearSearchResults(bool showHelp = true);
+
+    int *max_category_id; // maximum id in this category: max_category_id - base_category_id gives the current number of hits displayed in this category
+    int *categorised_hit_total; // current number of hits returned in each category
+
+    bool ensureServiceRunning(const QString & service);
+
+    QString iconForHitMenuItem(HitMenuItem *hit_item);
+
+    int getHitMenuItemPosition (HitMenuItem *hit_item);
+    QMap<QString, QString> mimetype_iconstore;
+    QMap<QString, QString> media_mimetypes;
+    // report error as a menu item
+    void reportError (QString err);
+    void addToHistory();
+
+    int max_items(int category) const;
+    QString TOP_CATEGORY_STRING;
+    bool *already_added;
+
+    void notifyServiceStarted(KService::Ptr service);
+    void parseLine( bool final );
+    QString m_iconName;
+    QStringList m_middleFilters;
+    QStringList m_finalFilters;
+    KURIFilterData* m_filterData;
+    QPtrList<HitMenuItem> m_current_menu_items;
+    QListViewItem *m_searchIndex, *m_searchInternet;
+
+    bool checkUriInMenu(const KURL &uri);
+
+    QRegExp emailRegExp,uriRegExp,uri2RegExp,authRegExp;
+
+    KBookmarkManager *bookmarkManager;
+    KABC::AddressBook* m_addressBook;
+
+    enum ContextMenuEntry { AddItemToPanel, EditItem, AddMenuToPanel, EditMenu,
+                            AddItemToDesktop, AddMenuToDesktop, PutIntoRunDialog,
+                            AddToFavorites, RemoveFromFavorites, ClearRecentlyUsedApps, 
+                            ClearRecentlyUsedDocs };
+    struct PopupPath
+    {
+        QString title, description, icon, path, menuPath; 
+    };
+
+    enum KickoffTabEntry { FavoriteTab, ApplicationsTab, ComputerTab,
+        HistoryTab, LeaveTab, SearchTab, NumTabs };
+
+    KPopupMenu* m_popupMenu;
+    KService* m_popupService;
+    PopupPath m_popupPath;
+
+    KickoffTabBar* m_tabBar;
+    QTab* m_tabs[NumTabs];
+
+    QString newDesktopFile(const KURL& url, const QString &directory);
+    void updateRecentlyUsedApps(KService::Ptr &service);
+
+    QPixmap main_border_lc;
+    QPixmap main_border_rc;
+    QPixmap main_border_tl;
+    QPixmap main_border_tr;
+    QPixmap button_box_left;
+
+    QPixmap search_tab_left;
+    QPixmap search_tab_right;
+    QPixmap search_tab_center;
+
+    QPixmap search_tab_top_left;
+    QPixmap search_tab_top_right;
+    QPixmap search_tab_top_center;
+
+    QWidgetStack *m_stacker;
+
+    QStringList m_programsInMenu;
+    QStringList m_newInstalledPrograms, m_seenPrograms;
+    bool m_seenProgramsChanged;
+    QString m_currentDate;
+
+    MenuOrientation m_orientation;
+    bool m_toolTipsEnabled;
+    int m_media_id;
+
+    bool m_recentDirty, m_browserDirty, m_kerryInstalled, m_isShowing;
+
+    KickoffSearch::Plugin* m_search_plugin;
+    QObject* m_search_plugin_interface;
+
+    OverflowCategoryState m_overflowCategoryState;
+    QPtrList<HitMenuItem> m_overflowList;
+    int m_overflowCategory;
+
+    void resetOverflowCategory();
+    void fillOverflowCategory();
+
+    QString insertBreaks(const QString& text, QFontMetrics fm, int width, QString leadInsert = QString::null);
+};
+
+#endif
diff -Nurp kicker.orig/kicker/ui/Makefile.am kicker/kicker/ui/Makefile.am
--- kicker.orig/kicker/ui/Makefile.am	2005-09-10 08:25:31.000000000 +0000
+++ kicker/kicker/ui/Makefile.am	2008-09-17 15:14:41.000000000 +0000
@@ -1,38 +1,46 @@
 INCLUDES = -I$(srcdir)/../core -I../core -I$(srcdir)/../buttons \
 	-I../../libkicker -I$(srcdir)/../../libkicker \
-	-I$(top_srcdir)/libkonq -I$(top_srcdir)/kdmlib $(all_includes)
+	-I$(top_srcdir)/libkonq -I$(top_srcdir)/kdmlib $(DBUS_INCS) $(all_includes)
 
 noinst_LTLIBRARIES = libkicker_ui.la
 
+libkicker_ui_la_COMPILE_FIRST = kmenubase.h
+
 libkicker_ui_la_SOURCES = addbutton_mnu.cpp appletitem.ui appletview.ui addapplet.cpp \
         addapplet_mnu.cpp appletop_mnu.cpp \
         browser_mnu.cpp client_mnu.cpp dirdrop_mnu.cpp \
-        nonKDEButtonSettings.ui exe_dlg.cpp k_mnu.cpp k_mnu.skel\
-        quickbrowser_mnu.cpp service_mnu.cpp \
-        addextension_mnu.cpp extensionop_mnu.cpp \
-        recentapps.cpp browser_dlg.cpp \
+        nonKDEButtonSettings.ui exe_dlg.cpp k_new_mnu.cpp k_mnu.cpp k_mnu.skel\
+        quickbrowser_mnu.cpp service_mnu.cpp kmenubase.ui kmenuitembase.ui \
+        addextension_mnu.cpp extensionop_mnu.cpp k_mnu_stub.cpp \
+        recentapps.cpp browser_dlg.cpp itemview.cpp kickoff_bar.cpp \
         removeapplet_mnu.cpp removeextension_mnu.cpp removecontainer_mnu.cpp \
         removebutton_mnu.cpp popupmenutitle.cpp hidebutton.cpp \
-        addappletvisualfeedback.cpp
+        addappletvisualfeedback.cpp flipscrollview.cpp \
+	media_watcher.cpp media_watcher.skel mykickoffsearchinterface.cpp query.cpp
 
-libkicker_ui_la_LIBADD = $(top_builddir)/libkonq/libkonq.la $(top_builddir)/kdmlib/libdmctl.la
+libkicker_ui_la_LIBADD = $(top_builddir)/libkonq/libkonq.la $(top_builddir)/kdmlib/libdmctl.la \
+		$(LIB_KABC) ../interfaces/libkickoffsearch_interfaces.la -llazy
 
 libkicker_ui_la_METASOURCES = AUTO
 
 noinst_HEADERS = addapplet.h appletwidget.h addbutton_mnu.h addapplet_mnu.h appletop_mnu.h \
-		browser_mnu.h client_mnu.h dirdrop_mnu.h exe_dlg.h k_mnu.h \
+		browser_mnu.h client_mnu.h dirdrop_mnu.h exe_dlg.h k_new_mnu.h  k_mnu.h \
 		quickbrowser_mnu.h service_mnu.h \
 		addextension_mnu.h extensionop_mnu.h \
-		recentapps.h browser_dlg.h \
+		recentapps.h browser_dlg.h itemview.h query.h \
 		removeapplet_mnu.h removeextension_mnu.h removecontainer_mnu.h \
 		removebutton_mnu.h popupmenutitle.h hidebutton.h addappletvisualfeedback.h
 
+kicker_ui_data_DATA = default-favs
+kicker_ui_datadir = $(kde_datadir)/kicker
+
 removecontainer_mnu.lo: ../../libkicker/kickerSettings.h
 removeextension_mnu.lo: ../../libkicker/kickerSettings.h
 addextension_mnu.lo: ../core/extensionSettings.h
 appletop_mnu.lo: ../../libkicker/kickerSettings.h
 extensionop_mnu.lo: ../../libkicker/kickerSettings.h
 k_mnu.lo: ../../libkicker/kickerSettings.h
+k_new_mnu.lo: ../../libkicker/kickerSettings.h
 removecontainer_mnu.lo: ../core/extensionSettings.h
 removeextension_mnu.lo: ../core/extensionSettings.h
 service_mnu.lo: ../../libkicker/kickerSettings.h
diff -Nurp kicker.orig/kicker/ui/media_watcher.cpp kicker/kicker/ui/media_watcher.cpp
--- kicker.orig/kicker/ui/media_watcher.cpp	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/ui/media_watcher.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,57 @@
+/*****************************************************************
+
+Copyright (c) 2006 Stephan Kulow <coolo@novell.com>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#include "media_watcher.h"
+#include <kapplication.h>
+#include <kdebug.h>
+#include <dcopclient.h>
+#include <dcopref.h>
+
+MediaWatcher::MediaWatcher( QObject *parent ) :
+    QObject( parent ), DCOPObject("mediawatcher")
+{
+    connectDCOPSignal( "kded", "mediamanager", "mediumAdded(QString,bool)",
+                       "slotMediumAdded(QString,bool)", true );
+    connectDCOPSignal( "kded", "mediamanager", "mediumRemoved(QString,bool)",
+                       "slotMediumAdded(QString,bool)", true );
+    connectDCOPSignal( "kded", "mediamanager", "mediumChanged(QString,bool)",
+                       "slotMediumAdded(QString,bool)", true );
+
+    updateDevices();
+}
+
+void MediaWatcher::updateDevices()
+{
+    DCOPRef nsd( "kded", "mediamanager" );
+    nsd.setDCOPClient( kapp->dcopClient() );
+    m_devices = nsd.call( "fullList" );
+}
+
+void MediaWatcher::slotMediumAdded( QString item, bool a )
+{
+    updateDevices();
+
+    emit mediumChanged();
+}
+
+#include "media_watcher.moc"
diff -Nurp kicker.orig/kicker/ui/media_watcher.h kicker/kicker/ui/media_watcher.h
--- kicker.orig/kicker/ui/media_watcher.h	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/ui/media_watcher.h	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,51 @@
+/*****************************************************************
+
+Copyright (c) 2006 Stephan Kulow <coolo@novell.com>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#ifndef _media_watcher_
+#define _media_watcher_
+
+#include <dcopobject.h>
+#include <qobject.h>
+#include <qstringlist.h>
+
+class MediaWatcher : public QObject, public DCOPObject
+{
+    Q_OBJECT
+    K_DCOP
+
+    QStringList m_devices;
+    void updateDevices();
+
+k_dcop:
+    void slotMediumAdded(QString medium, bool a);
+
+signals:
+    void mediumChanged();
+
+public:
+    MediaWatcher(QObject *parent);
+
+    QStringList devices() const { return m_devices; }
+};
+
+#endif
diff -Nurp kicker.orig/kicker/ui/mykickoffsearchinterface.cpp kicker/kicker/ui/mykickoffsearchinterface.cpp
--- kicker.orig/kicker/ui/mykickoffsearchinterface.cpp	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/ui/mykickoffsearchinterface.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,54 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Stephan Binner <binner@kde.org>                 *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
+ ***************************************************************************/
+
+#include "mykickoffsearchinterface.h"
+#include "../ui/k_new_mnu.h"
+
+MyKickoffSearchInterface::MyKickoffSearchInterface( KMenu* menu, QObject* parent, const char* name  )
+    : KickoffSearchInterface( parent, name ), _menu( menu )
+{
+}
+
+bool MyKickoffSearchInterface::anotherHitMenuItemAllowed(int cat)
+{
+   return _menu->anotherHitMenuItemAllowed(cat);
+}
+
+void MyKickoffSearchInterface::addHitMenuItem(HitMenuItem* item)
+{
+   _menu->addHitMenuItem(item);
+}
+
+
+void MyKickoffSearchInterface::searchOver()
+{
+   _menu->searchOver();
+}
+
+void MyKickoffSearchInterface::initCategoryTitlesUpdate()
+{
+   _menu->initCategoryTitlesUpdate();
+}
+
+void MyKickoffSearchInterface::updateCategoryTitles()
+{
+   _menu->updateCategoryTitles();
+}
+
+#include "mykickoffsearchinterface.moc"
diff -Nurp kicker.orig/kicker/ui/mykickoffsearchinterface.h kicker/kicker/ui/mykickoffsearchinterface.h
--- kicker.orig/kicker/ui/mykickoffsearchinterface.h	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/ui/mykickoffsearchinterface.h	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,47 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Stephan Binner <binner@kde.org>                 *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
+ ***************************************************************************/
+
+#ifndef MYKICKOFFSEARCHINTERFACE_H
+#define MYKICKOFFSEARCHINTERFACE_H
+
+#include "../interfaces/kickoffsearchinterface.h"
+
+class KMenu;
+
+using namespace KickoffSearch;
+
+class MyKickoffSearchInterface :public KickoffSearchInterface
+{
+    Q_OBJECT
+
+public:
+    MyKickoffSearchInterface( KMenu*, QObject* parent, const char* name = 0 );
+
+    bool anotherHitMenuItemAllowed(int cat);
+    void addHitMenuItem(HitMenuItem* item);
+    void searchOver();
+    void initCategoryTitlesUpdate();
+    void updateCategoryTitles();
+
+private:
+    KMenu* _menu;
+
+};
+
+#endif /* MYKICKOFFSEARCHINTERFACE_H */
diff -Nurp kicker.orig/kicker/ui/query.cpp kicker/kicker/ui/query.cpp
--- kicker.orig/kicker/ui/query.cpp	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/ui/query.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,136 @@
+/*****************************************************************
+
+   Copyright (c) 2006 Stephan Binner <binner@kde.org>
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+
+******************************************************************/
+
+#include "query.h"
+#include <kdebug.h>
+
+Query::Query()
+{
+   alternatives.setAutoDelete(true);
+}
+
+void Query::clear()
+{
+   query_term = QString::null;
+   alternatives.clear();
+}
+
+void Query::set(const QString &term)
+{
+   query_term = term;
+   alternatives.clear();
+
+   current_alternative = new Alternative;
+   current_part = QString::null;
+   within_quotes = false;
+   exclude_part = false;
+
+   for (uint index=0;index<term.length();index++) {
+      if (current_part.isEmpty() && query_term[index]=='-')
+         exclude_part = true;
+      else if (term[index]=='\'' || term[index]=='"') {
+         if (within_quotes)
+            add_term();
+         else
+            within_quotes = true;
+      }
+      else if (!within_quotes && query_term[index]==' ')
+         add_term();
+      else if (!exclude_part && !within_quotes && query_term[index]=='O' && index+1<term.length() && query_term[index+1]=='R') {
+         index++;
+         alternatives.append(current_alternative);
+         current_alternative = new Alternative;
+         within_quotes = false;
+         exclude_part = false;
+         current_part = QString::null;
+     }
+     else
+        current_part+=term[index];
+   }
+   add_term();
+   alternatives.append(current_alternative);
+
+#if 0
+   for (Alternative* alt=alternatives.first(); alt; alt=alternatives.next()) {
+      kdDebug() << "---" << endl;
+      kdDebug() << "*** includes = " << alt->includes << endl;
+      kdDebug() << "*** excludes = " << alt->excludes << endl;
+   }
+#endif
+}
+
+void Query::add_term() {
+   if (!current_part.isEmpty()) {
+      if (current_part.startsWith("*"))
+         current_part=current_part.mid(1);
+
+      if (current_part.endsWith("*"))
+         current_part=current_part.mid(0,current_part.length()-1);
+
+      if (exclude_part)
+         current_alternative->excludes+=current_part.lower();
+      else
+         current_alternative->includes+=current_part.lower();
+   }
+   within_quotes = false;
+   exclude_part = false;
+   current_part = QString::null;
+}
+
+QString Query::get() const
+{
+   return query_term;
+}
+
+bool Query::matches(const QString &term)
+{
+   QString lower_term = term.lower();
+
+   for (Alternative* alt=alternatives.first(); alt; alt=alternatives.next()) {
+      if (!alt->includes.count())
+         continue;
+
+      bool next_alternative = false;
+
+      for ( QStringList::ConstIterator it = alt->excludes.begin(); it != alt->excludes.end(); ++it ) {
+         if ( lower_term.find(*it)!=-1 ) {
+            next_alternative = true;
+            continue;
+         }
+      }
+      if (next_alternative)
+         continue;
+
+      for ( QStringList::ConstIterator it = alt->includes.begin(); it != alt->includes.end(); ++it ) {
+         if ( lower_term.find(*it)==-1 ) {
+            next_alternative = true;
+            continue;
+         }
+      }
+      if (next_alternative)
+         continue;
+
+//kdDebug() << "Found hit in '" << term << "'" << endl;
+      return true;
+   }
+
+   return false;
+}
diff -Nurp kicker.orig/kicker/ui/query.h kicker/kicker/ui/query.h
--- kicker.orig/kicker/ui/query.h	1970-01-01 00:00:00.000000000 +0000
+++ kicker/kicker/ui/query.h	2008-09-17 15:14:41.000000000 +0000
@@ -0,0 +1,55 @@
+/*****************************************************************
+
+   Copyright (c) 2006 Stephan Binner <binner@kde.org>
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+
+******************************************************************/
+
+#ifndef QUERY_H
+#define QUERY_H
+
+#include <qstringlist.h>
+#include <qptrlist.h>
+
+class Alternative
+{
+public:
+    QStringList includes;
+    QStringList excludes;
+};
+
+class Query
+{
+  public:
+    Query();
+    void clear();
+    void set(const QString &);
+    QString get() const;
+    bool matches(const QString &);
+
+  private:
+    QString query_term;
+    QPtrList<Alternative> alternatives;
+
+    void add_term();
+    QString current_part;
+    Alternative *current_alternative;
+    bool within_quotes;
+    bool exclude_part;
+};
+
+#endif
diff -Nurp kicker.orig/libkicker/kickerSettings.kcfg kicker/libkicker/kickerSettings.kcfg
--- kicker.orig/libkicker/kickerSettings.kcfg	2006-10-07 14:23:10.000000000 +0000
+++ kicker/libkicker/kickerSettings.kcfg	2008-09-17 15:14:41.000000000 +0000
@@ -98,6 +98,70 @@
       <label>A list of extensions that have been loaded at runtime. In the case of a crash these extensions will not be loaded at the next Kicker start, in case they caused the crash</label>
    </entry>
 
+<entry name="LegacyKMenu" type="Bool" >
+      <label>When this option is enabled, the classic K Menu is used.</label>
+      <default>false</default>
+   </entry>
+
+<entry name="OpenOnHover" type="Bool" >
+      <label>When this option is enabled, the SUSE Menu does open on mouse hover.</label>
+      <default>true</default>
+   </entry>
+
+<entry name="ScrollFlipView" type="Bool" >
+      <label>When this option is enabled, the SUSE Menu application view switching will scroll.</label>
+      <default>true</default>
+   </entry>
+
+<entry name="KMenuWidth" type="Int">
+      <label>Preferred width of the KMenu</label>
+      <default>0</default>
+    </entry>
+
+<entry name="KMenuHeight" type="Int">
+      <label>Preferred width of the KMenu</label>
+      <default>0</default>
+    </entry>
+
+<entry name="KickoffFontPointSizeOffset" type="Int" >
+      <label>With this option the scale of the fonts Kickoff uses can be influenced</label>
+      <default>0</default>
+      <min>-100</min>
+      <max>100</max>
+   </entry>
+
+<entry name="KickoffSearchAddressBook" type="Bool" >
+      <label>When this option is enabled, kabc is utilized to search for addresses. This may start KMail.</label>
+      <default>false</default>
+   </entry>
+
+<entry name="KickoffDrawGeekoEye" type="Bool" >
+      <label>When this option is enabled, the Geeko eye moves when the mouse hovers the start menu button</label>
+      <default>false</default>
+   </entry>
+
+<entry name="KickoffTabBarFormat" type="Enum" >
+        <choices>
+            <choice name="LabelAndIcon">
+                <label>Show names and icons on tabs</label>
+            </choice>
+            <choice name="LabelOnly">
+                <label>Show only the names</label>
+            </choice>
+            <choice name="IconOnly">
+                <label>Show only the icons</label>
+            </choice>
+        </choices>
+        <default>LabelAndIcon</default>
+        <label>Appearace of the Kickoff tabbar</label>
+    </entry>
+
+<entry name="KickoffSwitchTabsOnHover" type="Bool" >
+      <label>When this option is enabled, the tabs in the Kickoff menu will switch without the need to click</label>
+      <default>true</default>
+   </entry>
+
+
 </group>
 
 <group name="menus">
@@ -172,6 +236,19 @@
       <default>false</default>
    </entry>
 
+<entry name="Favorites" type="StringList">
+      <label>The menu entries shown in the Favorites tab</label>
+   </entry>
+
+<entry name="FirstRun" type="Bool" >
+      <label>Whether the panel has been started before or not</label>
+      <default>false</default>
+   </entry>
+
+<entry name="FirstSeenApps" type="StringList">
+      <label>When the applications were first seen by Kickoff</label>
+   </entry>
+
 </group>
 
 <group name="button_tiles">
@@ -337,6 +414,29 @@
 
 </group>
 
+  <group name="SearchField"> 
+    <entry key="History" type="PathList">
+      <default></default>
+      <label></label>
+      <whatsthis></whatsthis>
+    </entry>
+    <entry key="HistoryLength" type="Int">
+      <default>50</default>
+      <label></label>
+      <whatsthis></whatsthis>
+    </entry>
+    <entry key="CompletionItems" type="PathList">
+      <default></default>
+      <label></label>
+      <whatsthis></whatsthis>
+    </entry>
+    <entry key="CompletionMode" type="Int">
+      <default>2</default>
+      <label></label>
+      <whatsthis></whatsthis>
+    </entry>
+  </group>
+
 </kcfg>
 
 
diff -Nurp kicker.orig/libkicker/kickertip.cpp kicker/libkicker/kickertip.cpp
--- kicker.orig/libkicker/kickertip.cpp	2007-10-08 09:51:19.000000000 +0000
+++ kicker/libkicker/kickertip.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -38,6 +38,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE 
 
 // putting this #include higher results in compile errors
 #include <netwm.h>
+#include <assert.h>
 
 static const int DEFAULT_FRAMES_PER_SECOND = 30;
 
@@ -71,14 +72,16 @@ KickerTip::KickerTip(QWidget * parent)
       m_dissolveDelta(-1),
       m_direction(KPanelApplet::Up),
       m_dirty(false),
-      m_toolTipsEnabled(KickerSettings::showToolTips()),
-      m_tippingFor(0)
+      m_tippingFor(0),
+      m_timer(0, "KickerTip::m_timer"),
+      m_frameTimer(0, "KickerTip::m_frameTimer")
 {
     setFocusPolicy(NoFocus);
     setBackgroundMode(NoBackground);
     resize(0, 0);
     hide();
     connect(&m_frameTimer, SIGNAL(timeout()), SLOT(internalUpdate()));
+    connect(kapp, SIGNAL(settingsChanged(SettingsCategory)), SLOT(slotSettingsChanged()));
 }
 
 KickerTip::~KickerTip()
@@ -87,6 +90,11 @@ KickerTip::~KickerTip()
     delete m_mimeFactory;
 }
 
+void KickerTip::slotSettingsChanged()
+{
+    QToolTip::setGloballyEnabled(KickerSettings::showToolTips());
+}
+
 void KickerTip::display()
 {
     if (!tippingEnabled())
@@ -192,9 +200,7 @@ void KickerTip::paintEvent(QPaintEvent *
 
 void KickerTip::mousePressEvent(QMouseEvent * /*e*/)
 {
-    QToolTip::setGloballyEnabled(m_toolTipsEnabled);
     m_timer.stop();
-    m_frameTimer.stop();
     hide();
 }
 
@@ -395,8 +401,11 @@ void KickerTip::enableTipping(bool tip)
         m_tippingEnabled--;
     }
 
+    assert(m_tippingEnabled >= -1);
+
     if (m_tippingEnabled < 1 && m_self)
     {
+        m_self->m_timer.stop();
         m_self->hide();
     }
 }
@@ -411,6 +420,8 @@ void KickerTip::hide()
     m_tippingFor = 0;
     m_frameTimer.stop();
     QWidget::hide();
+
+    QToolTip::setGloballyEnabled(KickerSettings::showToolTips());
 }
 
 bool KickerTip::eventFilter(QObject *object, QEvent *event)
@@ -439,7 +450,6 @@ bool KickerTip::eventFilter(QObject *obj
                 !qApp->activePopupWidget() &&
                 !isTippingFor(widget))
             {
-                m_toolTipsEnabled = QToolTip::isGloballyEnabled();
                 QToolTip::setGloballyEnabled(false);
 
                 tipFor(widget);
@@ -461,8 +471,6 @@ bool KickerTip::eventFilter(QObject *obj
             }
             break;
         case QEvent::Leave:
-            QToolTip::setGloballyEnabled(m_toolTipsEnabled);
-
             m_timer.stop();
 
             if (isTippingFor(widget) && isVisible())
@@ -475,9 +483,7 @@ bool KickerTip::eventFilter(QObject *obj
             tipFor(0);
             break;
         case QEvent::MouseButtonPress:
-            QToolTip::setGloballyEnabled(m_toolTipsEnabled);
             m_timer.stop();
-            m_frameTimer.stop();
             hide();
         default:
             break;
diff -Nurp kicker.orig/libkicker/kickertip.h kicker/libkicker/kickertip.h
--- kicker.orig/libkicker/kickertip.h	2007-01-15 11:31:25.000000000 +0000
+++ kicker/libkicker/kickertip.h	2008-09-17 15:14:41.000000000 +0000
@@ -92,6 +92,7 @@ protected slots:
     void tipperDestroyed(QObject* o);
     void internalUpdate();
     void display();
+    void slotSettingsChanged();
 
 private:
     QBitmap m_mask;
@@ -108,7 +109,6 @@ private:
     QTimer m_timer;
     QTimer m_frameTimer;
     bool m_dirty;
-    bool m_toolTipsEnabled;
 
     const QWidget* m_tippingFor;
 
diff -Nurp kicker.orig/libkicker/panelbutton.cpp kicker/libkicker/panelbutton.cpp
--- kicker.orig/libkicker/panelbutton.cpp	2008-08-19 18:16:55.000000000 +0000
+++ kicker/libkicker/panelbutton.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -42,6 +42,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE 
 #include <kipc.h>
 #include <kstandarddirs.h>
 #include <klocale.h>
+#include <kdebug.h>
 
 #include "global.h"
 
@@ -65,6 +66,7 @@ PanelButton::PanelButton( QWidget* paren
       m_hasAcceptedDrag(false),
       m_arrowDirection(KPanelExtension::Bottom),
       m_popupDirection(KPanelApplet::Up),
+      m_iconAlignment(AlignCenter),
       m_orientation(Horizontal),
       m_size((KIcon::StdSizes)-1),
       m_fontPercent(0.40)
@@ -186,6 +188,12 @@ void PanelButton::setPopupDirection(KPan
     setArrowDirection(KickerLib::directionToPopupPosition(d));
 }
 
+void PanelButton::setIconAlignment(AlignmentFlags align)
+{
+    m_iconAlignment = align;
+    update();
+}
+
 void PanelButton::setOrientation(Orientation o)
 {
     m_orientation = o;
@@ -300,7 +308,9 @@ int PanelButton::widthForHeight(int heig
 
 int PanelButton::heightForWidth(int width) const
 {
-    return preferredDimension(width);
+    int rc=preferredDimension(width);
+
+    return rc;
 }
 
 const QPixmap& PanelButton::labelIcon() const
@@ -556,11 +566,16 @@ void PanelButton::drawButtonLabel(QPaint
                                                  icon.height() - 2);
     }
 
+    int y = 0;
+    if (m_iconAlignment & AlignVCenter) 
+        y = (height() - icon.height()) / 2;
+    else if (m_iconAlignment & AlignBottom)
+        y = (height() - icon.height());
+
     if (!m_buttonText.isEmpty() && orientation() == Horizontal)
     {
         int h = height();
         int w = width();
-        int y = (h - icon.height())/2;
         p->save();
         QFont f = font();
 
@@ -629,8 +644,11 @@ void PanelButton::drawButtonLabel(QPaint
     }
     else if (!icon.isNull())
     {
-        int y = (height() - icon.height()) / 2;
-        int x = (width()  - icon.width()) / 2;
+        int x = 0;
+        if (m_iconAlignment & AlignHCenter)
+           x = (width()  - icon.width()) / 2;
+        else if (m_iconAlignment & AlignRight)
+           x = (width() - icon.width());
         p->drawPixmap(x, y, icon);
     }
 
@@ -792,7 +810,19 @@ void PanelButton::loadIcons()
     QString nm = m_iconName;
     KIcon::States defaultState = isEnabled() ? KIcon::DefaultState :
                                                KIcon::DisabledState;
-    m_icon = ldr->loadIcon(nm, KIcon::Panel, m_size, defaultState, 0L, true);
+    if (nm=="kmenu-suse")
+    {
+        QString pth = locate( "data", "kicker/pics/kmenu_basic.mng" );
+        if (!pth.isEmpty())
+        {
+            m_icon = QImage(pth);
+            m_iconh = QPixmap(m_icon);
+            m_iconz = QPixmap(m_icon);
+            return;
+        }
+    }
+    else
+        m_icon = ldr->loadIcon(nm, KIcon::Panel, m_size, defaultState, 0L, true);
 
     if (m_icon.isNull())
     {
@@ -857,7 +887,7 @@ PanelPopupButton::PanelPopupButton(QWidg
     connect(this, SIGNAL(pressed()), SLOT(slotExecMenu()));
 }
 
-void PanelPopupButton::setPopup(QPopupMenu *popup)
+void PanelPopupButton::setPopup(QWidget *popup)
 {
     if (m_popup)
     {
@@ -875,7 +905,7 @@ void PanelPopupButton::setPopup(QPopupMe
     }
 }
 
-QPopupMenu *PanelPopupButton::popup() const
+QWidget *PanelPopupButton::popup() const
 {
     return m_popup;
 }
@@ -954,7 +984,9 @@ void PanelPopupButton::slotExecMenu()
     }
 
     m_popup->adjustSize();
-    m_popup->exec(KickerLib::popupPosition(popupDirection(), m_popup, this));
+    if(dynamic_cast<QPopupMenu*>(m_popup))
+        static_cast<QPopupMenu*>(m_popup)->exec(KickerLib::popupPosition(popupDirection(), m_popup, this));
+    // else.. hmm. some derived class has to fix it.
 }
 
 void PanelPopupButton::menuAboutToHide()
@@ -964,8 +996,10 @@ void PanelPopupButton::menuAboutToHide()
         return;
     }
 
-    setDown(false);
-    KickerTip::enableTipping(true);
+    if (isDown()) {
+        setDown(false);
+        KickerTip::enableTipping(true);
+    }
 }
 
 void PanelPopupButton::triggerDrag()
@@ -983,3 +1017,5 @@ void PanelPopupButton::setInitialized(bo
     m_initialized = initialized;
 }
 
+
+
diff -Nurp kicker.orig/libkicker/panelbutton.cpp.orig kicker/libkicker/panelbutton.cpp.orig
--- kicker.orig/libkicker/panelbutton.cpp.orig	1970-01-01 00:00:00.000000000 +0000
+++ kicker/libkicker/panelbutton.cpp.orig	2008-08-19 18:16:55.000000000 +0000
@@ -0,0 +1,985 @@
+/*****************************************************************
+
+Copyright (c) 1996-2000 the kicker authors. See file AUTHORS.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#include <qcursor.h>
+#include <qfile.h>
+#include <qfontmetrics.h>
+#include <qpainter.h>
+#include <qpopupmenu.h>
+#include <qstyle.h>
+#include <qstylesheet.h>
+#include <qtooltip.h>
+
+#include <kapplication.h>
+#include <kconfig.h>
+#include <kcursor.h>
+#include <kdialog.h>
+#include <kdirwatch.h>
+#include <kglobal.h>
+#include <kglobalsettings.h>
+#include <kiconloader.h>
+#include <kicontheme.h>
+#include <kipc.h>
+#include <kstandarddirs.h>
+#include <klocale.h>
+
+#include "global.h"
+
+#include "kshadowengine.h"
+#include "kshadowsettings.h"
+
+#include "kickerSettings.h"
+#include "panelbutton.h"
+#include "panelbutton.moc"
+
+// init static variable
+KShadowEngine* PanelButton::s_textShadowEngine = 0L;
+
+PanelButton::PanelButton( QWidget* parent, const char* name )
+    : QButton(parent, name),
+      m_valid(true),
+      m_isLeftMouseButtonDown(false),
+      m_drawArrow(false),
+      m_highlight(false),
+      m_changeCursorOverItem(true),
+      m_hasAcceptedDrag(false),
+      m_arrowDirection(KPanelExtension::Bottom),
+      m_popupDirection(KPanelApplet::Up),
+      m_orientation(Horizontal),
+      m_size((KIcon::StdSizes)-1),
+      m_fontPercent(0.40)
+{
+    setBackgroundOrigin(AncestorOrigin);
+    setWFlags(WNoAutoErase);
+    KGlobal::locale()->insertCatalogue("libkicker");
+    calculateIconSize();
+    setAcceptDrops(true);
+
+    m_textColor = KGlobalSettings::textColor();
+
+    updateSettings(KApplication::SETTINGS_MOUSE);
+
+    kapp->addKipcEventMask(KIPC::SettingsChanged | KIPC::IconChanged);
+
+    installEventFilter(KickerTip::the());
+
+    connect(kapp, SIGNAL(settingsChanged(int)), SLOT(updateSettings(int)));
+    connect(kapp, SIGNAL(iconChanged(int)), SLOT(updateIcon(int)));
+}
+
+void PanelButton::configure()
+{
+    QString name = tileName();
+    if( name.isEmpty() )
+        return;
+
+    if (!KickerSettings::enableTileBackground())
+    {
+        setTile(QString::null);
+        return;
+    }
+
+    KConfigGroup tilesGroup( KGlobal::config(), "button_tiles" );
+    if( !tilesGroup.readBoolEntry( "Enable" + name + "Tiles", true ) ) {
+            setTile( QString::null );
+        return;
+    }
+
+    QString tile = tilesGroup.readEntry( name + "Tile" );
+    QColor color = QColor();
+
+    if (tile == "Colorize")
+    {
+        color = tilesGroup.readColorEntry( name + "TileColor" );
+        tile = QString::null;
+    }
+
+    setTile( tile, color );
+}
+
+void PanelButton::setTile(const QString& tile, const QColor& color)
+{
+    if (tile == m_tile && m_tileColor == color)
+    {
+        return;
+    }
+
+    m_tile = tile;
+    m_tileColor = color;
+    loadTiles();
+    update();
+}
+
+void PanelButton::setDrawArrow(bool drawArrow)
+{
+    if (m_drawArrow == drawArrow)
+    {
+        return;
+    }
+
+    m_drawArrow = drawArrow;
+    update();
+}
+
+QImage PanelButton::loadTile(const QString& tile,
+                             const QSize& size,
+                             const QString& state)
+{
+    QString name = tile;
+
+    if (size.height() < 42)
+    {
+        name += "_tiny_";
+    }
+    else if (size.height() < 54)
+    {
+        name += "_normal_";
+    }
+    else
+    {
+        name += "_large_";
+    }
+
+    name += state + ".png";
+
+    QImage tileImg(KGlobal::dirs()->findResource("tiles", name));
+
+    // scale if size does not match exactly
+    if (!tileImg.isNull() && tileImg.size() != size)
+    {
+        tileImg = tileImg.smoothScale(size);
+    }
+
+    return tileImg;
+}
+
+void PanelButton::setEnabled(bool enable)
+{
+    QButton::setEnabled(enable);
+    loadIcons();
+    update();
+}
+
+void PanelButton::setPopupDirection(KPanelApplet::Direction d)
+{
+    m_popupDirection = d;
+    setArrowDirection(KickerLib::directionToPopupPosition(d));
+}
+
+void PanelButton::setOrientation(Orientation o)
+{
+    m_orientation = o;
+}
+
+void PanelButton::updateIcon(int group)
+{
+    if (group != KIcon::Panel)
+    {
+        return;
+    }
+
+    loadIcons();
+    update();
+}
+
+void PanelButton::updateSettings(int category)
+{
+    if (category != KApplication::SETTINGS_MOUSE)
+    {
+        return;
+    }
+
+    m_changeCursorOverItem = KGlobalSettings::changeCursorOverIcon();
+
+    if (m_changeCursorOverItem)
+    {
+        setCursor(KCursor::handCursor());
+    }
+    else
+    {
+        unsetCursor();
+    }
+}
+
+void PanelButton::checkForDeletion(const QString& path)
+{
+    if (path == m_backingFile)
+    {
+        setEnabled(false);
+        QTimer::singleShot(1000, this, SLOT(scheduleForRemoval()));
+    }
+}
+
+bool PanelButton::checkForBackingFile()
+{
+    return QFile::exists(m_backingFile);
+}
+
+void PanelButton::scheduleForRemoval()
+{
+    static int timelapse = 1000;
+    if (checkForBackingFile())
+    {
+        setEnabled(true);
+        timelapse = 1000;
+        emit hideme(false);
+        return;
+    }
+    else if (KickerSettings::removeButtonsWhenBroken())
+    {
+        if (timelapse > 255*1000) // we'v given it ~8.5 minutes by this point
+        {
+            emit removeme();
+            return;
+        }
+
+        if (timelapse > 3000 && isVisible())
+        {
+            emit hideme(true);
+        }
+
+        timelapse *= 2;
+        QTimer::singleShot(timelapse, this, SLOT(scheduleForRemoval()));
+    }
+}
+
+// return the dimension that the button wants to be for a given panel dimension (panelDim)
+int PanelButton::preferredDimension(int panelDim) const
+{
+    // determine the upper limit on the size.  Normally, this is panelDim,
+    // but if conserveSpace() is true, we restrict size to comfortably fit the icon
+    if (KickerSettings::conserveSpace())
+    {
+        int newSize = preferredIconSize(panelDim);
+        if (newSize > 0)
+        {
+            return QMIN(panelDim, newSize + (KDialog::spacingHint() * 2));
+        }
+    }
+
+    return panelDim;
+}
+
+int PanelButton::widthForHeight(int height) const
+{
+    int rc = preferredDimension(height);
+
+    // we only paint the text when horizontal, so make sure we're horizontal
+    // before adding the text in here
+    if (orientation() == Horizontal && !m_buttonText.isEmpty())
+    {
+        QFont f(font());
+        f.setPixelSize(KMIN(height, KMAX(int(float(height) * m_fontPercent), 16)));
+        QFontMetrics fm(f);
+
+        rc += fm.width(m_buttonText) + KMIN(25, KMAX(5, fm.width('m') / 2));
+    }
+
+    return rc;
+}
+
+int PanelButton::heightForWidth(int width) const
+{
+    return preferredDimension(width);
+}
+
+const QPixmap& PanelButton::labelIcon() const
+{
+    return m_highlight ? m_iconh : m_icon;
+}
+
+const QPixmap& PanelButton::zoomIcon() const
+{
+    return m_iconz;
+}
+
+bool PanelButton::isValid() const
+{
+    return m_valid;
+}
+
+void PanelButton::setTitle(const QString& t)
+{
+    m_title = t;
+}
+
+void PanelButton::setIcon(const QString& icon)
+{
+    if (icon == m_iconName)
+    {
+        return;
+    }
+
+    m_iconName = icon;
+    loadIcons();
+    update();
+    emit iconChanged();
+}
+
+QString PanelButton::icon() const
+{
+    return m_iconName;
+}
+
+bool PanelButton::hasText() const
+{
+    return !m_buttonText.isEmpty();
+}
+
+void PanelButton::setButtonText(const QString& text)
+{
+    m_buttonText = text;
+    update();
+}
+
+QString PanelButton::buttonText() const
+{
+    return m_buttonText;
+}
+
+void PanelButton::setTextColor(const QColor& c)
+{
+    m_textColor = c;
+}
+
+QColor PanelButton::textColor() const
+{
+    return m_textColor;
+}
+
+void PanelButton::setFontPercent(double p)
+{
+    m_fontPercent = p;
+}
+
+double PanelButton::fontPercent() const
+{
+    return m_fontPercent;
+}
+
+KPanelExtension::Orientation PanelButton::orientation() const
+{
+    return m_orientation;
+}
+
+KPanelApplet::Direction PanelButton::popupDirection() const
+{
+    return m_popupDirection;
+}
+
+QPoint PanelButton::center() const
+{
+    return mapToGlobal(rect().center());
+}
+
+QString PanelButton::title() const
+{
+    return m_title;
+}
+
+void PanelButton::triggerDrag()
+{
+    setDown(false);
+
+    startDrag();
+}
+
+void PanelButton::startDrag()
+{
+    emit dragme(m_icon);
+}
+
+void PanelButton::enterEvent(QEvent* e)
+{
+    if (!m_highlight)
+    {
+        m_highlight = true;
+        repaint(false);
+    }
+
+    QButton::enterEvent(e);
+}
+
+void PanelButton::leaveEvent(QEvent* e)
+{
+    if (m_highlight)
+    {
+        m_highlight = false;
+        repaint(false);
+    }
+
+    QButton::leaveEvent(e);
+}
+
+void PanelButton::dragEnterEvent(QDragEnterEvent* e)
+{
+    if (e->isAccepted())
+    {
+        m_hasAcceptedDrag = true;
+    }
+
+    update();
+    QButton::dragEnterEvent( e );
+}
+
+void PanelButton::dragLeaveEvent(QDragLeaveEvent* e)
+{
+    m_hasAcceptedDrag = false;
+    update();
+    QButton::dragLeaveEvent( e );
+}
+
+void PanelButton::dropEvent(QDropEvent* e)
+{
+    m_hasAcceptedDrag = false;
+    update();
+    QButton::dropEvent( e );
+}
+
+void PanelButton::mouseMoveEvent(QMouseEvent *e)
+{
+    if (!m_isLeftMouseButtonDown || (e->state() & LeftButton) == 0)
+    {
+        return;
+    }
+
+    QPoint p(e->pos() - m_lastLeftMouseButtonPress);
+    if (p.manhattanLength() <= 16)
+    {
+        // KGlobalSettings::dndEventDelay() is not enough!
+        return;
+    }
+
+    m_isLeftMouseButtonDown = false;
+    triggerDrag();
+}
+
+void PanelButton::mousePressEvent(QMouseEvent *e)
+{
+    if (e->button() == LeftButton)
+    {
+        m_lastLeftMouseButtonPress = e->pos();
+        m_isLeftMouseButtonDown = true;
+    }
+    QButton::mousePressEvent(e);
+}
+
+void PanelButton::mouseReleaseEvent(QMouseEvent *e)
+{
+    if (e->button() == LeftButton)
+    {
+        m_isLeftMouseButtonDown = false;
+    }
+    QButton::mouseReleaseEvent(e);
+}
+
+void PanelButton::resizeEvent(QResizeEvent*)
+{
+    loadTiles();
+
+    if (calculateIconSize())
+    {
+        loadIcons();
+    }
+}
+
+void PanelButton::drawButton(QPainter *p)
+{
+    const QPixmap& tile = (isDown() || isOn()) ? m_down : m_up;
+    
+    if (m_tileColor.isValid())
+    {
+        p->fillRect(rect(), m_tileColor);
+        style().drawPrimitive(QStyle::PE_Panel, p, rect(), colorGroup());
+    }
+    else if (paletteBackgroundPixmap())
+    {
+        // Draw the background. This is always needed, even when using tiles,
+        // because they don't have to cover the entire button.
+        QPoint offset = backgroundOffset();
+        int ox = offset.x();
+        int oy = offset.y();
+        p->drawTiledPixmap( 0, 0, width(), height(),*paletteBackgroundPixmap(), ox, oy);
+    }
+
+    if (!tile.isNull())
+    {
+        // Draw the tile.
+        p->drawPixmap(0, 0, tile);
+    }
+    else if (isDown() || isOn())
+    {
+        // Draw shapes to indicate the down state.
+        style().drawPrimitive(QStyle::PE_Panel, p, rect(), colorGroup(), QStyle::Style_Sunken);
+    }
+
+    drawButtonLabel(p);
+
+    if (hasFocus() || m_hasAcceptedDrag)
+    {
+        int x1, y1, x2, y2;
+        rect().coords(&x1, &y1, &x2, &y2);
+        QRect r(x1+2, y1+2, x2-x1-3, y2-y1-3);
+        style().drawPrimitive(QStyle::PE_FocusRect, p, r, colorGroup(),
+        QStyle::Style_Default, colorGroup().button());
+    }
+}
+
+void PanelButton::drawButtonLabel(QPainter *p)
+{
+    QPixmap icon = labelIcon();
+    bool active = isDown() || isOn();
+
+    if (active)
+    {
+        icon = icon.convertToImage().smoothScale(icon.width() - 2,
+                                                 icon.height() - 2);
+    }
+
+    if (!m_buttonText.isEmpty() && orientation() == Horizontal)
+    {
+        int h = height();
+        int w = width();
+        int y = (h - icon.height())/2;
+        p->save();
+        QFont f = font();
+
+        double fontPercent = m_fontPercent;
+        if (active)
+        {
+            fontPercent *= .8;
+        }
+        f.setPixelSize(KMIN(h, KMAX(int(float(h) * m_fontPercent), 16)));
+        QFontMetrics fm(f);
+        p->setFont(f);
+
+        /* Draw shadowed text */
+        bool reverse = QApplication::reverseLayout();
+        QPainter::TextDirection rtl = reverse ? QPainter::RTL : QPainter::LTR;
+
+        if (!reverse && !icon.isNull())
+        {
+            /* Draw icon */
+            p->drawPixmap(3, y, icon);
+        }
+
+        int tX = reverse ? 3 : icon.width() + KMIN(25, KMAX(5, fm.width('m') / 2));
+        int tY = fm.ascent() + ((h - fm.height()) / 2);
+
+        QColor shadCol = KickerLib::shadowColor(m_textColor);
+
+        // get a transparent pixmap
+        QPainter pixPainter;
+        QPixmap textPixmap(w, h);
+
+        textPixmap.fill(QColor(0,0,0));
+        textPixmap.setMask(textPixmap.createHeuristicMask(true));
+
+        // draw text
+        pixPainter.begin(&textPixmap);
+        pixPainter.setPen(m_textColor);
+        pixPainter.setFont(p->font()); // get the font from the root painter
+        pixPainter.drawText(tX, tY, m_buttonText, -1, rtl);
+        pixPainter.end();
+
+        if (!s_textShadowEngine)
+        {
+            KShadowSettings* shadset = new KShadowSettings();
+            shadset->setOffsetX(0);
+            shadset->setOffsetY(0);
+            shadset->setThickness(1);
+            shadset->setMaxOpacity(96);
+            s_textShadowEngine = new KShadowEngine(shadset);
+        }
+
+        // draw shadow
+        QImage img = s_textShadowEngine->makeShadow(textPixmap, shadCol);
+        p->drawImage(0, 0, img);
+        p->save();
+        p->setPen(m_textColor);
+        p->drawText(tX, tY, m_buttonText, -1, rtl);
+        p->restore();
+
+        if (reverse && !icon.isNull())
+        {
+            p->drawPixmap(w - icon.width() - 3, y, icon);
+        }
+
+        p->restore();
+    }
+    else if (!icon.isNull())
+    {
+        int y = (height() - icon.height()) / 2;
+        int x = (width()  - icon.width()) / 2;
+        p->drawPixmap(x, y, icon);
+    }
+
+    if (m_drawArrow && (m_highlight || active))
+    {
+        QStyle::PrimitiveElement e = QStyle::PE_ArrowUp;
+        int arrowSize = style().pixelMetric(QStyle::PM_MenuButtonIndicator);
+        QRect r((width() - arrowSize)/2, 0, arrowSize, arrowSize);
+
+        switch (m_arrowDirection)
+        {
+            case KPanelExtension::Top:
+                e = QStyle::PE_ArrowUp;
+                break;
+            case KPanelExtension::Bottom:
+                e = QStyle::PE_ArrowDown;
+                r.moveBy(0, height() - arrowSize);
+                break;
+            case KPanelExtension::Right:
+                e = QStyle::PE_ArrowRight;
+                r = QRect(width() - arrowSize, (height() - arrowSize)/2, arrowSize, arrowSize);
+                break;
+            case KPanelExtension::Left:
+                e = QStyle::PE_ArrowLeft;
+                r = QRect(0, (height() - arrowSize)/2, arrowSize, arrowSize);
+                break;
+            case KPanelExtension::Floating:
+                if (orientation() == Horizontal)
+                {
+                    e = QStyle::PE_ArrowDown;
+                    r.moveBy(0, height() - arrowSize);
+                }
+                else if (QApplication::reverseLayout())
+                {
+                    e = QStyle::PE_ArrowLeft;
+                    r = QRect(0, (height() - arrowSize)/2, arrowSize, arrowSize);
+                }
+                else
+                {
+                    e = QStyle::PE_ArrowRight;
+                    r = QRect(width() - arrowSize, (height() - arrowSize)/2, arrowSize, arrowSize);
+                }
+                break;
+        }
+
+        int flags = QStyle::Style_Enabled;
+        if (active)
+        {
+            flags |= QStyle::Style_Down;
+        }
+        style().drawPrimitive(e, p, r, colorGroup(), flags);
+    }
+}
+
+// return the icon size that would be used if the panel were proposed_size
+// if proposed_size==-1, use the current panel size instead
+int PanelButton::preferredIconSize(int proposed_size) const
+{
+    // (re)calculates the icon sizes and report true if they have changed.
+    // Get sizes from icontheme. We assume they are sorted.
+    KIconTheme *ith = KGlobal::iconLoader()->theme();
+
+    if (!ith)
+    {
+        return -1; // unknown icon size
+    }
+
+    QValueList<int> sizes = ith->querySizes(KIcon::Panel);
+
+    int sz = ith->defaultSize(KIcon::Panel);
+
+    if (proposed_size < 0)
+    {
+        proposed_size = (orientation() == Horizontal) ? height() : width();
+    }
+
+    // determine the upper limit on the size.  Normally, this is panelSize,
+    // but if conserve space is requested, the max button size is used instead.
+    int upperLimit = proposed_size;
+    if (proposed_size > KickerLib::maxButtonDim() &&
+        KickerSettings::conserveSpace())
+    {
+        upperLimit = KickerLib::maxButtonDim();
+    }
+
+    //kdDebug()<<endl<<endl<<flush;
+    QValueListConstIterator<int> i = sizes.constBegin();
+    while (i != sizes.constEnd())
+    {
+        if ((*i) + (2 * KickerSettings::iconMargin()) > upperLimit)
+        {
+            break;
+        }
+        sz = *i;   // get the largest size under the limit
+        ++i;
+    }
+
+    //kdDebug()<<"Using icon sizes: "<<sz<<"  "<<zoom_sz<<endl<<flush;
+    return sz;
+}
+
+void PanelButton::backedByFile(const QString& localFilePath)
+{
+    m_backingFile = localFilePath;
+
+    if (m_backingFile.isEmpty())
+    {
+        return;
+    }
+
+    // avoid multiple connections
+    disconnect(KDirWatch::self(), SIGNAL(deleted(const QString&)),
+               this, SLOT(checkForDeletion(const QString&)));
+
+    if (!KDirWatch::self()->contains(m_backingFile))
+    {
+        KDirWatch::self()->addFile(m_backingFile);
+    }
+
+    connect(KDirWatch::self(), SIGNAL(deleted(const QString&)),
+            this, SLOT(checkForDeletion(const QString&)));
+
+}
+
+void PanelButton::setArrowDirection(KPanelExtension::Position dir)
+{
+    if (m_arrowDirection != dir)
+    {
+        m_arrowDirection = dir;
+        update();
+    }
+}
+
+void PanelButton::loadTiles()
+{
+    if (m_tileColor.isValid())
+    {
+        setBackgroundOrigin(WidgetOrigin);
+        m_up = m_down = QPixmap();
+    }
+    else if (m_tile.isNull())
+    {
+        setBackgroundOrigin(AncestorOrigin);
+        m_up = m_down = QPixmap();
+    }
+    else
+    {
+        setBackgroundOrigin(WidgetOrigin);
+        // If only the tiles were named a bit smarter we wouldn't have
+        // to pass the up or down argument.
+        m_up   = QPixmap(loadTile(m_tile, size(), "up"));
+        m_down = QPixmap(loadTile(m_tile, size(), "down"));
+    }
+}
+
+void PanelButton::loadIcons()
+{
+    KIconLoader * ldr = KGlobal::iconLoader();
+    QString nm = m_iconName;
+    KIcon::States defaultState = isEnabled() ? KIcon::DefaultState :
+                                               KIcon::DisabledState;
+    m_icon = ldr->loadIcon(nm, KIcon::Panel, m_size, defaultState, 0L, true);
+
+    if (m_icon.isNull())
+    {
+        nm = defaultIcon();
+        m_icon = ldr->loadIcon(nm, KIcon::Panel, m_size, defaultState);
+    }
+
+    if (!isEnabled())
+    {
+        m_iconh = m_icon;
+    }
+    else
+    {
+        m_iconh = ldr->loadIcon(nm, KIcon::Panel, m_size,
+                                KIcon::ActiveState, 0L, true);
+    }
+
+    m_iconz = ldr->loadIcon(nm, KIcon::Panel, KIcon::SizeHuge,
+                            defaultState, 0L, true );
+}
+
+// (re)calculates the icon sizes and report true if they have changed.
+//      (false if we don't know, because theme couldn't be loaded?)
+bool PanelButton::calculateIconSize()
+{
+    int size = preferredIconSize();
+
+    if (size < 0)
+    {
+        // size unknown
+        return false;
+    }
+
+    if (m_size != size)
+    {
+        // Size has changed, update
+        m_size = size;
+        return true;
+    }
+
+    return false;
+}
+
+void PanelButton::updateKickerTip(KickerTip::Data& data)
+{
+    data.message = QStyleSheet::escape(title());
+    data.subtext = QStyleSheet::escape(QToolTip::textFor(this));
+    data.icon = zoomIcon();
+    data.direction = popupDirection();
+}
+
+//
+// PanelPopupButton class
+//
+
+PanelPopupButton::PanelPopupButton(QWidget *parent, const char *name)
+  : PanelButton(parent, name),
+    m_popup(0),
+    m_pressedDuringPopup(false),
+    m_initialized(false)
+{
+    connect(this, SIGNAL(pressed()), SLOT(slotExecMenu()));
+}
+
+void PanelPopupButton::setPopup(QPopupMenu *popup)
+{
+    if (m_popup)
+    {
+        m_popup->removeEventFilter(this);
+        disconnect(m_popup, SIGNAL(aboutToHide()), this, SLOT(menuAboutToHide()));
+    }
+
+    m_popup = popup;
+    setDrawArrow(m_popup != 0);
+
+    if (m_popup)
+    {
+        m_popup->installEventFilter(this);
+        connect(m_popup, SIGNAL(aboutToHide()), this, SLOT(menuAboutToHide()));
+    }
+}
+
+QPopupMenu *PanelPopupButton::popup() const
+{
+    return m_popup;
+}
+
+bool PanelPopupButton::eventFilter(QObject *, QEvent *e)
+{
+    if (e->type() == QEvent::MouseMove)
+    {
+        QMouseEvent *me = static_cast<QMouseEvent *>(e);
+        if (rect().contains(mapFromGlobal(me->globalPos())) &&
+            ((me->state() & ControlButton) != 0 ||
+             (me->state() & ShiftButton) != 0))
+        {
+            PanelButton::mouseMoveEvent(me);
+            return true;
+        }
+    }
+    else if (e->type() == QEvent::MouseButtonPress ||
+             e->type() == QEvent::MouseButtonDblClick)
+    {
+        QMouseEvent *me = static_cast<QMouseEvent *>(e);
+        if (rect().contains(mapFromGlobal(me->globalPos())))
+        {
+            m_pressedDuringPopup = true;
+            return true;
+        }
+    }
+    else if (e->type() == QEvent::MouseButtonRelease)
+    {
+        QMouseEvent *me = static_cast<QMouseEvent *>(e);
+        if (rect().contains(mapFromGlobal(me->globalPos())))
+        {
+            if (m_pressedDuringPopup && m_popup)
+            {
+                m_popup->hide();
+            }
+            return true;
+        }
+    }
+    return false;
+}
+
+void PanelPopupButton::showMenu()
+{
+    if (isDown())
+    {
+        if (m_popup)
+        {
+            m_popup->hide();
+        }
+
+        setDown(false);
+        return;
+    }
+
+    setDown(true);
+    update();
+    slotExecMenu();
+}
+
+void PanelPopupButton::slotExecMenu()
+{
+    if (!m_popup)
+    {
+        return;
+    }
+
+    m_pressedDuringPopup = false;
+    KickerTip::enableTipping(false);
+    kapp->syncX();
+    kapp->processEvents();
+
+    if (!m_initialized)
+    {
+        initPopup();
+    }
+
+    m_popup->adjustSize();
+    m_popup->exec(KickerLib::popupPosition(popupDirection(), m_popup, this));
+}
+
+void PanelPopupButton::menuAboutToHide()
+{
+    if (!m_popup)
+    {
+        return;
+    }
+
+    setDown(false);
+    KickerTip::enableTipping(true);
+}
+
+void PanelPopupButton::triggerDrag()
+{
+    if (m_popup)
+    {
+        m_popup->hide();
+    }
+
+    PanelButton::triggerDrag();
+}
+
+void PanelPopupButton::setInitialized(bool initialized)
+{
+    m_initialized = initialized;
+}
+
diff -Nurp kicker.orig/libkicker/panelbutton.h kicker/libkicker/panelbutton.h
--- kicker.orig/libkicker/panelbutton.h	2006-01-19 17:01:40.000000000 +0000
+++ kicker/libkicker/panelbutton.h	2008-09-17 15:14:41.000000000 +0000
@@ -254,9 +254,11 @@ public slots:
     /**
      * Sets the direction to pop up the contents of the button.
      */
-    void setPopupDirection(KPanelApplet::Direction d);
+    virtual void setPopupDirection(KPanelApplet::Direction d);
 
 protected:
+
+    void setIconAlignment(AlignmentFlags align);
     /**
      * Subclasses must implement this to define the name of the button which is
      * used to identify this button for saving and loading. It must be unique
@@ -391,6 +393,7 @@ private:
     QPixmap m_iconz; // mouse over
     KPanelExtension::Position m_arrowDirection;
     KPanelApplet::Direction m_popupDirection;
+    AlignmentFlags m_iconAlignment;
     Orientation m_orientation;
     int m_size;
     double m_fontPercent;
@@ -419,12 +422,12 @@ public:
      * Sets the button's popup menu.
      * @param popup the menu to pop up
      */
-    void setPopup(QPopupMenu *popup);
+    void setPopup(QWidget *popup);
 
     /**
      * @return the button's popup menu
      */
-    QPopupMenu *popup() const;
+    QWidget *popup() const;
 
     bool eventFilter(QObject *, QEvent *);
     virtual void showMenu();
@@ -459,8 +462,8 @@ protected slots:
 private slots:
     void menuAboutToHide();
 
-private:
-    QPopupMenu *m_popup;
+protected:
+    QWidget *m_popup;
     bool m_pressedDuringPopup;
     bool m_initialized;
 
diff -Nurp kicker.orig/taskbar/taskbar.cpp kicker/taskbar/taskbar.cpp
--- kicker.orig/taskbar/taskbar.cpp	2008-08-19 18:16:54.000000000 +0000
+++ kicker/taskbar/taskbar.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -59,7 +59,8 @@ TaskBar::TaskBar( QWidget *parent, const
       m_showIcon(false),
       m_showOnlyIconified(false),
       m_textShadowEngine(0),
-      m_ignoreUpdates(false)
+      m_ignoreUpdates(false),
+      m_relayoutTimer(0, "TaskBar::m_relayoutTimer")
 {
     setFrameStyle( NoFrame );
 
diff -Nurp kicker.orig/taskbar/taskbar.cpp.orig kicker/taskbar/taskbar.cpp.orig
--- kicker.orig/taskbar/taskbar.cpp.orig	1970-01-01 00:00:00.000000000 +0000
+++ kicker/taskbar/taskbar.cpp.orig	2008-08-19 18:16:54.000000000 +0000
@@ -0,0 +1,1238 @@
+/*****************************************************************
+
+Copyright (c) 2001 Matthias Elter <elter@kde.org>
+Copyright (c) 2004 Sebastian Wolff
+Copyright (c) 2005 Aaron Seigo <aseigo@kde.org>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#include <math.h>
+
+#include <qapplication.h>
+#include <qbitmap.h>
+#include <qdesktopwidget.h>
+#include <qlayout.h>
+#include <qpainter.h>
+#include <qstringlist.h>
+
+#include <dcopclient.h>
+#include <kapplication.h>
+#include <kdebug.h>
+#include <kglobal.h>
+#include <kglobalaccel.h>
+#include <kimageeffect.h>
+#include <klocale.h>
+#include <kstandarddirs.h>
+
+#include "kickerSettings.h"
+#include "taskbarsettings.h"
+#include "taskcontainer.h"
+#include "taskmanager.h"
+
+#include "taskbar.h"
+#include "taskbar.moc"
+
+
+TaskBar::TaskBar( QWidget *parent, const char *name )
+    : Panner( parent, name ),
+      m_showAllWindows(false),
+      m_currentScreen(-1),
+      m_showOnlyCurrentScreen(false),
+      m_sortByDesktop(false),
+      m_showIcon(false),
+      m_showOnlyIconified(false),
+      m_textShadowEngine(0),
+      m_ignoreUpdates(false)
+{
+    setFrameStyle( NoFrame );
+
+    arrowType = LeftArrow;
+    blocklayout = true;
+    
+    // init
+    setSizePolicy( QSizePolicy( QSizePolicy::Expanding, QSizePolicy::Expanding ) );
+
+    // setup animation frames
+    for (int i = 1; i < 11; i++)
+    {
+        frames.append(new QPixmap(locate("data", "kicker/pics/disk" + QString::number(i) + ".png")));
+    }
+
+    // configure
+    configure();
+
+    connect(&m_relayoutTimer, SIGNAL(timeout()),
+            this, SLOT(reLayout()));
+
+    // connect manager
+    connect(TaskManager::the(), SIGNAL(taskAdded(Task::Ptr)),
+            this, SLOT(add(Task::Ptr)));
+    connect(TaskManager::the(), SIGNAL(taskRemoved(Task::Ptr)),
+            this, SLOT(remove(Task::Ptr)));
+    connect(TaskManager::the(), SIGNAL(startupAdded(Startup::Ptr)),
+            this, SLOT(add(Startup::Ptr)));
+    connect(TaskManager::the(), SIGNAL(startupRemoved(Startup::Ptr)),
+            this, SLOT(remove(Startup::Ptr)));
+    connect(TaskManager::the(), SIGNAL(desktopChanged(int)),
+            this, SLOT(desktopChanged(int)));
+    connect(TaskManager::the(), SIGNAL(windowChanged(Task::Ptr)),
+            this, SLOT(windowChanged(Task::Ptr)));
+
+    isGrouping = shouldGroup();
+
+    // register existant tasks
+    Task::Dict tasks = TaskManager::the()->tasks();
+    Task::Dict::iterator taskEnd = tasks.end();
+    for (Task::Dict::iterator it = tasks.begin(); it != taskEnd; ++it)
+    {
+        add(it.data());
+    }
+
+    // register existant startups
+    Startup::List startups = TaskManager::the()->startups();
+    Startup::List::iterator startupEnd = startups.end();
+    for (Startup::List::iterator sIt = startups.begin(); sIt != startupEnd; ++sIt)
+    {
+        add((*sIt));
+    }
+
+    blocklayout = false;
+
+    connect(kapp, SIGNAL(settingsChanged(int)), SLOT(slotSettingsChanged(int)));
+    keys = new KGlobalAccel( this );
+#include "taskbarbindings.cpp"
+    keys->readSettings();
+    keys->updateConnections();
+
+    reLayout();
+}
+
+TaskBar::~TaskBar()
+{
+    for (TaskContainer::Iterator it = m_hiddenContainers.begin();
+         it != m_hiddenContainers.end();
+         ++it)
+    {
+        (*it)->deleteLater();
+    }
+
+    for (TaskContainer::List::const_iterator it = containers.constBegin();
+         it != containers.constEnd();
+         ++it)
+    {
+        (*it)->deleteLater();
+    }
+
+    for (PixmapList::const_iterator it = frames.constBegin();
+         it != frames.constEnd();
+         ++it)
+    {
+        delete *it;
+    }
+
+    delete m_textShadowEngine;
+}
+
+KTextShadowEngine *TaskBar::textShadowEngine()
+{
+    if (!m_textShadowEngine)
+        m_textShadowEngine = new KTextShadowEngine();
+
+    return m_textShadowEngine;
+}
+
+
+QSize TaskBar::sizeHint() const
+{
+    // get our minimum height based on the minimum button height or the
+    // height of the font in use, which is largest
+    QFontMetrics fm(KGlobalSettings::taskbarFont());
+    int minButtonHeight = fm.height() > TaskBarSettings::minimumButtonHeight() ?
+                          fm.height() : TaskBarSettings::minimumButtonHeight();
+
+    return QSize(BUTTON_MIN_WIDTH, minButtonHeight);
+}
+
+QSize TaskBar::sizeHint( KPanelExtension::Position p, QSize maxSize) const
+{
+    // get our minimum height based on the minimum button height or the
+    // height of the font in use, which is largest
+    QFontMetrics fm(KGlobalSettings::taskbarFont());
+    int minButtonHeight = fm.height() > TaskBarSettings::minimumButtonHeight() ?
+                          fm.height() : TaskBarSettings::minimumButtonHeight();
+
+    if ( p == KPanelExtension::Left || p == KPanelExtension::Right )
+    {
+        int actualMax = minButtonHeight * containerCount();
+
+        if (containerCount() == 0)
+        {
+            actualMax = minButtonHeight;
+        }
+
+        if (actualMax > maxSize.height())
+        {
+            return maxSize;
+        }
+        return QSize( maxSize.width(), actualMax );
+    }
+    else
+    {
+        int rows = KickerSettings::conserveSpace() ?
+                   contentsRect().height() / minButtonHeight :
+                   1;
+        if ( rows < 1 )
+        {
+            rows = 1;
+        }
+
+        int maxWidth = TaskBarSettings::maximumButtonWidth();
+        if (maxWidth == 0)
+        {
+            maxWidth = BUTTON_MAX_WIDTH;
+        }
+
+        int actualMax = maxWidth * (containerCount() / rows);
+
+        if (containerCount() % rows > 0)
+        {
+            actualMax += maxWidth;
+        }
+        if (containerCount() == 0)
+        {
+            actualMax = maxWidth;
+        }
+
+        if (actualMax > maxSize.width())
+        {
+           return maxSize;
+        }
+        return QSize( actualMax, maxSize.height() );
+    }
+}
+
+void TaskBar::configure()
+{
+    bool wasShowWindows = m_showAllWindows;
+    bool wasSortByDesktop = m_sortByDesktop;
+    bool wasShowIcon = m_showIcon;
+    bool wasShowOnlyIconified = m_showOnlyIconified;
+
+    m_showAllWindows = TaskBarSettings::showAllWindows();
+    m_sortByDesktop = m_showAllWindows && TaskBarSettings::sortByDesktop();
+    m_showIcon = TaskBarSettings::showIcon();
+    m_showOnlyIconified = TaskBarSettings::showOnlyIconified();
+
+    m_currentScreen = -1;    // Show all screens or re-get our screen
+    m_showOnlyCurrentScreen = TaskBarSettings::showCurrentScreenOnly() &&
+                              QApplication::desktop()->isVirtualDesktop() &&
+                              QApplication::desktop()->numScreens() > 1;
+
+    // we need to watch geometry issues if we aren't showing windows when we
+    // are paying attention to the current Xinerama screen
+    if (m_showOnlyCurrentScreen)
+    {
+        // disconnect first in case we've been here before
+        // to avoid multiple connections
+        disconnect(TaskManager::the(), SIGNAL(windowChangedGeometry(Task::Ptr)),
+                    this, SLOT(windowChangedGeometry(Task::Ptr)));
+        connect(TaskManager::the(), SIGNAL(windowChangedGeometry(Task::Ptr)),
+                 this, SLOT(windowChangedGeometry(Task::Ptr)));
+    }
+    TaskManager::the()->trackGeometry(m_showOnlyCurrentScreen);
+
+    if (wasShowWindows != m_showAllWindows ||
+        wasSortByDesktop != m_sortByDesktop ||
+        wasShowIcon != m_showIcon ||
+        wasShowOnlyIconified != m_showOnlyIconified)
+    {
+        // relevant settings changed, update our task containers
+        for (TaskContainer::Iterator it = containers.begin();
+             it != containers.end();
+             ++it)
+        {
+            (*it)->settingsChanged();
+        }
+    }
+
+    TaskManager::the()->setXCompositeEnabled(TaskBarSettings::showThumbnails());
+
+    reLayoutEventually();
+}
+
+void TaskBar::setOrientation( Orientation o )
+{
+    Panner::setOrientation( o );
+    reLayoutEventually();
+}
+
+void TaskBar::moveEvent( QMoveEvent* e )
+{
+    Panner::moveEvent(e);
+    setViewportBackground();
+}
+
+void TaskBar::resizeEvent( QResizeEvent* e )
+{
+    if (m_showOnlyCurrentScreen)
+    {
+        QPoint topLeft = mapToGlobal(this->geometry().topLeft());
+        if (m_currentScreen != QApplication::desktop()->screenNumber(topLeft))
+        {
+            // we have been moved to another screen!
+            m_currentScreen = -1;
+            reGroup();
+        }
+    }
+
+    Panner::resizeEvent(e);
+    reLayoutEventually();
+}
+
+void TaskBar::add(Task::Ptr task)
+{
+    if (!task ||
+        (m_showOnlyCurrentScreen &&
+         !TaskManager::isOnScreen(showScreen(), task->window())))
+    {
+        return;
+    }
+
+    // try to group
+    if (isGrouping)
+    {
+        for (TaskContainer::Iterator it = containers.begin();
+             it != containers.end();
+             ++it)
+        {
+            TaskContainer* c = *it;
+
+            if (idMatch(task->classClass(), c->id()))
+            {
+                c->add(task);
+                reLayoutEventually();
+                return;
+            }
+        }
+    }
+
+    // create new container
+    TaskContainer *container = new TaskContainer(task, this, viewport());
+    m_hiddenContainers.append(container);
+
+    // even though there is a signal to listen to, we have to add this
+    // immediately to ensure grouping doesn't break (primarily on startup)
+    // we still add the container to m_hiddenContainers in case the event
+    // loop gets re-entered here and something bizarre happens. call it
+    // insurance =)
+    showTaskContainer(container);
+}
+
+void TaskBar::add(Startup::Ptr startup)
+{
+    if (!startup)
+    {
+        return;
+    }
+
+    for (TaskContainer::Iterator it = containers.begin();
+         it != containers.end();
+         ++it)
+    {
+        if ((*it)->contains(startup))
+        {
+            return;
+        }
+    }
+
+    // create new container
+    TaskContainer *container = new TaskContainer(startup, frames, this, viewport());
+    m_hiddenContainers.append(container);
+    connect(container, SIGNAL(showMe(TaskContainer*)), this, SLOT(showTaskContainer(TaskContainer*)));
+}
+
+void TaskBar::showTaskContainer(TaskContainer* container)
+{
+    TaskContainer::List::iterator it = m_hiddenContainers.find(container);
+    if (it != m_hiddenContainers.end())
+    {
+        m_hiddenContainers.erase(it);
+    }
+
+    if (container->isEmpty())
+    {
+        return;
+    }
+
+    // try to place the container after one of the same app
+    if (TaskBarSettings::sortByApp())
+    {
+        TaskContainer::Iterator it = containers.begin();
+        for (; it != containers.end(); ++it)
+        {
+            TaskContainer* c = *it;
+
+            if (container->id().lower() == c->id().lower())
+            {
+                // search for the last occurrence of this app
+                for (; it != containers.end(); ++it)
+                {
+                    c = *it;
+
+                    if (container->id().lower() != c->id().lower())
+                    {
+                        break;
+                    }
+                }
+                break;
+            }
+        }
+
+        if (it != containers.end())
+        {
+            containers.insert(it, container);
+        }
+        else
+        {
+            containers.append(container);
+        }
+    }
+    else
+    {
+        containers.append(container);
+    }
+
+    addChild(container);
+    reLayoutEventually();
+    emit containerCountChanged();
+}
+
+void TaskBar::remove(Task::Ptr task, TaskContainer* container)
+{
+    for (TaskContainer::Iterator it = m_hiddenContainers.begin();
+         it != m_hiddenContainers.end();
+         ++it)
+    {
+        if ((*it)->contains(task))
+        {
+            (*it)->finish();
+            m_deletableContainers.append(*it);
+            m_hiddenContainers.erase(it);
+            break;
+        }
+    }
+
+    if (!container)
+    {
+        for (TaskContainer::Iterator it = containers.begin();
+             it != containers.end();
+             ++it)
+        {
+            if ((*it)->contains(task))
+            {
+                container = *it;
+                break;
+            }
+        }
+
+        if (!container)
+        {
+            return;
+        }
+    }
+
+    container->remove(task);
+
+    if (container->isEmpty())
+    {
+        TaskContainer::List::iterator it = containers.find(container);
+        if (it != containers.end())
+        {
+            containers.erase(it);
+        }
+
+        removeChild(container);
+        container->finish();
+        m_deletableContainers.append(container);
+
+        reLayoutEventually();
+        emit containerCountChanged();
+    }
+    else if (container->filteredTaskCount() < 1)
+    {
+        reLayoutEventually();
+        emit containerCountChanged();
+    }
+}
+
+void TaskBar::remove(Startup::Ptr startup, TaskContainer* container)
+{
+    for (TaskContainer::Iterator it = m_hiddenContainers.begin();
+         it != m_hiddenContainers.end();
+         ++it)
+    {
+        if ((*it)->contains(startup))
+        {
+            (*it)->remove(startup);
+
+            if ((*it)->isEmpty())
+            {
+                (*it)->finish();
+                m_deletableContainers.append(*it);
+                m_hiddenContainers.erase(it);
+            }
+
+            break;
+        }
+    }
+
+    if (!container)
+    {
+        for (TaskContainer::Iterator it = containers.begin();
+             it != containers.end();
+             ++it)
+        {
+            if ((*it)->contains(startup))
+            {
+                container = *it;
+                break;
+            }
+        }
+
+        if (!container)
+        {
+            return;
+        }
+    }
+
+    container->remove(startup);
+    if (!container->isEmpty())
+    {
+        return;
+    }
+
+    TaskContainer::List::iterator it = containers.find(container);
+    if (it != containers.end())
+    {
+        containers.erase(it);
+    }
+
+    // startup containers only ever contain that one item. so
+    // just delete the poor bastard.
+    container->finish();
+    m_deletableContainers.append(container);
+    reLayoutEventually();
+    emit containerCountChanged();
+}
+
+void TaskBar::desktopChanged(int desktop)
+{
+    if (m_showAllWindows)
+    {
+        return;
+    }
+
+    m_relayoutTimer.stop();
+    m_ignoreUpdates = true;
+    for (TaskContainer::Iterator it = containers.begin();
+         it != containers.end();
+         ++it)
+    {
+        (*it)->desktopChanged(desktop);
+    }
+
+    m_ignoreUpdates = false;
+    reLayout();
+    emit containerCountChanged();
+}
+
+void TaskBar::windowChanged(Task::Ptr task)
+{
+    if (m_showOnlyCurrentScreen &&
+        !TaskManager::isOnScreen(showScreen(), task->window()))
+    {
+        return; // we don't care about this window
+    }
+
+    TaskContainer* container = 0;
+    for (TaskContainer::List::const_iterator it = containers.constBegin();
+         it != containers.constEnd();
+         ++it)
+    {
+        TaskContainer* c = *it;
+
+        if (c->contains(task))
+        {
+            container = c;
+            break;
+        }
+    }
+
+    // if we don't have a container or we're showing only windows on this
+    // desktop and the container is neither on the desktop nor currently visible
+    // just skip it
+    if (!container ||
+        (!m_showAllWindows &&
+         !container->onCurrentDesktop() &&
+         !container->isVisibleTo(this)))
+    {
+        return;
+    }
+
+    container->windowChanged(task);
+
+    if (!m_showAllWindows || m_showOnlyIconified)
+    {
+        emit containerCountChanged();
+    }
+
+    reLayoutEventually();
+}
+
+void TaskBar::windowChangedGeometry(Task::Ptr task)
+{
+    //TODO: this gets called every time a window's geom changes
+    //      when we are in "show only on the same Xinerama screen"
+    //      mode it would be Good(tm) to compress these events so this
+    //      gets run less often, but always when needed
+    TaskContainer* container = 0;
+    for (TaskContainer::Iterator it = containers.begin();
+         it != containers.end();
+         ++it)
+    {
+        TaskContainer* c = *it;
+        if (c->contains(task))
+        {
+            container = c;
+            break;
+        }
+    }
+
+    if ((!!container) == TaskManager::isOnScreen(showScreen(), task->window()))
+    {
+        // we have this window covered, so we don't need to do anything
+        return;
+    }
+
+    if (container)
+    {
+        remove(task, container);
+    }
+    else
+    {
+        add(task);
+    }
+}
+
+void TaskBar::reLayoutEventually()
+{
+    m_relayoutTimer.stop();
+
+    if (!blocklayout && !m_ignoreUpdates)
+    {
+        m_relayoutTimer.start(100, true);
+    }
+}
+
+void TaskBar::reLayout()
+{
+    // Because QPopupMenu::exec() creates its own event loop, deferred deletes
+    // via QObject::deleteLater() may be prematurely executed when a container's
+    // popup menu is visible.
+    //
+    // To get around this, we collect the containers and delete them manually
+    // when doing a relayout. (kling)
+    if (!m_deletableContainers.isEmpty()) {
+        TaskContainer::List::iterator it = m_deletableContainers.begin();
+        for (; it != m_deletableContainers.end(); ++it)
+            delete *it;
+        m_deletableContainers.clear();
+    }
+
+    // filter task container list
+    TaskContainer::List list = filteredContainers();
+
+    if (list.count() < 1)
+    {
+        resizeContents(contentsRect().width(), contentsRect().height());
+        return;
+    }
+
+    if (isGrouping != shouldGroup())
+    {
+        reGroup();
+        return;
+    }
+
+    // sort container list by desktop
+    if (m_sortByDesktop)
+    {
+        sortContainersByDesktop(list);
+    }
+
+    // needed because Panner doesn't know how big it's contents are so it's
+    // up to use to initialize it. =(
+    resizeContents(contentsRect().width(), contentsRect().height());
+
+    // number of rows simply depends on our height which is either the
+    // minimum button height or the height of the font in use, whichever is
+    // largest
+    QFontMetrics fm(KGlobalSettings::taskbarFont());
+    int minButtonHeight = fm.height() > TaskBarSettings::minimumButtonHeight() ?
+                          fm.height() : TaskBarSettings::minimumButtonHeight();
+
+    // horizontal layout
+    if (orientation() == Horizontal)
+    {
+        int bwidth = BUTTON_MIN_WIDTH;
+        int rows = contentsRect().height() / minButtonHeight;
+
+        if ( rows < 1 )
+        {
+            rows = 1;
+        }
+
+        // actual button height
+        int bheight = contentsRect().height() / rows;
+
+        // avoid zero devision later
+        if (bheight < 1)
+        {
+            bheight = 1;
+        }
+
+        // buttons per row
+        int bpr = (int)ceil( (double)list.count() / rows);
+
+        // adjust content size
+        if ( contentsRect().width() < bpr * BUTTON_MIN_WIDTH )
+        {
+            resizeContents( bpr * BUTTON_MIN_WIDTH, contentsRect().height() );
+        }
+
+        // maximum number of buttons per row
+        int mbpr = contentsRect().width() / BUTTON_MIN_WIDTH;
+
+        // expand button width if space permits
+        if (mbpr > bpr)
+        {
+            bwidth = contentsRect().width() / bpr;
+            int maxWidth = TaskBarSettings::maximumButtonWidth();
+            if (maxWidth > 0 && bwidth > maxWidth)
+            {
+                bwidth = maxWidth;
+            }
+        }
+
+        // layout containers
+
+        // for taskbars at the bottom, we need to ensure that the bottom
+        // buttons touch the bottom of the screen. since we layout from
+        // top to bottom this means seeing if we have any padding and
+        // popping it on the top. this preserves Fitt's Law behaviour
+        // for taskbars on the bottom
+        int topPadding = 0;
+        if (arrowType == UpArrow)
+        {
+            topPadding = contentsRect().height() % (rows * bheight);
+        }
+
+        int i = 0;
+        bool reverseLayout = QApplication::reverseLayout();
+        for (TaskContainer::Iterator it = list.begin();
+             it != list.end();
+             ++it, i++)
+        {
+            TaskContainer* c = *it;
+
+            int row = i % rows;
+
+            int x = ( i / rows ) * bwidth;
+            if (reverseLayout)
+            {
+                x = contentsRect().width() - x - bwidth;
+            }
+            int y = (row * bheight) + topPadding;
+
+            c->setArrowType(arrowType);
+            
+            if (childX(c) != x || childY(c) != y)
+                moveChild(c, x, y);
+                
+            if (c->width() != bwidth || c->height() != bheight)
+                c->resize( bwidth, bheight );
+                
+            c->setBackground();
+        }
+    }
+    else // vertical layout
+    {
+        // adjust content size
+        if (contentsRect().height() < (int)list.count() * minButtonHeight)
+        {
+            resizeContents(contentsRect().width(), list.count() * minButtonHeight);
+        }
+
+        // layout containers
+        int i = 0;
+        for (TaskContainer::Iterator it = list.begin();
+             it != list.end();
+             ++it)
+        {
+            TaskContainer* c = *it;
+
+            c->setArrowType(arrowType);
+            
+            if (c->width() != contentsRect().width() || c->height() != minButtonHeight)
+                c->resize(contentsRect().width(), minButtonHeight);
+
+            if (childX(c) != 0 || childY(c) != (i * minButtonHeight))
+                moveChild(c, 0, i * minButtonHeight);
+            
+            c->setBackground();
+            i++;
+        }
+    }
+    
+    QTimer::singleShot(100, this, SLOT(publishIconGeometry()));
+}
+
+void TaskBar::viewportResizeEvent( QResizeEvent* e )
+{
+    Panner::viewportResizeEvent(e);
+    setViewportBackground();
+}
+
+void TaskBar::setViewportBackground()
+{
+    const QPixmap *bg = parentWidget()->backgroundPixmap();
+    
+    viewport()->unsetPalette();
+    
+    if (bg)
+    {
+        QPixmap pm(parentWidget()->size());
+        pm.fill(parentWidget(), pos() + viewport()->pos());
+        viewport()->setPaletteBackgroundPixmap(pm);
+        viewport()->setBackgroundOrigin( WidgetOrigin );
+    }
+    else
+        viewport()->setPaletteBackgroundColor(paletteBackgroundColor());
+}
+
+void TaskBar::setBackground()
+{
+    setViewportBackground();
+    
+    TaskContainer::List list = filteredContainers();
+    
+    for (TaskContainer::Iterator it = list.begin();
+            it != list.end();
+            ++it)
+    {
+        TaskContainer* c = *it;
+        c->setBackground();
+    }
+}
+
+void TaskBar::setArrowType(Qt::ArrowType at)
+{
+    if (arrowType == at)
+    {
+        return;
+    }
+
+    arrowType = at;
+    for (TaskContainer::Iterator it = containers.begin();
+         it != containers.end();
+         ++it)
+    {
+        (*it)->setArrowType(arrowType);
+    }
+}
+
+void TaskBar::publishIconGeometry()
+{
+    QPoint p = mapToGlobal(QPoint(0,0)); // roundtrip, don't do that too often
+
+    for (TaskContainer::Iterator it = containers.begin();
+         it != containers.end();
+         ++it)
+    {
+        (*it)->publishIconGeometry(p);
+    }
+}
+
+void TaskBar::viewportMousePressEvent( QMouseEvent* e )
+{
+    propagateMouseEvent( e );
+}
+
+void TaskBar::viewportMouseReleaseEvent( QMouseEvent* e )
+{
+    propagateMouseEvent( e );
+}
+
+void TaskBar::viewportMouseDoubleClickEvent( QMouseEvent* e )
+{
+    propagateMouseEvent( e );
+}
+
+void TaskBar::viewportMouseMoveEvent( QMouseEvent* e )
+{
+    propagateMouseEvent( e );
+}
+
+void TaskBar::propagateMouseEvent( QMouseEvent* e )
+{
+    if ( !isTopLevel()  )
+    {
+        QMouseEvent me( e->type(), mapTo( topLevelWidget(), e->pos() ),
+                        e->globalPos(), e->button(), e->state() );
+        QApplication::sendEvent( topLevelWidget(), &me );
+    }
+}
+
+bool TaskBar::idMatch( const QString& id1, const QString& id2 )
+{
+    if ( id1.isEmpty() || id2.isEmpty() )
+        return false;
+
+    return id1.lower() == id2.lower();
+}
+
+int TaskBar::containerCount() const
+{
+    int i = 0;
+
+    for (TaskContainer::List::const_iterator it = containers.constBegin();
+         it != containers.constEnd();
+         ++it)
+    {
+        if ((m_showAllWindows || (*it)->onCurrentDesktop()) &&
+            ((showScreen() == -1) || ((*it)->isOnScreen())))
+        {
+            i++;
+        }
+    }
+
+    return i;
+}
+
+int TaskBar::taskCount() const
+{
+    int i = 0;
+
+    for (TaskContainer::List::const_iterator it = containers.constBegin();
+         it != containers.constEnd();
+         ++it)
+    {
+        if ((m_showAllWindows || (*it)->onCurrentDesktop()) &&
+            ((showScreen() == -1) || ((*it)->isOnScreen())))
+        {
+            i += (*it)->filteredTaskCount();
+        }
+    }
+
+    return i;
+}
+
+int TaskBar::maximumButtonsWithoutShrinking() const
+{
+    QFontMetrics fm(KGlobalSettings::taskbarFont());
+    int minButtonHeight = fm.height() > TaskBarSettings::minimumButtonHeight() ?
+                          fm.height() : TaskBarSettings::minimumButtonHeight();
+    int rows = contentsRect().height() / minButtonHeight;
+
+    if (rows < 1)
+    {
+        rows = 1;
+    }
+
+    if ( orientation() == Horizontal ) {
+        // maxWidth of 0 means no max width, drop back to default
+        int maxWidth = TaskBarSettings::maximumButtonWidth();
+        if (maxWidth == 0)
+        {
+            maxWidth = BUTTON_MAX_WIDTH;
+        }
+
+        // They squash a bit before they pop, hence the 2
+        return rows * (contentsRect().width() / maxWidth) + 2;
+    }
+    else
+    {
+        // Overlap slightly and ugly arrows appear, hence -1
+        return rows - 1;
+    }
+}
+
+bool TaskBar::shouldGroup() const
+{
+    return TaskBarSettings::groupTasks() == TaskBarSettings::GroupAlways ||
+           (TaskBarSettings::groupTasks() == TaskBarSettings::GroupWhenFull &&
+            taskCount() > maximumButtonsWithoutShrinking());
+}
+
+void TaskBar::reGroup()
+{
+    isGrouping = shouldGroup();
+    blocklayout = true;
+
+    TaskContainer::Iterator lastContainer = m_hiddenContainers.end();
+    for (TaskContainer::Iterator it = m_hiddenContainers.begin();
+         it != lastContainer;
+         ++it)
+    {
+        (*it)->finish();
+        m_deletableContainers.append(*it);
+    }
+    m_hiddenContainers.clear();
+
+    for (TaskContainer::List::const_iterator it = containers.constBegin();
+         it != containers.constEnd();
+         ++it)
+    {
+        (*it)->finish();
+        m_deletableContainers.append(*it);
+    }
+    containers.clear();
+
+    Task::Dict tasks = TaskManager::the()->tasks();
+    Task::Dict::iterator lastTask = tasks.end();
+    for (Task::Dict::iterator it = tasks.begin(); it != lastTask; ++it)
+    {
+        Task::Ptr task = it.data();
+        if (showScreen() == -1 || task->isOnScreen(showScreen()))
+        {
+            add(task);
+        }
+    }
+
+    Startup::List startups = TaskManager::the()->startups();
+    Startup::List::iterator itEnd = startups.end();
+    for (Startup::List::iterator sIt = startups.begin(); sIt != itEnd; ++sIt)
+    {
+        add(*sIt);
+    }
+
+    blocklayout = false;
+    reLayoutEventually();
+}
+
+
+TaskContainer::List TaskBar::filteredContainers()
+{
+    // filter task container list
+    TaskContainer::List list;
+
+    for (TaskContainer::List::const_iterator it = containers.constBegin();
+        it != containers.constEnd();
+        ++it)
+    {
+        TaskContainer* c = *it;
+        if ((m_showAllWindows || c->onCurrentDesktop()) &&
+            (!m_showOnlyIconified || c->isIconified()) &&
+            ((showScreen() == -1) || c->isOnScreen()))
+        {
+            list.append(c);
+            c->show();
+        }
+        else
+        {
+            c->hide();
+        }
+    }
+        
+    return list;
+}
+
+void TaskBar::activateNextTask(bool forward)
+{
+    bool forcenext = false;
+    TaskContainer::List list = filteredContainers();
+
+    // this is necessary here, because 'containers' is unsorted and
+    // we want to iterate over the _shown_ task containers in a linear way
+    if (m_sortByDesktop)
+    {
+        sortContainersByDesktop(list);
+    }
+
+    int numContainers = list.count();
+    TaskContainer::List::iterator it;
+    for (int i = 0; i < numContainers; ++i)
+    {
+        it = forward ? list.at(i) : list.at(numContainers - i - 1);
+
+        if (it != list.end() && (*it)->activateNextTask(forward, forcenext))
+        {
+            return;
+        }
+    }
+
+    if (forcenext)
+    {
+        // moving forward from the last, or backward from the first, loop around
+        for (int i = 0; i < numContainers; ++i)
+        {
+            it = forward ? list.at(i) : list.at(numContainers - i - 1);
+
+            if (it != list.end() && (*it)->activateNextTask(forward, forcenext))
+            {
+                return;
+            }
+        }
+
+        return;
+    }
+
+    forcenext = true; // select first
+    for (int i = 0; i < numContainers; ++i)
+    {
+        it = forward ? list.at(i) : list.at(numContainers - i - 1);
+
+        if (it == list.end())
+        {
+            break;
+        }
+
+        TaskContainer* c = *it;
+        if (m_sortByDesktop)
+        {
+            if (forward ? c->desktop() < TaskManager::the()->currentDesktop()
+                        : c->desktop() > TaskManager::the()->currentDesktop())
+            {
+                continue;
+            }
+        }
+
+        if (c->activateNextTask(forward, forcenext))
+        {
+            return;
+        }
+    }
+}
+
+void TaskBar::wheelEvent(QWheelEvent* e)
+{
+    if (e->delta() > 0)
+    {
+        // scroll away from user, previous task
+        activateNextTask(false);
+    }
+    else
+    {
+        // scroll towards user, next task
+        activateNextTask(true);
+    }
+}
+
+void TaskBar::slotActivateNextTask()
+{
+    activateNextTask( true );
+}
+
+void TaskBar::slotActivatePreviousTask()
+{
+    activateNextTask( false );
+}
+
+void TaskBar::slotSettingsChanged( int category )
+{
+    if( category == (int) KApplication::SETTINGS_SHORTCUTS )
+    {
+        keys->readSettings();
+        keys->updateConnections();
+    }
+}
+
+int TaskBar::showScreen() const
+{
+    if (m_showOnlyCurrentScreen && m_currentScreen == -1)
+    {
+        const_cast<TaskBar*>(this)->m_currentScreen =
+            QApplication::desktop()->screenNumber(mapToGlobal(this->geometry().topLeft()));
+    }
+
+    return m_currentScreen;
+}
+
+QImage* TaskBar::blendGradient(const QSize& size)
+{
+    if (m_blendGradient.isNull() || m_blendGradient.size() != size)
+    {
+        QPixmap bgpm(size);
+        QPainter bgp(&bgpm);
+        bgpm.fill(black);
+
+        if (QApplication::reverseLayout())
+        {
+            QImage gradient = KImageEffect::gradient(
+                    QSize(30, size.height()),
+                    QColor(255,255,255),
+                    QColor(0,0,0),
+                    KImageEffect::HorizontalGradient);
+            bgp.drawImage(0, 0, gradient);
+        }
+        else
+        {
+            QImage gradient = KImageEffect::gradient(
+                    QSize(30, size.height()),
+                    QColor(0,0,0),
+                    QColor(255,255,255),
+                    KImageEffect::HorizontalGradient);
+            bgp.drawImage(size.width() - 30, 0, gradient);
+        }
+
+        m_blendGradient = bgpm.convertToImage();
+    }
+
+    return &m_blendGradient;
+}
+
+void TaskBar::sortContainersByDesktop(TaskContainer::List& list)
+{
+    typedef QValueVector<QPair<int, QPair<int, TaskContainer*> > > SortVector;
+    SortVector sorted;
+    sorted.resize(list.count());
+    int i = 0;
+
+    TaskContainer::List::ConstIterator lastUnsorted(list.constEnd());
+    for (TaskContainer::List::ConstIterator it = list.constBegin();
+            it != lastUnsorted;
+            ++it)
+    {
+        sorted[i] = qMakePair((*it)->desktop(), qMakePair(i, *it));
+        ++i;
+    }
+
+    qHeapSort(sorted);
+
+    list.clear();
+    SortVector::const_iterator lastSorted(sorted.constEnd());
+    for (SortVector::const_iterator it = sorted.constBegin();
+         it != lastSorted;
+         ++it)
+    {
+        list.append((*it).second.second);
+    }
+}
+
diff -Nurp kicker.orig/taskbar/taskcontainer.cpp kicker/taskbar/taskcontainer.cpp
--- kicker.orig/taskbar/taskcontainer.cpp	2008-08-19 18:16:54.000000000 +0000
+++ kicker/taskbar/taskcontainer.cpp	2008-09-17 15:14:41.000000000 +0000
@@ -67,7 +67,11 @@ TaskContainer::TaskContainer(Task::Ptr t
       discardNextMouseEvent(false),
       aboutToActivate(false),
       m_mouseOver(false),
-      m_paintEventCompression(false)
+      animationTimer(0, "TaskContainer::animationTimer"),
+      dragSwitchTimer(0, "TaskContainer::dragSwitchTimer"),
+      attentionTimer(0, "TaskContainer::attentionTimer"),
+      m_paintEventCompression(false),
+      m_paintEventCompressionTimer(0, "TaskContainer::paintEventCompressionTimer")
 {
     init();
     setAcceptDrops(true); // Always enabled to activate task during drag&drop.
@@ -95,7 +99,11 @@ TaskContainer::TaskContainer(Startup::Pt
       discardNextMouseEvent(false),
       aboutToActivate(false),
       m_mouseOver(false),
-      m_paintEventCompression(false)
+      animationTimer(0, "TaskContainer::animationTimer"),
+      dragSwitchTimer(0, "TaskContainer::dragSwitchTimer"),
+      attentionTimer(0, "TaskContainer::attentionTimer"),
+      m_paintEventCompression(false),
+      m_paintEventCompressionTimer(0, "TaskContainer::paintEventCompressionTimer")
 {
     init();
     setEnabled(false);
